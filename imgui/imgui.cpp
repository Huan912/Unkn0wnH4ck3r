// dear imgui, v1.63
// (main code and documentation)

// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui
// Releases change-log at https://github.com/ocornut/imgui/releases
// Technical Support for Getting Started https://discourse.dearimgui.org/c/getting-started
// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269
// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// This library is free but I need your support to sustain development and maintenance.
// If you work for a company, please consider financial support, see README. For individuals: https://www.patreon.com/imgui

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

 Index
 - MISSION STATEMENT
 - END-USER GUIDE
 - PROGRAMMER GUIDE (read me!)
   - Read first
   - How to update to a newer version of Dear ImGui
   - Getting started with integrating Dear ImGui in your code/engine
   - Using gamepad/keyboard navigation controls [BETA]
 - API BREAKING CHANGES (read me when you update!)
 - ISSUES & TODO LIST
 - FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
   - How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
   - How can I display an image? What is ImTextureID, how does it works?
   - How can I have multiple widgets with the same label or without a label? A primer on labels and the ID Stack.
   - How can I use my own math types instead of ImVec2/ImVec4? 
   - How can I load a different font than the default?
   - How can I easily use icons in my application?
   - How can I load multiple fonts?
   - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?
   - How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
   - I integrated Dear ImGui in my engine and the text or lines are blurry..
   - I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
   - How can I help?
 - ISSUES & TODO-LIST
 - CODE


 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools
 - Easy to hack and improve
 - Minimize screen real-estate usage
 - Minimize setup and maintenance
 - Minimize state storage on user side
 - Portable, minimize dependencies, run on target (consoles, phones, etc.)
 - Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,
   opening a tree node for the first time, etc. but a typical frame should not allocate anything)

 Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:
 - Doesn't look fancy, doesn't animate
 - Limited layout features, intricate layouts are typically crafted in code


 END-USER GUIDE
 ==============

 - Double-click on title bar to collapse window.
 - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().
 - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
 - Click and drag on any empty space to move window.
 - TAB/SHIFT+TAB to cycle through keyboard editable fields.
 - CTRL+Click on a slider or drag box to input value as text.
 - Use mouse wheel to scroll.
 - Text editor:
   - Hold SHIFT or use mouse to select text.
   - CTRL+Left/Right to word jump.
   - CTRL+Shift+Left/Right to select words.
   - CTRL+A our Double-Click to select all.
   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
   - CTRL+Z,CTRL+Y to undo/redo.
   - ESCAPE to revert text to its original value.
   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.
 - General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.
 - General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW


 PROGRAMMER GUIDE
 ================

 READ FIRST

 - Read the FAQ below this section!
 - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction
   or destruction steps, less data retention on your side, less state duplication, less state synchronization, less bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
 - You can learn about immediate-mode gui principles at http://www.johno.se/book/imgui.html or watch http://mollyrocket.com/861

 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI

 - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - Try to keep your copy of dear imgui reasonably up to date.

 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE

 - Run and study the examples and demo to get acquainted with the library.
 - Add the Dear ImGui source files to your projects or using your preferred build system.
   It is recommended you build the .cpp files as part of your project and not as a library.
 - You can later customize the imconfig.h file to tweak some compilation time behavior, such as integrating imgui types with your own maths types.
 - You may be able to grab and copy a ready made imgui_impl_*** file from the examples/ folder.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering informatioe are stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.

 THIS IS HOW A SIMPLE APPLICATION MAY LOOK LIKE
 EXHIBIT 1: USING THE EXAMPLE BINDINGS (imgui_impl_XXX.cpp files from the examples/ folder)

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls
     // TODO: Fill optional settings of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer bindings (here we are using imgui_impl_win32 and imgui_impl_dx11)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }
     
     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 THIS IS HOW A SIMPLE APPLICATION MAY LOOK LIKE
 EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls
     // TODO: Fill optional settings of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = NULL;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that your your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ below for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->TexID = (void*)texture;

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform bindings)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.MousePos = my_mouse_pos;             // set the mouse position
        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states
        io.MouseDown[1] = my_mouse_buttons[1];

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use imgui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any ImGui functions as well!

        // Render imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use imgui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 THIS HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE

    void void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport using draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // The texture for the draw call is specified by pcmd->TextureId.
                 // The vast majority of draw calls with use the imgui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture(pcmd->TextureId);

                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everywhere else works!
                 // - Clipping coordinates are provided in imgui coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)
                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.
                 //   However, in the interest of supporting multi-viewport applications in the future, always subtract draw_data->DisplayPos from
                 //   clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 ImVec2 pos = draw_data->DisplayPos;
                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits if your engine doesn't support 16-bits indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
             }
             idx_buffer += pcmd->ElemCount;
          }
       }
    }

 - The examples/ folders contains many functional implementation of the pseudo-code above.
 - When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.
   They tell you if ImGui intends to use your inputs. When a flag is set you want to hide the corresponding inputs from the rest of your application.
   In both cases you need to pass on the inputs to imgui. Read the FAQ below for more information about those flags.
 - Please read the FAQ above. Amusingly, it is called a FAQ because people frequently have the same issues!

 USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS [BETA]

 - The gamepad/keyboard navigation is in Beta. Ask questions and report issues at https://github.com/ocornut/imgui/issues/787
 - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
 - Gamepad:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.
    - Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
      Note that io.NavInputs[] is cleared by EndFrame().
    - See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: goo.gl/9LgVZW.
    - If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo
      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
 - Keyboard:
    - Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.
      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
    - When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
      will be set. For more advanced uses, you may want to read from:
       - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
       - or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
      Please reach out if you think the game vs navigation input sharing could be improved.
 - Mouse:
    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
      Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.
      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.
      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)
      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
       to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink, io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details. 
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.
                       If your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.
                           ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)
                           {
                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;
                               return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);
                           }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         argument:   'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       font init:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>
                       became:     unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier;
                       you now more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.
                       it is now recommended that you sample the font texture with bilinear interpolation.
              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.
              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
              (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 ISSUES & TODO-LIST
 ==================
 See TODO.txt


 FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
 ======================================

 Q: How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
 A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the ImGuiIO structure (e.g. if (ImGui::GetIO().WantCaptureMouse) { ... } )
    - When 'io.WantCaptureMouse' is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantCaptureKeyboard' is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).
    Note: you should always pass your mouse/keyboard inputs to imgui, even when the io.WantCaptureXXX flag are set false.
     This is because imgui needs to detect that you clicked in the void to unfocus its windows.
    Note: The 'io.WantCaptureMouse' is more accurate that any attempt to "check if the mouse is hovering a window" (don't do that!).
     It handle mouse dragging correctly (both dragging that started over your application or over an imgui window) and handle e.g. modal windows blocking inputs.
     Those flags are updated by ImGui::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also
     perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to UpdateHoveredWindowAndCaptureFlags().
    Note: Text input widget releases focus on "Return KeyDown", so the subsequent "Return KeyUp" event that your application receive will typically
     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs
     were targeted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)

 Q: How can I display an image? What is ImTextureID, how does it works?
 A: Short explanation:
    - You may use functions such as ImGui::Image(), ImGui::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures.
    - Actual textures are identified in a way that is up to the user/engine.
    - Loading image files from the disk and turning them into a texture is not within the scope of Dear ImGui (for a good reason). 
      Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward.

    Long explanation:
    - Dear ImGui's job is to create "meshes", defined in a renderer-agnostic format made of draw commands and vertices.
      At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code
      to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.).
    - Each rendering function decides on a data type to represent "textures". The concept of what is a "texture" is entirely tied to your underlying engine/graphics API.
      We carry the information to identify a "texture" in the ImTextureID type. 
      ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice.
      Dear ImGui doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function.
    - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying 
      an image from the end-user perspective. This is what the _examples_ rendering functions are using:

         OpenGL:     ImTextureID = GLuint                       (see ImGui_ImplGlfwGL3_RenderDrawData() function in imgui_impl_glfw_gl3.cpp)
         DirectX9:   ImTextureID = LPDIRECT3DTEXTURE9           (see ImGui_ImplDX9_RenderDrawData()     function in imgui_impl_dx9.cpp)
         DirectX11:  ImTextureID = ID3D11ShaderResourceView*    (see ImGui_ImplDX11_RenderDrawData()    function in imgui_impl_dx11.cpp)
         DirectX12:  ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE  (see ImGui_ImplDX12_RenderDrawData()    function in imgui_impl_dx12.cpp)

      For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID. 
      Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure 
      tying together both the texture and information about its format and how to read it.
    - If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about
      the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase
      is designed. If your engine has high-level data types for "textures" and "material" then you may want to use them.
      If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID 
      representation suggested by the example bindings is probably the best choice.
      (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer)

    User code may do:

        // Cast our texture type to ImTextureID / void*
        MyTexture* texture = g_CoffeeTableTexture;
        ImGui::Image((void*)texture, ImVec2(texture->Width, texture->Height)); 

    The renderer function called after ImGui::Render() will receive that same value that the user code passed:

        // Cast ImTextureID / void* stored in the draw command as our texture type
        MyTexture* texture = (MyTexture*)pcmd->TextureId;
        MyEngineBindTexture2D(texture);

    Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear ImGui.
    This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them.
    If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using.

    Here's a simplified OpenGL example using stb_image.h:

        // Use stb_image.h to load a PNG from disk and turn it into raw RGBA pixel data:
        #define STB_IMAGE_IMPLEMENTATION
        #include <stb_image.h>
        [...]
        int my_image_width, my_image_height;
        unsigned char* my_image_data = stbi_load("my_image.png", &my_image_width, &my_image_height, NULL, 4);

        // Turn the RGBA pixel data into an OpenGL texture:
        GLuint my_opengl_texture;
        glGenTextures(1, &my_opengl_texture);
        glBindTexture(GL_TEXTURE_2D, my_opengl_texture);
        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);

        // Now that we have an OpenGL texture, assuming our imgui rendering function (imgui_impl_xxx.cpp file) takes GLuint as ImTextureID, we can display it:
        ImGui::Image((void*)(intptr_t)my_opengl_texture, ImVec2(my_image_width, my_image_height));

    C/C++ tip: a void* is pointer-sized storage. You may safely store any pointer or integer into it by casting your value to ImTexture / void*, and vice-versa. 
    Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTexture / void*.
    Examples:

        GLuint my_tex = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)(intptr_t)my_tex;                  // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer)
        my_tex = (GLuint)(intptr_t)my_void_ptr;                 // cast a void* into a GLuint

        ID3D11ShaderResourceView* my_dx11_srv = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)my_dx11_srv;                       // cast a ID3D11ShaderResourceView* into an opaque void*
        my_dx11_srv = (ID3D11ShaderResourceView*)my_void_ptr;   // cast a void* into a ID3D11ShaderResourceView*

    Finally, you may call ImGui::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.

 Q: How can I have multiple widgets with the same label or without a label?
 Q: I have multiple widgets with the same label, and only the first one works. Why is that?
 A: A primer on labels and the ID Stack...

    Dear ImGui internally need to uniquely identify UI elements.
    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.
    Interactive widgets (such as calls to Button buttons) need a unique ID. 
    Unique ID are used internally to track active widgets and occasionally associate state to widgets.
    Unique ID are implicitly built from the hash of multiple elements that identify the "path" to the UI element.

   - Unique ID are often derived from a string label:

       Button("OK");          // Label = "OK",     ID = hash of (..., "OK")
       Button("Cancel");      // Label = "Cancel", ID = hash of (..., "Cancel")

   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having
     two buttons labeled "OK" in different windows or different tree locations is fine.
     We used "..." above to signify whatever was already pushed to the ID stack previously:

       Begin("MyWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyWindow", "OK")
       End();

   - If you have a same ID twice in the same location, you'll have a conflict:

       Button("OK");
       Button("OK");          // ID collision! Interacting with either button will trigger the first one.

     Fear not! this is easy to solve and there are many ways to solve it!

   - Solving ID conflict in a simple/local context:
     When passing a label you can optionally specify extra ID information within string itself.
     Use "##" to pass a complement to the ID that won't be visible to the end-user.
     This helps solving the simple collision cases when you know e.g. at compilation time which items
     are going to be created:

       Begin("MyWindow");
       Button("Play");        // Label = "Play",   ID = hash of ("MyWindow", "Play")
       Button("Play##foo1");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo1")  // Different from above
       Button("Play##foo2");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo2")  // Different from above
       End();

   - If you want to completely hide the label, but still need an ID:

       Checkbox("##On", &b);  // Label = "",       ID = hash of (..., "##On")   // No visible label!

   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows
     you to animate labels. For example you may want to include varying information in a window title bar,
     but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:

       Button("Hello###ID";   // Label = "Hello",  ID = hash of (..., "ID")
       Button("World###ID";   // Label = "World",  ID = hash of (..., "ID")     // Same as above, even though the label looks different

       sprintf(buf, "My game (%f FPS)###MyGame", fps);
       Begin(buf);            // Variable label,   ID = hash of "MyGame"

   - Solving ID conflict in a more general manner:
     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts
     within the same window. This is the most convenient way of distinguishing ID when iterating and
     creating many UI elements programmatically.
     You can push a pointer, a string or an integer value into the ID stack.
     Remember that ID are formed from the concatenation of _everything_ in the ID stack!

       Begin("Window");
       for (int i = 0; i < 100; i++)
       {
         PushID(i);         // Push i to the id tack
         Button("Click");   // Label = "Click",  ID = Hash of ("Window", i, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj);
         Button("Click");   // Label = "Click",  ID = Hash of ("Window", obj pointer, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj->Name);
         Button("Click");   // Label = "Click",  ID = Hash of ("Window", obj->Name, "Click")
         PopID();
       }
       End();

   - More example showing that you can stack multiple prefixes into the ID stack:

       Button("Click");     // Label = "Click",  ID = hash of (..., "Click")
       PushID("node");
       Button("Click");     // Label = "Click",  ID = hash of (..., "node", "Click")
         PushID(my_ptr);
           Button("Click"); // Label = "Click",  ID = hash of (..., "node", my_ptr, "Click")
         PopID();
       PopID();

   - Tree nodes implicitly creates a scope for you by calling PushID().

       Button("Click");     // Label = "Click",  ID = hash of (..., "Click")
       if (TreeNode("node"))
       {
         Button("Click");   // Label = "Click",  ID = hash of (..., "node", "Click")
         TreePop();
       }

   - When working with trees, ID are used to preserve the open/close state of each tree node.
     Depending on your use cases you may want to use strings, indices or pointers as ID.
      e.g. when following a single pointer that may change over time, using a static string as ID
       will preserve your node open/closed state when the targeted object change.
      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the
       node open/closed state differently. See what makes more sense in your situation!

 Q: How can I use my own math types instead of ImVec2/ImVec4? 
 A: You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA/IM_VEC4_CLASS_EXTRA macros to add implicit type conversions.
    This way you'll be able to use your own types everywhere, e.g. passsing glm::vec2 to ImGui functions instead of ImVec2.

 Q: How can I load a different font than the default?
 A: Use the font atlas to load the TTF/OTF file you want:
      ImGuiIO& io = ImGui::GetIO();
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
    (default is ProggyClean.ttf, rendered at size 13, embedded in dear imgui's source code)

    New programmers: remember that in C/C++ and most programming languages if you want to use a
    backslash \ within a string literal, you need to write it double backslash "\\":
      io.Fonts->AddFontFromFileTTF("MyDataFolder\MyFontFile.ttf", size_in_pixels);   // WRONG (you are escape the M here!)
      io.Fonts->AddFontFromFileTTF("MyDataFolder\\MyFontFile.ttf", size_in_pixels);  // CORRECT
      io.Fonts->AddFontFromFileTTF("MyDataFolder/MyFontFile.ttf", size_in_pixels);   // ALSO CORRECT

 Q: How can I easily use icons in my application?
 A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you
    main font. Then you can refer to icons within your strings. Read 'How can I load multiple fonts?'
    and the file 'misc/fonts/README.txt' for instructions and useful header files.

 Q: How can I load multiple fonts?
 A: Use the font atlas to pack them into a single texture:
    (Read misc/fonts/README.txt and the code in ImFontAtlas for more details.)

      ImGuiIO& io = ImGui::GetIO();
      ImFont* font0 = io.Fonts->AddFontDefault();
      ImFont* font1 = io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      ImFont* font2 = io.Fonts->AddFontFromFileTTF("myfontfile2.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
      // the first loaded font gets used by default
      // use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime

      // Options
      ImFontConfig config;
      config.OversampleH = 3;
      config.OversampleV = 1;
      config.GlyphOffset.y -= 2.0f;      // Move everything by 2 pixels up
      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters
      io.Fonts->LoadFromFileTTF("myfontfile.ttf", size_pixels, &config);

      // Combine multiple fonts into one (e.g. for icon fonts)
      ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };
      ImFontConfig config;
      config.MergeMode = true;
      io.Fonts->AddFontDefault();
      io.Fonts->LoadFromFileTTF("fontawesome-webfont.ttf", 16.0f, &config, ranges); // Merge icon font
      io.Fonts->LoadFromFileTTF("myfontfile.ttf", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs

 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.

      // Add default Japanese ranges
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());

      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)
      ImVector<ImWchar> ranges;
      ImFontAtlas::GlyphRangesBuilder builder;
      builder.AddText("Hello world");                        // Add a string (here "Hello world" contains 7 unique characters)
      builder.AddChar(0x7262);                               // Add a specific character
      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges
      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, ranges.Data);

    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8
    by using the u8"hello" syntax. Specifying literal in your source code using a local code page
    (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!
    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.

    Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter(). 
    The applications in examples/ are doing that. 
    Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode).
    You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state.
    Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for 
    the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.

 Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
 A: - You can create a dummy window. Call SetNextWindowBgAlpha(0.0f), call Begin() with NoTitleBar|NoResize|NoMove|NoScrollbar|NoSavedSettings|NoInputs flags.
      Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.
    - You can call ImGui::GetOverlayDrawList() and use this draw list to display contents over every other imgui windows.
    - You can create your own ImDrawList instance. You'll need to initialize them ImGui::GetDrawListSharedData(), or create your own ImDrawListSharedData.

 Q: I integrated Dear ImGui in my engine and the text or lines are blurry..
 A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).
    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.

 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
 A: You are probably mishandling the clipping rectangles in your render function.
    Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).

 Q: How can I help?
 A: - If you are experienced with Dear ImGui and C++, look at the github issues, or TODO.txt and see how you want/can help!
    - Convince your company to fund development time! Individual users: you can also become a Patron (patreon.com/imgui) or donate on PayPal! See README.
    - Disclose your usage of dear imgui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/1269). Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).

 - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.
        this is also useful to set yourself in the context of another window (to get/set other settings)
 - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called "Debug".
 - tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle
        of a deep nested inner loop in your code.
 - tip: you can call Render() multiple times (e.g for VR renders).
 - tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui!

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#ifndef IMGUI_DEFINE_MATH_OPERATORS
#define IMGUI_DEFINE_MATH_OPERATORS
#endif
#include "imgui_internal.h"

#include <ctype.h>      // toupper, isprint
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

#define IMGUI_DEBUG_NAV_SCORING     0
#define IMGUI_DEBUG_NAV_RECTS       0

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127) // condition expression is constant
#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast" // warning : cast to 'void *' from smaller integer type 'int'
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

#include "..//XorStr/obfuscation.h"

static const ImS32  IM_S32_MIN = INT_MIN;    // (-2147483647 - 1), (0x80000000);
static const ImS32  IM_S32_MAX = INT_MAX;    // (2147483647), (0x7FFFFFFF)
static const ImU32  IM_U32_MIN = 0;
static const ImU32  IM_U32_MAX = UINT_MAX;   // (0xFFFFFFFF)
#ifdef LLONG_MIN
static const ImS64  IM_S64_MIN = LLONG_MIN;  // (-9223372036854775807ll - 1ll);
static const ImS64  IM_S64_MAX = LLONG_MAX;  // (9223372036854775807ll);
#else
static const ImS64  IM_S64_MIN = -9223372036854775807LL - 1;
static const ImS64  IM_S64_MAX = 9223372036854775807LL;
#endif
static const ImU64  IM_U64_MIN = 0;
#ifdef ULLONG_MAX
static const ImU64  IM_U64_MAX = ULLONG_MAX; // (0xFFFFFFFFFFFFFFFFull);
#else
static const ImU64  IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);
#endif

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY   = 0.20f; // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY = 0.15f; // Time before the window list starts to appear

//-------------------------------------------------------------------------
// Forward Declarations
//-------------------------------------------------------------------------

static void             SetCurrentWindow(ImGuiWindow* window);
static void             SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);
static void             SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);
static void             SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);
static void             FindHoveredWindow();
static ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);
static ImGuiWindowSettings* CreateNewWindowSettings(const char* name);
static void             CheckStacksSize(ImGuiWindow* window, bool write);
static ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges);

static void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void             AddWindowToDrawData(ImVector<ImDrawList*>* out_list, ImGuiWindow* window);
static void             AddWindowToSortedBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);

static ImRect           GetViewportRect();

static bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data);
static int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);
static ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);

static inline int       DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format);
static void             DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);
static bool             DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format);

namespace ImGui
{
static bool             BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags);

static void             NavUpdate();
static void             NavUpdateWindowing();
static void             NavUpdateWindowingList();
static void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id);

static void             UpdateMouseInputs();
static void             UpdateMouseWheel();
static void             UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);

// Template widget behaviors
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
static bool             DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power);

template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
static bool             SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb);
}

//-----------------------------------------------------------------------------
// Platform dependent default implementations
//-----------------------------------------------------------------------------

static const char*      GetClipboardTextFn_DefaultImpl(void* user_data);
static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);
static void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);

//-----------------------------------------------------------------------------
// Context and Memory Allocators
//-----------------------------------------------------------------------------

// Current context pointer. Implicitly used by all ImGui functions. Always assumed to be != NULL.
// CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().
// If you use DLL hotreloading you might need to call SetCurrentContext() after reloading code from this file.
// ImGui functions are not thread-safe because of this pointer. If you want thread-safety to allow N threads to access N different contexts, you can:
// - Change this variable to use thread local storage. You may #define GImGui in imconfig.h for that purpose. Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
// - Having multiple instances of the ImGui code compiled inside different namespace (easiest/safest, if you have a finite number of contexts)
#ifndef GImGui
ImGuiContext*   GImGui = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.
// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void*   MallocWrapper(size_t size, void* user_data)    { (void)user_data; return malloc(size); }
static void    FreeWrapper(void* ptr, void* user_data)        { (void)user_data; free(ptr); }
#else
static void*   MallocWrapper(size_t size, void* user_data)    { (void)user_data; (void)size; IM_ASSERT(0); return NULL; }
static void    FreeWrapper(void* ptr, void* user_data)        { (void)user_data; (void)ptr; IM_ASSERT(0); }
#endif

static void*  (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;
static void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;
static void*    GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// User facing structures
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle()
{
    Alpha                   = 1.0f;             // Global alpha applies to everything in ImGui
    WindowPadding           = ImVec2(8,8);      // Padding within a window
    WindowRounding          = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
    WindowBorderSize        = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    WindowMinSize           = ImVec2(32,32);    // Minimum window size
    WindowTitleAlign        = ImVec2(0.0f,0.5f);// Alignment for title bar text
    ChildRounding           = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
    ChildBorderSize         = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    PopupRounding           = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
    PopupBorderSize         = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    FramePadding            = ImVec2(4,3);      // Padding within a framed rectangle (used by most widgets)
    FrameRounding           = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
    FrameBorderSize         = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
    ItemSpacing             = ImVec2(8,4);      // Horizontal and vertical spacing between widgets/lines
    ItemInnerSpacing        = ImVec2(4,4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
    TouchExtraPadding       = ImVec2(0,0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    IndentSpacing           = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    ColumnsMinSpacing       = 6.0f;             // Minimum horizontal spacing between two columns
    ScrollbarSize           = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
    ScrollbarRounding       = 9.0f;             // Radius of grab corners rounding for scrollbar
    GrabMinSize             = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
    GrabRounding            = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    ButtonTextAlign         = ImVec2(0.5f,0.5f);// Alignment of button text when button is larger than text.
    DisplayWindowPadding    = ImVec2(20,20);    // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.
    DisplaySafeAreaPadding  = ImVec2(3,3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
    MouseCursorScale        = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    AntiAliasedLines        = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.
    AntiAliasedFill         = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    CurveTessellationTol    = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

    // Default theme
    ImGui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes(float scale_factor)
{
    WindowPadding = ImFloor(WindowPadding * scale_factor);
    WindowRounding = ImFloor(WindowRounding * scale_factor);
    WindowMinSize = ImFloor(WindowMinSize * scale_factor);
    ChildRounding = ImFloor(ChildRounding * scale_factor);
    PopupRounding = ImFloor(PopupRounding * scale_factor);
    FramePadding = ImFloor(FramePadding * scale_factor);
    FrameRounding = ImFloor(FrameRounding * scale_factor);
    ItemSpacing = ImFloor(ItemSpacing * scale_factor);
    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
    IndentSpacing = ImFloor(IndentSpacing * scale_factor);
    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
    GrabMinSize = ImFloor(GrabMinSize * scale_factor);
    GrabRounding = ImFloor(GrabRounding * scale_factor);
    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO()
{
    // Most fields are initialized with zero
    memset(this, 0, sizeof(*this));

    // Settings
    ConfigFlags = 0x00;
    BackendFlags = 0x00;
    DisplaySize = ImVec2(-1.0f, -1.0f);
    DeltaTime = 1.0f/60.0f;
    IniSavingRate = 5.0f;
    IniFilename = XorString("imgui.ini");
    LogFilename = XorString("imgui_log.txt");
    MouseDoubleClickTime = 0.30f;
    MouseDoubleClickMaxDist = 6.0f;
    for (int i = 0; i < ImGuiKey_COUNT; i++)
        KeyMap[i] = -1;
    KeyRepeatDelay = 0.250f;
    KeyRepeatRate = 0.050f;
    UserData = NULL;

    Fonts = NULL;
    FontGlobalScale = 1.0f;
    FontDefault = NULL;
    FontAllowUserScaling = false;
    DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
    DisplayVisibleMin = DisplayVisibleMax = ImVec2(0.0f, 0.0f);

    // Miscellaneous configuration options
#ifdef __APPLE__
    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
    ConfigMacOSXBehaviors = false;
#endif
    ConfigCursorBlink = true;
    ConfigResizeWindowsFromEdges = false;

    // Settings (User Functions)
    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
    ClipboardUserData = NULL;
    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
    ImeWindowHandle = NULL;

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    RenderDrawListsFn = NULL;
#endif

    // Input (NB: we already have memset zero the entire structure)
    MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
    MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
    MouseDragThreshold = 6.0f;
    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i]  = KeysDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void ImGuiIO::AddInputCharacter(ImWchar c)
{
    const int n = ImStrlenW(InputCharacters);
    if (n + 1 < IM_ARRAYSIZE(InputCharacters))
    {
        InputCharacters[n] = c;
        InputCharacters[n+1] = '\0';
    }
}

void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
{
    // We can't pass more wchars than ImGuiIO::InputCharacters[] can hold so don't convert more
    const int wchars_buf_len = sizeof(ImGuiIO::InputCharacters) / sizeof(ImWchar);
    ImWchar wchars[wchars_buf_len];
    ImTextStrFromUtf8(wchars, wchars_buf_len, utf8_chars, NULL);
    for (int i = 0; i < wchars_buf_len && wchars[i] != 0; i++)
        AddInputCharacter(wchars[i]);
}

//-----------------------------------------------------------------------------
// HELPERS
//-----------------------------------------------------------------------------

ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
{
    ImVec2 ap = p - a;
    ImVec2 ab_dir = b - a;
    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0f)
        return a;
    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)
        return b;
    return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
{
    ImVec2 v0 = b - a;
    ImVec2 v1 = c - a;
    ImVec2 v2 = p - a;
    const float denom = v0.x * v1.y - v1.x * v0.y;
    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
    ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
    ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
    ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
    float dist2_ab = ImLengthSqr(p - proj_ab);
    float dist2_bc = ImLengthSqr(p - proj_bc);
    float dist2_ca = ImLengthSqr(p - proj_ca);
    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}

int ImStricmp(const char* str1, const char* str2)
{
    int d;
    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }
    return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
    int d = 0;
    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
    if (count < 1) return;
    strncpy(dst, src, count);
    dst[count-1] = 0;
}

char* ImStrdup(const char *str)
{
    size_t len = strlen(str) + 1;
    void* buf = ImGui::MemAlloc(len);
    return (char*)memcpy(buf, (const void*)str, len);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
    for ( ; str < str_end; str++)
        if (*str == c)
            return str;
    return NULL;
}

int ImStrlenW(const ImWchar* str)
{
    int n = 0;
    while (*str++) n++;
    return n;
}

const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line
{
    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
        buf_mid_line--;
    return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
    if (!needle_end)
        needle_end = needle + strlen(needle);

    const char un0 = (char)toupper(*needle);
    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    {
        if (toupper(*haystack) == un0)
        {
            const char* b = needle + 1;
            for (const char* a = haystack + 1; b < needle_end; a++, b++)
                if (toupper(*a) != toupper(*b))
                    break;
            if (b == needle_end)
                return haystack;
        }
        haystack++;
    }
    return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks(char* buf)
{
    char* p = buf;
    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks
        p++;
    char* p_start = p;
    while (*p != 0)                         // Find end of string
        p++;
    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
        p--;
    if (p_start != buf)                     // Copy memory if we had leading blanks
        memmove(buf, p_start, p - p_start);
    buf[p - p_start] = 0;                   // Zero terminate
}

template<typename TYPE>
static const char* ImAtoi(const char* src, TYPE* output)
{
    int negative = 0;
    if (*src == '-') { negative = 1; src++; }
    if (*src == '+') { src++; }
    TYPE v = 0;
    while (*src >= '0' && *src <= '9')
        v = (v * 10) + (*src++ - '0');
    *output = negative ? -v : v;
    return src;
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    int w = vsnprintf(buf, buf_size, fmt, args);
    va_end(args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{
    int w = vsnprintf(buf, buf_size, fmt, args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}
#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

// Pass data_size==0 for zero-terminated strings
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHash(const void* data, int data_size, ImU32 seed)
{
    static ImU32 crc32_lut[256] = { 0 };
    if (!crc32_lut[1])
    {
        const ImU32 polynomial = 0xEDB88320;
        for (ImU32 i = 0; i < 256; i++)
        {
            ImU32 crc = i;
            for (ImU32 j = 0; j < 8; j++)
                crc = (crc >> 1) ^ (ImU32(-int(crc & 1)) & polynomial);
            crc32_lut[i] = crc;
        }
    }

    seed = ~seed;
    ImU32 crc = seed;
    const unsigned char* current = (const unsigned char*)data;

    if (data_size > 0)
    {
        // Known size
        while (data_size--)
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *current++];
    }
    else
    {
        // Zero-terminated string
        while (unsigned char c = *current++)
        {
            // We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
            // Because this syntax is rarely used we are optimizing for the common case.
            // - If we reach ### in the string we discard the hash so far and reset to the seed.
            // - We don't do 'current += 2; continue;' after handling ### to keep the code smaller.
            if (c == '#' && current[0] == '#' && current[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    return ~crc;
}

//-----------------------------------------------------------------------------
// ImText* helpers
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bits character, process single character input.
// Based on stb_from_utf8() from github.com/nothings/stb/
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
    unsigned int c = (unsigned int)-1;
    const unsigned char* str = (const unsigned char*)in_text;
    if (!(*str & 0x80))
    {
        c = (unsigned int)(*str++);
        *out_char = c;
        return 1;
    }
    if ((*str & 0xe0) == 0xc0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 2) return 1;
        if (*str < 0xc2) return 2;
        c = (unsigned int)((*str++ & 0x1f) << 6);
        if ((*str & 0xc0) != 0x80) return 2;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 2;
    }
    if ((*str & 0xf0) == 0xe0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 3) return 1;
        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;
        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x0f) << 12);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 3;
    }
    if ((*str & 0xf8) == 0xf0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 4) return 1;
        if (*str > 0xf4) return 4;
        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;
        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x07) << 18);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 12);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (*str++ & 0x3f);
        // utf-8 encodings of values used in surrogate pairs are invalid
        if ((c & 0xFFFFF800) == 0xD800) return 4;
        *out_char = c;
        return 4;
    }
    *out_char = 0;
    return 0;
}

int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
    ImWchar* buf_out = buf;
    ImWchar* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes
            *buf_out++ = (ImWchar)c;
    }
    *buf_out = 0;
    if (in_text_remaining)
        *in_text_remaining = in_text;
    return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
    int char_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)
            char_count++;
    }
    return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
    if (c < 0x80)
    {
        buf[0] = (char)c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) return 0;
        buf[0] = (char)(0xc0 + (c >> 6));
        buf[1] = (char)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c >= 0xdc00 && c < 0xe000)
    {
        return 0;
    }
    if (c >= 0xd800 && c < 0xdc00)
    {
        if (buf_size < 4) return 0;
        buf[0] = (char)(0xf0 + (c >> 18));
        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (char)(0x80 + ((c ) & 0x3f));
        return 4;
    }
    //else if (c < 0x10000)
    {
        if (buf_size < 3) return 0;
        buf[0] = (char)(0xe0 + (c >> 12));
        buf[1] = (char)(0x80 + ((c>> 6) & 0x3f));
        buf[2] = (char)(0x80 + ((c ) & 0x3f));
        return 3;
    }
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
{
    unsigned int dummy = 0;
    return ImTextCharFromUtf8(&dummy, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c >= 0xdc00 && c < 0xe000) return 0;
    if (c >= 0xd800 && c < 0xdc00) return 4;
    return 3;
}

int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
{
    char* buf_out = buf;
    const char* buf_end = buf + buf_size;
    while (buf_out < buf_end-1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            *buf_out++ = (char)c;
        else
            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end-buf_out-1), c);
    }
    *buf_out = 0;
    return (int)(buf_out - buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
{
    int bytes_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            bytes_count++;
        else
            bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
{
    float s = 1.0f/255.0f;
    return ImVec4(
        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
{
    ImU32 out;
    out  = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
    return out;
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4& col)
{
    ImGuiStyle& style = GImGui->Style;
    ImVec4 c = col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
{
    ImGuiStyle& style = GImGui->Style;
    return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col)
{
    float style_alpha = GImGui->Style.Alpha;
    if (style_alpha >= 1.0f)
        return col;
    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
    float K = 0.f;
    if (g < b)
    {
        ImSwap(g, b);
        K = -1.f;
    }
    if (r < g)
    {
        ImSwap(r, g);
        K = -2.f / 6.f - K;
    }

    const float chroma = r - (g < b ? g : b);
    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
    out_s = chroma / (r + 1e-20f);
    out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
    if (s == 0.0f)
    {
        // gray
        out_r = out_g = out_b = v;
        return;
    }

    h = ImFmod(h, 1.0f) / (60.0f/360.0f);
    int   i = (int)h;
    float f = h - (float)i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));

    switch (i)
    {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
    }
}

FILE* ImFileOpen(const char* filename, const char* mode)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;
    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;
    ImVector<ImWchar> buf;
    buf.resize(filename_wsize + mode_wsize);
    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);
    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);
    return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);
#else
    return fopen(filename, mode);
#endif
}

// Load file content into memory
// Memory allocated with ImGui::MemAlloc(), must be freed by user using ImGui::MemFree()
void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size, int padding_bytes)
{
    IM_ASSERT(filename && file_open_mode);
    if (out_file_size)
        *out_file_size = 0;

    FILE* f;
    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)
        return NULL;

    long file_size_signed;
    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))
    {
        fclose(f);
        return NULL;
    }

    size_t file_size = (size_t)file_size_signed;
    void* file_data = ImGui::MemAlloc(file_size + padding_bytes);
    if (file_data == NULL)
    {
        fclose(f);
        return NULL;
    }
    if (fread(file_data, 1, file_size, f) != file_size)
    {
        fclose(f);
        ImGui::MemFree(file_data);
        return NULL;
    }
    if (padding_bytes > 0)
        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

    fclose(f);
    if (out_file_size)
        *out_file_size = file_size;

    return file_data;
}

//-----------------------------------------------------------------------------
// ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)
{
    ImVector<ImGuiStorage::Pair>::iterator first = data.begin();
    ImVector<ImGuiStorage::Pair>::iterator last = data.end();
    size_t count = (size_t)(last - first);
    while (count > 0)
    {
        size_t count2 = count >> 1;
        ImVector<ImGuiStorage::Pair>::iterator mid = first + count2;
        if (mid->key < key)
        {
            first = ++mid;
            count -= count2 + 1;
        }
        else
        {
            count = count2;
        }
    }
    return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey()
{
    struct StaticFunc
    {
        static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)
        {
            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;
            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;
            return 0;
        }
    };
    if (Data.Size > 1)
        ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
{
    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
{
    return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
{
    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_f;
}

void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
{
    ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return NULL;
    return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
{
    return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt(ImGuiID key, int val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val)
{
    SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
{
    ImVector<Pair>::iterator it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v)
{
    for (int i = 0; i < Data.Size; i++)
        Data[i].val_i = v;
}

//-----------------------------------------------------------------------------
// ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)
{
    if (default_filter)
    {
        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
        Build();
    }
    else
    {
        InputBuf[0] = 0;
        CountGrep = 0;
    }
}

bool ImGuiTextFilter::Draw(const char* label, float width)
{
    if (width != 0.0f)
        ImGui::PushItemWidth(width);
    bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
    if (width != 0.0f)
        ImGui::PopItemWidth();
    if (value_changed)
        Build();
    return value_changed;
}

void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>* out) const
{
    out->resize(0);
    const char* wb = b;
    const char* we = wb;
    while (we < e)
    {
        if (*we == separator)
        {
            out->push_back(TextRange(wb, we));
            wb = we + 1;
        }
        we++;
    }
    if (wb != we)
        out->push_back(TextRange(wb, we));
}

void ImGuiTextFilter::Build()
{
    Filters.resize(0);
    TextRange input_range(InputBuf, InputBuf+strlen(InputBuf));
    input_range.split(',', &Filters);

    CountGrep = 0;
    for (int i = 0; i != Filters.Size; i++)
    {
        TextRange& f = Filters[i];
        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
            f.b++;
        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
            f.e--;
        if (f.empty())
            continue;
        if (Filters[i].b[0] != '-')
            CountGrep += 1;
    }
}

bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
{
    if (Filters.empty())
        return true;

    if (text == NULL)
        text = "";

    for (int i = 0; i != Filters.Size; i++)
    {
        const TextRange& f = Filters[i];
        if (f.empty())
            continue;
        if (f.b[0] == '-')
        {
            // Subtract
            if (ImStristr(text, text_end, f.begin()+1, f.end()) != NULL)
                return false;
        }
        else
        {
            // Grep
            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
                return true;
        }
    }

    // Implicit * grep
    if (CountGrep == 0)
        return true;

    return false;
}

//-----------------------------------------------------------------------------
// ImGuiTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
{
    va_list args_copy;
    va_copy(args_copy, args);

    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
    if (len <= 0)
    {
        va_end(args_copy);
        return;
    }

    const int write_off = Buf.Size;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int double_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > double_capacity ? needed_sz : double_capacity);
    }

    Buf.resize(needed_sz);
    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
    va_end(args_copy);
}

void ImGuiTextBuffer::appendf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    appendfv(fmt, args);
    va_end(args);
}

//-----------------------------------------------------------------------------
// ImGuiSimpleColumns (internal use only)
//-----------------------------------------------------------------------------

ImGuiMenuColumns::ImGuiMenuColumns()
{
    Count = 0;
    Spacing = Width = NextWidth = 0.0f;
    memset(Pos, 0, sizeof(Pos));
    memset(NextWidths, 0, sizeof(NextWidths));
}

void ImGuiMenuColumns::Update(int count, float spacing, bool clear)
{
    IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));
    Count = count;
    Width = NextWidth = 0.0f;
    Spacing = spacing;
    if (clear) memset(NextWidths, 0, sizeof(NextWidths));
    for (int i = 0; i < Count; i++)
    {
        if (i > 0 && NextWidths[i] > 0.0f)
            Width += Spacing;
        Pos[i] = (float)(int)Width;
        Width += NextWidths[i];
        NextWidths[i] = 0.0f;
    }
}

float ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double
{
    NextWidth = 0.0f;
    NextWidths[0] = ImMax(NextWidths[0], w0);
    NextWidths[1] = ImMax(NextWidths[1], w1);
    NextWidths[2] = ImMax(NextWidths[2], w2);
    for (int i = 0; i < 3; i++)
        NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);
    return ImMax(Width, NextWidth);
}

float ImGuiMenuColumns::CalcExtraSpace(float avail_w)
{
    return ImMax(0.0f, avail_w - Width);
}

//-----------------------------------------------------------------------------
// ImGuiListClipper
//-----------------------------------------------------------------------------

static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)
{
    // Set cursor position and a few other things so that SetScrollHere() and Columns() can work when seeking cursor.
    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
    // The clipper should probably have a 4th step to display the last item in a regular manner.
    ImGui::SetCursorPosY(pos_y);
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHere() can properly function after the end of our clipper usage.
    window->DC.PrevLineSize.y = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
    if (window->DC.ColumnsSet)
        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void ImGuiListClipper::Begin(int count, float items_height)
{
    StartPosY = ImGui::GetCursorPosY();
    ItemsHeight = items_height;
    ItemsCount = count;
    StepNo = 0;
    DisplayEnd = DisplayStart = -1;
    if (ItemsHeight > 0.0f)
    {
        ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display
        if (DisplayStart > 0)
            SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor
        StepNo = 2;
    }
}

void ImGuiListClipper::End()
{
    if (ItemsCount < 0)
        return;
    // In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
    if (ItemsCount < INT_MAX)
        SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor
    ItemsCount = -1;
    StepNo = 3;
}

bool ImGuiListClipper::Step()
{
    if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)
    {
        ItemsCount = -1;
        return false;
    }
    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.
    {
        DisplayStart = 0;
        DisplayEnd = 1;
        StartPosY = ImGui::GetCursorPosY();
        StepNo = 1;
        return true;
    }
    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
    {
        if (ItemsCount == 1) { ItemsCount = -1; return false; }
        float items_height = ImGui::GetCursorPosY() - StartPosY;
        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
        Begin(ItemsCount-1, items_height);
        DisplayStart++;
        DisplayEnd++;
        StepNo = 3;
        return true;
    }
    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.
    {
        IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);
        StepNo = 3;
        return true;
    }
    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
        End();
    return false;
}

//-----------------------------------------------------------------------------
// ImGuiWindow
//-----------------------------------------------------------------------------

ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)
    : DrawListInst(&context->DrawListSharedData)
{
    Name = ImStrdup(name);
    ID = ImHash(name, 0);
    IDStack.push_back(ID);
    Flags = 0;
    Pos = ImVec2(0.0f, 0.0f);
    Size = SizeFull = ImVec2(0.0f, 0.0f);
    SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    WindowPadding = ImVec2(0.0f, 0.0f);
    WindowRounding = 0.0f;
    WindowBorderSize = 0.0f;
    MoveId = GetID(XorString("#MOVE"));
    ChildId = 0;
    Scroll = ImVec2(0.0f, 0.0f);
    ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
    ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
    ScrollbarSizes = ImVec2(0.0f, 0.0f);
    ScrollbarX = ScrollbarY = false;
    Active = WasActive = false;
    WriteAccessed = false;
    Collapsed = false;
    WantCollapseToggle = false;
    SkipItems = false;
    Appearing = false;
    Hidden = false;
    HasCloseButton = false;
    BeginOrderWithinParent = -1;
    BeginOrderWithinContext = -1;
    BeginCount = 0;
    PopupId = 0;
    AutoFitFramesX = AutoFitFramesY = -1;
    AutoFitOnlyGrows = false;
    AutoFitChildAxises = 0x00;
    AutoPosLastDirection = ImGuiDir_None;
    HiddenFramesRegular = HiddenFramesForResize = 0;
    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
    SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);

    LastFrameActive = -1;
    ItemWidthDefault = 0.0f;
    FontWindowScale = 1.0f;
    SettingsIdx = -1;

    DrawList = &DrawListInst;
    DrawList->_OwnerName = Name;
    ParentWindow = NULL;
    RootWindow = NULL;
    RootWindowForTitleBarHighlight = NULL;
    RootWindowForNav = NULL;

    NavLastIds[0] = NavLastIds[1] = 0;
    NavRectRel[0] = NavRectRel[1] = ImRect();
    NavLastChildNavWindow = NULL;

    FocusIdxAllCounter = FocusIdxTabCounter = -1;
    FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;
    FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;
}

ImGuiWindow::~ImGuiWindow()
{
    IM_ASSERT(DrawList == &DrawListInst);
    IM_DELETE(Name);
    for (int i = 0; i != ColumnsStorage.Size; i++)
        ColumnsStorage[i].~ImGuiColumnsSet();
}

ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHash(str, str_end ? (int)(str_end - str) : 0, seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetID(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    ImGuiID id = ImHash(&ptr, sizeof(void*), seed);
    ImGui::KeepAliveID(id);
    return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)
{
    ImGuiID seed = IDStack.back();
    return ImHash(str, str_end ? (int)(str_end - str) : 0, seed);
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)
{
    ImGuiID seed = IDStack.back();
    return ImHash(&ptr, sizeof(void*), seed);
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
{
    ImGuiID seed = IDStack.back();
    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };
    ImGuiID id = ImHash(&r_rel, sizeof(r_rel), seed);
    ImGui::KeepAliveID(id);
    return id;
}

//-----------------------------------------------------------------------------
// Internal API exposed in imgui_internal.h
//-----------------------------------------------------------------------------

static void SetCurrentWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow = window;
    if (window)
        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void ImGui::SetNavID(ImGuiID id, int nav_layer)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindow);
    IM_ASSERT(nav_layer == 0 || nav_layer == 1);
    g.NavId = id;
    g.NavWindow->NavLastIds[nav_layer] = id;
}

void ImGui::SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)
{
    ImGuiContext& g = *GImGui;
    SetNavID(id, nav_layer);
    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
    g.NavMousePosDirty = true;
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = true;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        g.ActiveIdTimer = 0.0f;
        g.ActiveIdHasBeenEdited = false;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0f;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowNavDirFlags = 0;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdWindow = window;
    if (id)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
    }
}

void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(id != 0);

    // Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.
    const int nav_layer = window->DC.NavLayerCurrent;
    if (g.NavWindow != window)
        g.NavInitRequest = false;
    g.NavId = id;
    g.NavWindow = window;
    g.NavLayer = nav_layer;
    window->NavLastIds[nav_layer] = id;
    if (window->DC.LastItemId == id)
        window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

    if (g.ActiveIdSource == ImGuiInputSource_Nav)
        g.NavDisableMouseHover = true;
    else
        g.NavDisableHighlight = true;
}

void ImGui::ClearActiveID()
{
    SetActiveID(0, NULL);
}

void ImGui::SetHoveredID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id)
        g.HoveredIdTimer = 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::KeepAliveID(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
        g.ActiveIdIsAlive = id;
    if (g.ActiveIdPreviousFrame == id)
        g.ActiveIdPreviousFrameIsAlive = true;
}

void ImGui::MarkItemEdited(ImGuiID id)
{
    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
    (void)id; // Avoid unused variable warnings when asserts are compiled out.
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
    g.ActiveIdHasBeenEdited = true;
    g.CurrentWindow->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
{
    // An active popup disable hovering on other windows (apart from its own children)
    // FIXME-OPT: This could be cached/stored within the window.
    ImGuiContext& g = *GImGui;
    if (g.NavWindow)
        if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)
            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)
            {
                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
                // NB: The order of those two tests is important because Modal windows are also Popups.
                if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
                    return false;
                if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
                    return false;
            }

    return true;
}

// Advance cursor given item size for layout.
void ImGui::ItemSize(const ImVec2& size, float text_offset_y)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    // Always align ourselves on pixel boundaries
    const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);
    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);
    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
    window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);
    window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

    window->DC.PrevLineSize.y = line_height;
    window->DC.PrevLineTextBaseOffset = text_base_offset;
    window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;

    // Horizontal layout mode
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
        SameLine();
}

void ImGui::ItemSize(const ImRect& bb, float text_offset_y)
{
    ItemSize(bb.GetSize(), text_offset_y);
}

static ImGuiDir inline NavScoreItemGetQuadrant(float dx, float dy)
{
    if (ImFabs(dx) > ImFabs(dy))
        return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
    return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
    if (a1 < b0)
        return a1 - b0;
    if (b1 < a0)
        return a0 - b1;
    return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)
{
    if (move_dir == ImGuiDir_Left || move_dir == ImGuiDir_Right)
    {
        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
    }
    else
    {
        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
    }
}

// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavLayer != window->DC.NavLayerCurrent)
        return false;

    const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    g.NavScoringCount++;

    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    if (window->ParentWindow == g.NavWindow)
    {
        IM_ASSERT((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened);
        if (!window->ClipRect.Contains(cand))
            return false;
        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    }

    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.
    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);

    // Compute distance between boxes
    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
    if (dby != 0.0f && dbx != 0.0f)
       dbx = (dbx/1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    float dist_box = ImFabs(dbx) + ImFabs(dby);

    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
    ImGuiDir quadrant;
    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    if (dbx != 0.0f || dby != 0.0f)
    {
        // For non-overlapping boxes, use distance between boxes
        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = NavScoreItemGetQuadrant(dbx, dby);
    }
    else if (dcx != 0.0f || dcy != 0.0f)
    {
        // For overlapping boxes with different centers, use distance between centers
        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = NavScoreItemGetQuadrant(dcx, dcy);
    }
    else
    {
        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
        quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
    }

#if IMGUI_DEBUG_NAV_SCORING
    char buf[128];
    if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))
    {
        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
        ImDrawList* draw_list = ImGui::GetOverlayDrawList();
        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255,200,0,100));
        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255,255,0,200));
        draw_list->AddRectFilled(cand.Max-ImVec2(4,4), cand.Max+ImGui::CalcTextSize(buf)+ImVec2(4,4), IM_COL32(40,0,0,150));
        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
    }
    else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
    {
        if (IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }
        if (quadrant == g.NavMoveDir)
        {
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
            ImDrawList* draw_list = ImGui::GetOverlayDrawList();
            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
        }
    }
 #endif

    // Is it in the quadrant we're interesting in moving to?
    bool new_best = false;
    if (quadrant == g.NavMoveDir)
    {
        // Does it beat the current best candidate?
        if (dist_box < result->DistBox)
        {
            result->DistBox = dist_box;
            result->DistCenter = dist_center;
            return true;
        }
        if (dist_box == result->DistBox)
        {
            // Try using distance between center points to break ties
            if (dist_center < result->DistCenter)
            {
                result->DistCenter = dist_center;
                new_best = true;
            }
            else if (dist_center == result->DistCenter)
            {
                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
                if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
                    new_best = true;
            }
        }
    }

    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
        if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
            if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))
            {
                result->DistAxial = dist_axial;
                new_best = true;
            }

    return new_best;
}

static void NavSaveLastChildNavWindow(ImGuiWindow* child_window)
{
    ImGuiWindow* parent_window = child_window;
    while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
        parent_window = parent_window->ParentWindow;
    if (parent_window && parent_window != child_window)
        parent_window->NavLastChildNavWindow = child_window;
}

// Call when we are expected to land on Layer 0 after FocusWindow()
static ImGuiWindow* NavRestoreLastChildNavWindow(ImGuiWindow* window)
{
    return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;
}

static void NavRestoreLayer(int layer)
{
    ImGuiContext& g = *GImGui;
    g.NavLayer = layer;
    if (layer == 0)
        g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);
    if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)
        ImGui::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);
    else
        ImGui::NavInitWindow(g.NavWindow, true);
}

static inline void NavUpdateAnyRequestFlag()
{
    ImGuiContext& g = *GImGui;
    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    if (g.NavAnyRequest)
        IM_ASSERT(g.NavWindow != NULL);
}

bool ImGui::NavMoveRequestButNoResultYet()
{
    ImGuiContext& g = *GImGui;
    return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void ImGui::NavMoveRequestCancel()
{
    ImGuiContext& g = *GImGui;
    g.NavMoveRequest = false;
    NavUpdateAnyRequestFlag();
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
    //    return;

    const ImGuiItemFlags item_flags = window->DC.ItemFlags;
    const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);

    // Process Init Request
    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)
    {
        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)
        {
            g.NavInitResultId = id;
            g.NavInitResultRectRel = nav_bb_rel;
        }
        if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))
        {
            g.NavInitRequest = false; // Found a match, clear request
            NavUpdateAnyRequestFlag();
        }
    }

    // Process Move Request (scoring for navigation)
    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
    if ((g.NavId != id || (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AllowCurrentNavId)) && !(item_flags & ImGuiItemFlags_NoNav))
    {
        ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if IMGUI_DEBUG_NAV_SCORING
        // [DEBUG] Score all items in NavWindow at all times
        if (!g.NavMoveRequest)
            g.NavMoveDir = g.NavMoveDirLast;
        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
#else
        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);
#endif
        if (new_best)
        {
            result->ID = id;
            result->Window = window;
            result->RectRel = nav_bb_rel;
        }

        const float VISIBLE_RATIO = 0.70f;
        if ((g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))
                {
                    result = &g.NavMoveResultLocalVisibleSet;
                    result->ID = id;
                    result->Window = window;
                    result->RectRel = nav_bb_rel;
                }
    }

    // Update window-relative bounding box of navigated item
    if (g.NavId == id)
    {
        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
        g.NavLayer = window->DC.NavLayerCurrent;
        g.NavIdIsAlive = true;
        g.NavIdTabCounter = window->FocusIdxTabCounter;
        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)
    }
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().
bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (id != 0)
    {
        // Navigation processing runs prior to clipping early-out
        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.
        //      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
        window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;
        if (g.NavId == id || g.NavAnyRequest)
            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);
    }

    window->DC.LastItemId = id;
    window->DC.LastItemRect = bb;
    window->DC.LastItemStatusFlags = 0;

    // Clipping test
    const bool is_clipped = IsClippedEx(bb, id, false);
    if (is_clipped)
        return false;
    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    if (IsMouseHoveringRect(bb.Min, bb.Max))
        window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavDisableMouseHover && !g.NavDisableHighlight)
        return IsItemFocused();

    // Test for bounding box overlap, as updated as ItemAdd()
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function

    // Test if we are hovering the right window (our window could be behind another window)
    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
    //if (g.HoveredWindow != window)
    //    return false;
    if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))
        return false;

    // Test if another item is active (e.g. being dragged)
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
            return false;

    // Test if interactions on this window are blocked by an active popup or modal
    if (!IsWindowContentHoverable(window, flags))
        return false;

    // Test if the item is disabled
    if ((window->DC.ItemFlags & ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_AllowWhenDisabled))
        return false;

    // Special handling for the 1st item after Begin() which represent the title bar. When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect tht case.
    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)
        return false;
    return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow != window)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        return false;
    if (!IsMouseHoveringRect(bb.Min, bb.Max))
        return false;
    if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_None))
        return false;
    if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)
        return false;

    SetHoveredID(id);
    return true;
}

bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!bb.Overlaps(window->ClipRect))
        if (id == 0 || id != g.ActiveId)
            if (clip_even_when_logged || !g.LogEnabled)
                return true;
    return false;
}

bool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop)
{
    ImGuiContext& g = *GImGui;

    const bool allow_keyboard_focus = (window->DC.ItemFlags & (ImGuiItemFlags_AllowKeyboardFocus | ImGuiItemFlags_Disabled)) == ImGuiItemFlags_AllowKeyboardFocus;
    window->FocusIdxAllCounter++;
    if (allow_keyboard_focus)
        window->FocusIdxTabCounter++;

    // Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.
    // Note that we can always TAB out of a widget that doesn't allow tabbing in.
    if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))
        window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (allow_keyboard_focus ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.

    if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)
        return true;
    if (allow_keyboard_focus && window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)
    {
        g.NavJustTabbedId = id;
        return true;
    }

    return false;
}

void ImGui::FocusableItemUnregister(ImGuiWindow* window)
{
    window->FocusIdxAllCounter--;
    window->FocusIdxTabCounter--;
}

ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)
{
    ImGuiContext& g = *GImGui;
    ImVec2 content_max;
    if (size.x < 0.0f || size.y < 0.0f)
        content_max = g.CurrentWindow->Pos + GetContentRegionMax();
    if (size.x <= 0.0f)
        size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;
    if (size.y <= 0.0f)
        size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;
    return size;
}

float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
{
    if (wrap_pos_x < 0.0f)
        return 0.0f;

    ImGuiWindow* window = GetCurrentWindowRead();
    if (wrap_pos_x == 0.0f)
        wrap_pos_x = GetContentRegionMax().x + window->Pos.x;
    else if (wrap_pos_x > 0.0f)
        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

    return ImMax(wrap_pos_x - pos.x, 1.0f);
}

//-----------------------------------------------------------------------------

void* ImGui::MemAlloc(size_t size)
{
    if (ImGuiContext* ctx = GImGui)
        ctx->IO.MetricsActiveAllocations++;
    return GImAllocatorAllocFunc(size, GImAllocatorUserData);
}

void ImGui::MemFree(void* ptr)
{
    if (ptr) 
        if (ImGuiContext* ctx = GImGui)
            ctx->IO.MetricsActiveAllocations--;
    return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);
}

const char* ImGui::GetClipboardText()
{
    return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";
}

void ImGui::SetClipboardText(const char* text)
{
    if (GImGui->IO.SetClipboardTextFn)
        GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);
}

const char* ImGui::GetVersion()
{
    return IMGUI_VERSION;
}

// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext* ImGui::GetCurrentContext()
{
    return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext* ctx)
{
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
    IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
    GImGui = ctx;
#endif
}

// Helper function to verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If the user has inconsistent compilation settings, imgui configuration #define, packing pragma, etc. you may see different structures from what imgui.cpp sees which is highly problematic.
bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert)
{
    bool error = false;
    if (strcmp(version, IMGUI_VERSION)!=0) { error = true; IM_ASSERT(strcmp(version,IMGUI_VERSION)==0 && "Mismatched version string!");  }
    if (sz_io    != sizeof(ImGuiIO))       { error = true; IM_ASSERT(sz_io    == sizeof(ImGuiIO)      && "Mismatched struct layout!"); }
    if (sz_style != sizeof(ImGuiStyle))    { error = true; IM_ASSERT(sz_style == sizeof(ImGuiStyle)   && "Mismatched struct layout!"); }
    if (sz_vec2  != sizeof(ImVec2))        { error = true; IM_ASSERT(sz_vec2  == sizeof(ImVec2)       && "Mismatched struct layout!"); }
    if (sz_vec4  != sizeof(ImVec4))        { error = true; IM_ASSERT(sz_vec4  == sizeof(ImVec4)       && "Mismatched struct layout!"); }
    if (sz_vert  != sizeof(ImDrawVert))    { error = true; IM_ASSERT(sz_vert  == sizeof(ImDrawVert)   && "Mismatched struct layout!"); }
    return !error;
}

void ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}

ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
{
    ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
    if (GImGui == NULL)
        SetCurrentContext(ctx);
    Initialize(ctx);
    return ctx;
}

void ImGui::DestroyContext(ImGuiContext* ctx)
{
    if (ctx == NULL)
        ctx = GImGui;
    Shutdown(ctx);
    if (GImGui == ctx)
        SetCurrentContext(NULL);
    IM_DELETE(ctx);
}

ImGuiIO& ImGui::GetIO()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    return GImGui->IO;
}

ImGuiStyle& ImGui::GetStyle()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    return GImGui->Style;
}

// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()
ImDrawData* ImGui::GetDrawData()
{
    ImGuiContext& g = *GImGui;
    return g.DrawData.Valid ? &g.DrawData : NULL;
}

double ImGui::GetTime()
{
    return GImGui->Time;
}

int ImGui::GetFrameCount()
{
    return GImGui->FrameCount;
}

ImDrawList* ImGui::GetOverlayDrawList()
{
    return &GImGui->OverlayDrawList;
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
    return &GImGui->DrawListSharedData;
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(window == g.NavWindow);
    bool init_for_nav = false;
    if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))
        if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
            init_for_nav = true;
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer);
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavInitResultRectRel = ImRect();
        NavUpdateAnyRequestFlag();
    }
    else
    {
        g.NavId = window->NavLastIds[0];
    }
}

static ImVec2 NavCalcPreferredRefPos()
{
    ImGuiContext& g = *GImGui;
    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)
        return ImFloor(g.IO.MousePos);

    // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item
    const ImRect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];
    ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x*4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
    ImRect visible_rect = GetViewportRect();
    return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.
}

static int FindWindowIndex(ImGuiWindow* window) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.Windows.Size-1; i >= 0; i--)
        if (g.Windows[i] == window)
            return i;
    return -1;
}

static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
    ImGuiContext& g = *GImGui;
    for (int i = i_start; i >= 0 && i < g.Windows.Size && i != i_stop; i += dir)
        if (ImGui::IsWindowNavFocusable(g.Windows[i]))
            return g.Windows[i];
    return NULL;
}

float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)
{
    ImGuiContext& g = *GImGui;
    if (mode == ImGuiInputReadMode_Down)
        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

    const float t = g.IO.NavInputsDownDuration[n];
    if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.
        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);
    if (t < 0.0f)
        return 0.0f;
    if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.
        return (t == 0.0f) ? 1.0f : 0.0f;
    if (mode == ImGuiInputReadMode_Repeat)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);
    if (mode == ImGuiInputReadMode_RepeatSlow)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);
    if (mode == ImGuiInputReadMode_RepeatFast)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);
    return 0.0f;
}

ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)
{
    ImVec2 delta(0.0f, 0.0f);
    if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode)   - GetNavInputAmount(ImGuiNavInput_KeyLeft_,   mode), GetNavInputAmount(ImGuiNavInput_KeyDown_,   mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode)   - GetNavInputAmount(ImGuiNavInput_DpadLeft,   mode), GetNavInputAmount(ImGuiNavInput_DpadDown,   mode) - GetNavInputAmount(ImGuiNavInput_DpadUp,   mode));
    if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)
        delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));
    if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))
        delta *= slow_factor;
    if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))
        delta *= fast_factor;
    return delta;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget);
    if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
        return;

    const int i_current = FindWindowIndex(g.NavWindowingTarget);
    ImGuiWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
    if (!window_target)
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.Windows.Size - 1) : 0, i_current, focus_change_dir);
    if (window_target) // Don't reset windowing target if there's a single window in the list
        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    g.NavWindowingToggleLayer = false;
}

// Window management mode (hold to: change focus/move/resize, tap to: toggle menu layer)
static void ImGui::NavUpdateWindowing()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* apply_focus_window = NULL;
    bool apply_toggle_layer = false;

    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window != NULL)
    {
        g.NavWindowingTarget = NULL;
        return;
    }

    // Fade out
    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);
        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
            g.NavWindowingTargetAnim = NULL;
    }

    // Start CTRL-TAB or Square+L/R window selection
    bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);
    bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);
    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.Windows.Size - 1, -INT_MAX, -1))
        {
            g.NavWindowingTarget = g.NavWindowingTargetAnim = window;
            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
            g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;
        }

    // Gamepad update
    g.NavWindowingTimer += g.IO.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)
    {
        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

        // Select window to focus
        const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);
        if (focus_change_dir != 0)
        {
            NavUpdateWindowingHighlightWindow(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0f;
        }

        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)
        if (!IsNavInputDown(ImGuiNavInput_Menu))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
            if (g.NavWindowingToggleLayer && g.NavWindow)
                apply_toggle_layer = true;
            else if (!g.NavWindowingToggleLayer)
                apply_focus_window = g.NavWindowingTarget;
            g.NavWindowingTarget = NULL;
        }
    }

    // Keyboard: Focus
    if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)
    {
        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
        if (IsKeyPressedMap(ImGuiKey_Tab, true))
            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
        if (!g.IO.KeyCtrl)
            apply_focus_window = g.NavWindowingTarget;
    }

    // Keyboard: Press and Release ALT to toggle menu layer
    // FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))
        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))
            apply_toggle_layer = true;

    // Move window
    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
    {
        ImVec2 move_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);
        if (move_delta.x != 0.0f || move_delta.y != 0.0f)
        {
            const float NAV_MOVE_SPEED = 800.0f;
            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well
            g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;
            g.NavDisableMouseHover = true;
            MarkIniSettingsDirty(g.NavWindowingTarget);
        }
    }

    // Apply final focus
    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
    {
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
        ClosePopupsOverWindow(apply_focus_window);
        FocusWindow(apply_focus_window);
        if (apply_focus_window->NavLastIds[0] == 0)
            NavInitWindow(apply_focus_window, false);

        // If the window only has a menu layer, select it directly
        if (apply_focus_window->DC.NavLayerActiveMask == (1 << 1))
            g.NavLayer = 1;
    }
    if (apply_focus_window)
        g.NavWindowingTarget = NULL;

    // Apply menu/layer toggle
    if (apply_toggle_layer && g.NavWindow)
    {
        // Move to parent menu if necessary
        ImGuiWindow* new_nav_window = g.NavWindow;
        while ((new_nav_window->DC.NavLayerActiveMask & (1 << 1)) == 0 && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
            new_nav_window = new_nav_window->ParentWindow;

        if (new_nav_window != g.NavWindow)
        {
            ImGuiWindow* old_nav_window = g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window->NavLastChildNavWindow = old_nav_window;
        }
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        NavRestoreLayer((g.NavWindow->DC.NavLayerActiveMask & (1 << 1)) ? (g.NavLayer ^ 1) : 0);
    }
}

// Window has already passed the IsWindowNavFocusable()
static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)
{
    if (window->Flags & ImGuiWindowFlags_Popup)
        return XorString("(Popup)");
    if ((window->Flags & ImGuiWindowFlags_MenuBar) && strcmp(window->Name, XorString("##MainMenuBar")) == 0)
        return XorString("(Main menu bar)");
    return XorString("(Untitled)");
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void ImGui::NavUpdateWindowingList()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavWindowingTarget != NULL);

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
        return;

    if (g.NavWindowingList == NULL)
        g.NavWindowingList = FindWindowByName(XorString("###NavWindowingList"));
    SetNextWindowSizeConstraints(ImVec2(g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f), ImVec2(FLT_MAX, FLT_MAX));
    SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Always, ImVec2(0.5f, 0.5f));
    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
    Begin(XorString("###NavWindowingList"), NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoNav | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    for (int n = g.Windows.Size - 1; n >= 0; n--)
    {
        ImGuiWindow* window = g.Windows[n];
        if (!IsWindowNavFocusable(window))
            continue;
        const char* label = window->Name;
        if (label == FindRenderedTextEnd(label))
            label = GetFallbackWindowNameForWindowingList(window);
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}

// Scroll to keep newly navigated item fully into view
// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.
static void NavScrollToBringItemIntoView(ImGuiWindow* window, const ImRect& item_rect)
{
    ImRect window_rect(window->InnerMainRect.Min - ImVec2(1, 1), window->InnerMainRect.Max + ImVec2(1, 1));
    //g.OverlayDrawList.AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]
    if (window_rect.Contains(item_rect))
        return;

    ImGuiContext& g = *GImGui;
    if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)
    {
        window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 0.0f;
    }
    else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)
    {
        window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 1.0f;
    }
    if (item_rect.Min.y < window_rect.Min.y)
    {
        window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 0.0f;
    }
    else if (item_rect.Max.y >= window_rect.Max.y)
    {
        window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 1.0f;
    }
}

static void ImGui::NavUpdate()
{
    ImGuiContext& g = *GImGui;
    g.IO.WantSetMousePos = false;

#if 0
    if (g.NavScoringCount > 0) printf("[%05d] NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
#endif

    bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
    bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;

    // Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)
    if (nav_gamepad_active)
        if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)
            g.NavInputSource = ImGuiInputSource_NavGamepad;

    // Update Keyboard->Nav inputs mapping
    if (nav_keyboard_active)
    {
        #define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }
        NAV_MAP_KEY(ImGuiKey_Space,     ImGuiNavInput_Activate );
        NAV_MAP_KEY(ImGuiKey_Enter,     ImGuiNavInput_Input    );
        NAV_MAP_KEY(ImGuiKey_Escape,    ImGuiNavInput_Cancel   );
        NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_ );
        NAV_MAP_KEY(ImGuiKey_RightArrow,ImGuiNavInput_KeyRight_);
        NAV_MAP_KEY(ImGuiKey_UpArrow,   ImGuiNavInput_KeyUp_   );
        NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_ );
        if (g.IO.KeyCtrl)   g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;
        if (g.IO.KeyShift)  g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;
        if (g.IO.KeyAlt)    g.IO.NavInputs[ImGuiNavInput_KeyMenu_]  = 1.0f;
        #undef NAV_MAP_KEY
    }

    memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)
        g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Process navigation init request (select first/default focus)
    if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))
    {
        // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
        IM_ASSERT(g.NavWindow);
        if (g.NavInitRequestFromMove)
            SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);
        else
            SetNavID(g.NavInitResultId, g.NavLayer);
        g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;
    }
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavJustMovedToId = 0;

    // Process navigation move request
    if (g.NavMoveRequest && (g.NavMoveResultLocal.ID != 0 || g.NavMoveResultOther.ID != 0))
    {
        // Select which result to use
        ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

        // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
        if (g.NavMoveRequestFlags & ImGuiNavMoveFlags_AlsoScoreVisibleSet)
            if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)
                result = &g.NavMoveResultLocalVisibleSet;

        // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
        if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
            if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
                result = &g.NavMoveResultOther;
        IM_ASSERT(g.NavWindow && result->Window);

        // Scroll to keep newly navigated item fully into view.
        if (g.NavLayer == 0)
        {
            ImRect rect_abs = ImRect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);
            NavScrollToBringItemIntoView(result->Window, rect_abs);

            // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()
            ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);
            ImVec2 delta_scroll = result->Window->Scroll - next_scroll;
            result->RectRel.Translate(delta_scroll);

            // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).
            if (result->Window->Flags & ImGuiWindowFlags_ChildWindow)
                NavScrollToBringItemIntoView(result->Window->ParentWindow, ImRect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));
        }

        // Apply result from previous frame navigation directional move request
        ClearActiveID();
        g.NavWindow = result->Window;
        SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);
        g.NavJustMovedToId = result->ID;
        g.NavMoveFromClampedRefRect = false;
    }

    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
    if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)
    {
        IM_ASSERT(g.NavMoveRequest);
        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
            g.NavDisableHighlight = false;
        g.NavMoveRequestForward = ImGuiNavForward_None;
    }

    // Apply application mouse position movement, after we had a chance to process move request result.
    if (g.NavMousePosDirty && g.NavIdIsAlive)
    {
        // Set mouse position given our knowledge of the navigated item position from last frame
        if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
        {
            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
            {
                g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();
                g.IO.WantSetMousePos = true;
            }
        }
        g.NavMousePosDirty = false;
    }
    g.NavIdIsAlive = false;
    g.NavJustTabbedId = 0;
    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);

    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
    if (g.NavWindow)
        NavSaveLastChildNavWindow(g.NavWindow);
    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)
        g.NavWindow->NavLastChildNavWindow = NULL;

    NavUpdateWindowing();

    // Set output flags for user application
    g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
    g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL) || g.NavInitRequest;

    // Process NavCancel input (to close a popup, get back to parent, clear focus)
    if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))
    {
        if (g.ActiveId != 0)
        {
            ClearActiveID();
        }
        else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
        {
            // Exit child window
            ImGuiWindow* child_window = g.NavWindow;
            ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
            IM_ASSERT(child_window->ChildId != 0);
            FocusWindow(parent_window);
            SetNavID(child_window->ChildId, 0);
            g.NavIdIsAlive = false;
            if (g.NavDisableMouseHover)
                g.NavMousePosDirty = true;
        }
        else if (g.OpenPopupStack.Size > 0)
        {
            // Close open popup/menu
            if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
                ClosePopupToLevel(g.OpenPopupStack.Size - 1);
        }
        else if (g.NavLayer != 0)
        {
            // Leave the "menu" layer
            NavRestoreLayer(0);
        }
        else
        {
            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
            if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
                g.NavWindow->NavLastIds[0] = 0;
            g.NavId = 0;
        }
    }

    // Process manual activation request
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
    {
        bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);
        bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);
        if (g.ActiveId == 0 && activate_pressed)
            g.NavActivateId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
            g.NavActivateDownId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
            g.NavActivatePressedId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))
            g.NavInputId = g.NavId;
    }
    if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        g.NavDisableHighlight = true;
    if (g.NavActivateId != 0)
        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
    g.NavMoveRequest = false;

    // Process programmatic activation request
    if (g.NavNextActivateId != 0)
        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
    g.NavNextActivateId = 0;

    // Initiate directional inputs request
    const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;
    if (g.NavMoveRequestForward == ImGuiNavForward_None)
    {
        g.NavMoveDir = ImGuiDir_None;
        g.NavMoveRequestFlags = 0;
        if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
        {
            if ((allowed_dir_flags & (1<<ImGuiDir_Left))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;
            if ((allowed_dir_flags & (1<<ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight,ImGuiNavInput_KeyRight_,ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;
            if ((allowed_dir_flags & (1<<ImGuiDir_Up))    && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp,   ImGuiNavInput_KeyUp_,   ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;
            if ((allowed_dir_flags & (1<<ImGuiDir_Down))  && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;
        }
        g.NavMoveClipDir = g.NavMoveDir;
    }
    else
    {
        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
        IM_ASSERT(g.NavMoveDir != ImGuiDir_None && g.NavMoveClipDir != ImGuiDir_None);
        IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);
        g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;
    }

    // PageUp/PageDown scroll
    float nav_scoring_rect_offset_y = 0.0f;
    if (nav_keyboard_active && g.NavMoveDir == ImGuiDir_None && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        bool page_up_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageUp]) && (allowed_dir_flags & (1 << ImGuiDir_Up));
        bool page_down_held = IsKeyDown(g.IO.KeyMap[ImGuiKey_PageDown]) && (allowed_dir_flags & (1 << ImGuiDir_Down));
        if ((page_up_held && !page_down_held) || (page_down_held && !page_up_held))
        {
            if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)
            {
                // Fallback manual-scroll when window has no navigable item
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                    SetWindowScrollY(window, window->Scroll.y - window->InnerClipRect.GetHeight());
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                    SetWindowScrollY(window, window->Scroll.y + window->InnerClipRect.GetHeight());
            }
            else
            {
                const ImRect& nav_rect_rel = window->NavRectRel[g.NavLayer];
                const float page_offset_y = ImMax(0.0f, window->InnerClipRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
                if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageUp], true))
                {
                    nav_scoring_rect_offset_y = -page_offset_y;
                    g.NavMoveDir = ImGuiDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Up;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
                else if (IsKeyPressed(g.IO.KeyMap[ImGuiKey_PageDown], true))
                {
                    nav_scoring_rect_offset_y = +page_offset_y;
                    g.NavMoveDir = ImGuiDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = ImGuiDir_Down;
                    g.NavMoveRequestFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet;
                }
            }
        }
    }

    if (g.NavMoveDir != ImGuiDir_None)
    {
        g.NavMoveRequest = true;
        g.NavMoveDirLast = g.NavMoveDir;
    }

    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
    if (g.NavMoveRequest && g.NavId == 0)
    {
        g.NavInitRequest = g.NavInitRequestFromMove = true;
        g.NavInitResultId = 0;
        g.NavDisableHighlight = false;
    }

    NavUpdateAnyRequestFlag();

    // Scrolling
    if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
    {
        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        ImGuiWindow* window = g.NavWindow;
        const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
        if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)
        {
            if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)
                SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
            if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)
                SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        }

        // *Normal* Manual scroll with NavScrollXXX keys
        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
        ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f/10.0f, 10.0f);
        if (scroll_dir.x != 0.0f && window->ScrollbarX)
        {
            SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
        if (scroll_dir.y != 0.0f)
        {
            SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
    }

    // Reset search results
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisibleSet.Clear();
    g.NavMoveResultOther.Clear();

    // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
    if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)
    {
        ImGuiWindow* window = g.NavWindow;
        ImRect window_rect_rel(window->InnerMainRect.Min - window->Pos - ImVec2(1,1), window->InnerMainRect.Max - window->Pos + ImVec2(1,1));
        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
        {
            float pad = window->CalcFontSize() * 0.5f;
            window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item
            window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);
            g.NavId = 0;
        }
        g.NavMoveFromClampedRefRect = false;
    }

    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0,0,0,0);
    g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();
    g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);
    g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);
    g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;
    IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
    //g.OverlayDrawList.AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
    g.NavScoringCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
    if (g.NavWindow) { for (int layer = 0; layer < 2; layer++) GetOverlayDrawList()->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255,200,0,255)); } // [DEBUG]
    if (g.NavWindow) { ImU32 col = (g.NavWindow->HiddenFrames == 0) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); g.OverlayDrawList.AddCircleFilled(p, 3.0f, col); g.OverlayDrawList.AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
#endif
}

void ImGui::StartMouseMovingWindow(ImGuiWindow* window)
{
    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
    ImGuiContext& g = *GImGui;
    FocusWindow(window);
    SetActiveID(window->MoveId, window);
    g.NavDisableHighlight = true;
    g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;
    if (!(window->Flags & ImGuiWindowFlags_NoMove) && !(window->RootWindow->Flags & ImGuiWindowFlags_NoMove))
        g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
void ImGui::UpdateMouseMovingWindow()
{
    ImGuiContext& g = *GImGui;
    if (g.MovingWindow != NULL)
    {
        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        KeepAliveID(g.ActiveId);
        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
        ImGuiWindow* moving_window = g.MovingWindow->RootWindow;
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))
        {
            ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
            {
                MarkIniSettingsDirty(moving_window);
                SetWindowPos(moving_window, pos, ImGuiCond_Always);
            }
            FocusWindow(g.MovingWindow);
        }
        else
        {
            ClearActiveID();
            g.MovingWindow = NULL;
        }
    }
    else
    {
        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])
                ClearActiveID();
        }
    }
}

static bool IsWindowActiveAndVisible(ImGuiWindow* window)
{
    return (window->Active) && (!window->Hidden);
}

static void ImGui::UpdateMouseInputs()
{
    ImGuiContext& g = *GImGui;

    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX component, but in reality we test for -256000.0f) we cancel out movement in MouseDelta
    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))
        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
    else
        g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)
        g.NavDisableMouseHover = false;

    g.IO.MousePosPrev = g.IO.MousePos;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;
        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;
        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];
        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;
        g.IO.MouseDoubleClicked[i] = false;
        if (g.IO.MouseClicked[i])
        {
            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)
            {
                ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)
                    g.IO.MouseDoubleClicked[i] = true;
                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click
            }
            else
            {
                g.IO.MouseClickedTime[i] = g.Time;
            }
            g.IO.MouseClickedPos[i] = g.IO.MousePos;
            g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;
        }
        else if (g.IO.MouseDown[i])
        {
            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
            ImVec2 delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : ImVec2(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
        }
        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
            g.NavDisableMouseHover = false;
    }
}

void ImGui::UpdateMouseWheel()
{
    ImGuiContext& g = *GImGui;
    if (!g.HoveredWindow || g.HoveredWindow->Collapsed)
        return;
    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)
        return;

    // If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).
    ImGuiWindow* window = g.HoveredWindow;
    ImGuiWindow* scroll_window = window;
    while ((scroll_window->Flags & ImGuiWindowFlags_ChildWindow) && (scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoScrollbar) && !(scroll_window->Flags & ImGuiWindowFlags_NoInputs) && scroll_window->ParentWindow)
        scroll_window = scroll_window->ParentWindow;
    const bool scroll_allowed = !(scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoInputs);

    if (g.IO.MouseWheel != 0.0f)
    {
        if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
        {
            // Zoom / Scale window
            const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
            const float scale = new_font_scale / window->FontWindowScale;
            window->FontWindowScale = new_font_scale;

            const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
            window->Pos += offset;
            window->Size *= scale;
            window->SizeFull *= scale;
        }
        else if (!g.IO.KeyCtrl && scroll_allowed)
        {
            // Mouse wheel vertical scrolling
            float scroll_amount = 5 * scroll_window->CalcFontSize();
            scroll_amount = (float)(int)ImMin(scroll_amount, (scroll_window->ContentsRegionRect.GetHeight() + scroll_window->WindowPadding.y * 2.0f) * 0.67f);
            SetWindowScrollY(scroll_window, scroll_window->Scroll.y - g.IO.MouseWheel * scroll_amount);
        }
    }
    if (g.IO.MouseWheelH != 0.0f && scroll_allowed && !g.IO.KeyCtrl)
    {
        // Mouse wheel horizontal scrolling (for hardware that supports it)
        float scroll_amount = scroll_window->CalcFontSize();
        SetWindowScrollX(scroll_window, scroll_window->Scroll.x - g.IO.MouseWheelH * scroll_amount);
    }
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::UpdateHoveredWindowAndCaptureFlags()
{
    ImGuiContext& g = *GImGui;

    // Find the window hovered by mouse:
    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
    FindHoveredWindow();

    // Modal windows prevents cursor from hovering behind them.
    ImGuiWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window)
        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))
            g.HoveredRootWindow = g.HoveredWindow = NULL;

    // Disabled mouse?
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
    int mouse_earliest_button_down = -1;
    bool mouse_any_down = false;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        if (g.IO.MouseClicked[i])
            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());
        mouse_any_down |= g.IO.MouseDown[i];
        if (g.IO.MouseDown[i])
            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])
                mouse_earliest_button_down = i;
    }
    const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
    if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)
    if (g.WantCaptureMouseNextFrame != -1)
        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
    else
        g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());

    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)
    if (g.WantCaptureKeyboardNextFrame != -1)
        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    else
        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
        g.IO.WantCaptureKeyboard = true;

    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

void ImGui::NewFrame()
{
    IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
    ImGuiContext& g = *GImGui;

    // Check user data
    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    IM_ASSERT(g.Initialized);
    IM_ASSERT(g.IO.DeltaTime >= 0.0f                                    && "Need a positive DeltaTime (zero is tolerated but will cause some timing issues)");
    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f  && "Invalid DisplaySize value");
    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0                                && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded()                          && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f                       && "Invalid style setting");
    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f            && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)");
    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount)  && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    for (int n = 0; n < ImGuiKey_COUNT; n++)
        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

    // Perform simple check for required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
    if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)
        IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");

    // The beta io.ConfigResizeWindowsFromEdges option requires back-end to honor mouse cursor changes and set the ImGuiBackendFlags_HasMouseCursors flag accordingly.
    if (g.IO.ConfigResizeWindowsFromEdges && !(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseCursors))
        g.IO.ConfigResizeWindowsFromEdges = false;

    // Load settings on first frame (if not explicitly loaded manually before)
    if (!g.SettingsLoaded)
    {
        IM_ASSERT(g.SettingsWindows.empty());
        if (g.IO.IniFilename)
            LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }

    // Save settings (with a delay after the last modification, so we don't spam disk too much)
    if (g.SettingsDirtyTimer > 0.0f)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0f)
        {
            if (g.IO.IniFilename != NULL)
                SaveIniSettingsToDisk(g.IO.IniFilename);
            else
                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
            g.SettingsDirtyTimer = 0.0f;
        }
    }

    g.Time += g.IO.DeltaTime;
    g.FrameScopeActive = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;

    // Setup current font and draw list
    g.IO.Fonts->Locked = true;
    SetCurrentFont(GetDefaultFont());
    IM_ASSERT(g.Font->IsLoaded());
    g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;

    g.OverlayDrawList.Clear();
    g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);
    g.OverlayDrawList.PushClipRectFullScreen();
    g.OverlayDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

    // Mark rendering data as invalid to prevent user who may have a handle on it to use it
    g.DrawData.Clear();

    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        KeepAliveID(g.DragDropPayload.SourceId);

    // Clear reference to active widget if the widget isn't alive anymore
    if (!g.HoveredIdPreviousFrame)
        g.HoveredIdTimer = 0.0f;
    if (g.HoveredId)
        g.HoveredIdTimer += g.IO.DeltaTime;
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
        ClearActiveID();
    if (g.ActiveId)
        g.ActiveIdTimer += g.IO.DeltaTime;
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)
        g.ScalarAsInputTextId = 0;

    // Drag and drop
    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropWithinSourceOrTarget = false;

    // Update keyboard input state
    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)
        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Update gamepad/keyboard directional navigation
    NavUpdate();

    // Update mouse input state
    UpdateMouseInputs();

    // Calculate frame-rate for the user, as a purely luxurious feature
    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;

    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
    UpdateMouseMovingWindow();
    UpdateHoveredWindowAndCaptureFlags();

    // Background darkening/whitening
    if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    else
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

    g.MouseCursor = ImGuiMouseCursor_Arrow;
    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
    g.PlatformImePos = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

    // Mouse wheel scrolling, scale
    UpdateMouseWheel();

    // Pressing TAB activate widget focus
    if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab, false))
    {
        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)
            g.NavWindow->FocusIdxTabRequestNext = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
        else
            g.NavWindow->FocusIdxTabRequestNext = g.IO.KeyShift ? -1 : 0;
    }
    g.NavIdTabCounter = INT_MAX;

    // Mark all windows as not visible
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        window->WasActive = window->Active;
        window->Active = false;
        window->WriteAccessed = false;
    }

    // Closing the focused window restore focus to the first active root window in descending z-order
    if (g.NavWindow && !g.NavWindow->WasActive)
        FocusFrontMostActiveWindowIgnoringOne(NULL);

    // No window should be open at the beginning of the frame.
    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    g.CurrentWindowStack.resize(0);
    g.CurrentPopupStack.resize(0);
    ClosePopupsOverWindow(g.NavWindow);

    // Create implicit window - we will only render it if the user has added something to it.
    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
    SetNextWindowSize(ImVec2(400,400), ImGuiCond_FirstUseEver);
    Begin(XorString("Debug##Default"));
}

static void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
    ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHash(name, 0));
    if (!settings)
        settings = CreateNewWindowSettings(name);
    return (void*)settings;
}

static void SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
    ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
    float x, y;
    int i;
    if (sscanf(line, XorString("Pos=%f,%f"), &x, &y) == 2)         settings->Pos = ImVec2(x, y);
    else if (sscanf(line, XorString("Size=%f,%f"), &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), GImGui->Style.WindowMinSize);
    else if (sscanf(line, XorString("Collapsed=%d"), &i) == 1)     settings->Collapsed = (i != 0);
}

static void SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
    // Gather data from windows that were active during this session
    ImGuiContext& g = *imgui_ctx;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
            continue;

        ImGuiWindowSettings* settings = (window->SettingsIdx != -1) ? &g.SettingsWindows[window->SettingsIdx] : ImGui::FindWindowSettings(window->ID);
        if (!settings)
        {
            settings = CreateNewWindowSettings(window->Name);
            window->SettingsIdx = g.SettingsWindows.index_from_pointer(settings);
        }
        IM_ASSERT(settings->ID == window->ID);
        settings->Pos = window->Pos;
        settings->Size = window->SizeFull;
        settings->Collapsed = window->Collapsed;
    }

    // Write a buffer
    // If a window wasn't opened in this session we preserve its settings
    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve
    for (int i = 0; i != g.SettingsWindows.Size; i++)
    {
        const ImGuiWindowSettings* settings = &g.SettingsWindows[i];
        if (settings->Pos.x == FLT_MAX)
            continue;
        const char* name = settings->Name;
        if (const char* p = strstr(name, XorString("###")))  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
            name = p;
        buf->appendf(XorString("[%s][%s]\n"), handler->TypeName, name);
        buf->appendf(XorString("Pos=%d,%d\n"), (int)settings->Pos.x, (int)settings->Pos.y);
        buf->appendf(XorString("Size=%d,%d\n"), (int)settings->Size.x, (int)settings->Size.y);
        buf->appendf(XorString("Collapsed=%d\n"), settings->Collapsed);
        buf->appendf(XorString("\n"));
    }
}

void ImGui::Initialize(ImGuiContext* context)
{
    ImGuiContext& g = *context;
    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);

    // Add .ini handle for ImGuiWindow type
    ImGuiSettingsHandler ini_handler;
    ini_handler.TypeName = "Window";
    ini_handler.TypeHash = ImHash("Window", 0, 0);
    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
    g.SettingsHandlers.push_front(ini_handler);

    g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown(ImGuiContext* context)
{
    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
    ImGuiContext& g = *context;
    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
        IM_DELETE(g.IO.Fonts);
    g.IO.Fonts = NULL;

    // Cleanup of other data are conditional on actually having initialized ImGui.
    if (!g.Initialized)
        return;

    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
    if (g.SettingsLoaded && g.IO.IniFilename != NULL)
        SaveIniSettingsToDisk(g.IO.IniFilename);

    // Clear everything else
    for (int i = 0; i < g.Windows.Size; i++)
        IM_DELETE(g.Windows[i]);
    g.Windows.clear();
    g.WindowsSortBuffer.clear();
    g.CurrentWindow = NULL;
    g.CurrentWindowStack.clear();
    g.WindowsById.Clear();
    g.NavWindow = NULL;
    g.HoveredWindow = NULL;
    g.HoveredRootWindow = NULL;
    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
    g.MovingWindow = NULL;
    g.ColorModifiers.clear();
    g.StyleModifiers.clear();
    g.FontStack.clear();
    g.OpenPopupStack.clear();
    g.CurrentPopupStack.clear();
    g.DrawDataBuilder.ClearFreeMemory();
    g.OverlayDrawList.ClearFreeMemory();
    g.PrivateClipboard.clear();
    g.InputTextState.TextW.clear();
    g.InputTextState.InitialText.clear();
    g.InputTextState.TempBuffer.clear();

    for (int i = 0; i < g.SettingsWindows.Size; i++)
        IM_DELETE(g.SettingsWindows[i].Name);
    g.SettingsWindows.clear();
    g.SettingsHandlers.clear();

    if (g.LogFile && g.LogFile != stdout)
    {
        fclose(g.LogFile);
        g.LogFile = NULL;
    }
    g.LogClipboard.clear();

    g.Initialized = false;
}

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    for (int i = 0; i != g.SettingsWindows.Size; i++)
        if (g.SettingsWindows[i].ID == id)
            return &g.SettingsWindows[i];
    return NULL;
}

static ImGuiWindowSettings* CreateNewWindowSettings(const char* name)
{
    ImGuiContext& g = *GImGui;
    g.SettingsWindows.push_back(ImGuiWindowSettings());
    ImGuiWindowSettings* settings = &g.SettingsWindows.back();
    settings->Name = ImStrdup(name);
    settings->ID = ImHash(name, 0);
    return settings;
}

void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)
{
    size_t file_data_size = 0;
    char* file_data = (char*)ImFileLoadToMemory(ini_filename, XorString("rb"), &file_data_size);
    if (!file_data)
        return;
    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
    ImGui::MemFree(file_data);
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
{
    ImGuiContext& g = *GImGui;
    const ImGuiID type_hash = ImHash(type_name, 0, 0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
            return &g.SettingsHandlers[handler_n];
    return NULL;
}

// Zero-tolerance, no error reporting, cheap .ini parsing
void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
    if (ini_size == 0)
        ini_size = strlen(ini_data);
    char* buf = (char*)ImGui::MemAlloc(ini_size + 1);
    char* buf_end = buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf[ini_size] = 0;

    void* entry_data = NULL;
    ImGuiSettingsHandler* entry_handler = NULL;

    char* line_end = NULL;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {
        // Skip new lines markers, then find end of the line
        while (*line == '\n' || *line == '\r')
            line++;
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
            line_end++;
        line_end[0] = 0;

        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {
            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
            line_end[-1] = 0;
            const char* name_end = line_end - 1;
            const char* type_start = line + 1;
            char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');
            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
            if (!type_end || !name_start)
            {
                name_start = type_start; // Import legacy entries that have no type
                type_start = "Window";
            }
            else
            {
                *type_end = 0; // Overwrite first ']'
                name_start++;  // Skip second '['
            }
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
        }
        else if (entry_handler != NULL && entry_data != NULL)
        {
            // Let type handler parse the line
            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
        }
    }
    ImGui::MemFree(buf);
    g.SettingsLoaded = true;
}

void ImGui::SaveIniSettingsToDisk(const char* ini_filename)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    if (!ini_filename)
        return;

    size_t ini_data_size = 0;
    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
    FILE* f = ImFileOpen(ini_filename, XorString("wt"));
    if (!f)
        return;
    fwrite(ini_data, sizeof(char), ini_data_size, f);
    fclose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)
{
    ImGuiContext& g = *GImGui;
    g.SettingsDirtyTimer = 0.0f;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.push_back(0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
    {
        ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];
        handler->WriteAllFn(&g, handler, &g.SettingsIniData);
    }
    if (out_size)
        *out_size = (size_t)g.SettingsIniData.size();
    return g.SettingsIniData.c_str();
}

void ImGui::MarkIniSettingsDirty()
{
    ImGuiContext& g = *GImGui;
    if (g.SettingsDirtyTimer <= 0.0f)
        g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
        if (g.SettingsDirtyTimer <= 0.0f)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
{
    const ImGuiWindow* const a = *(const ImGuiWindow* const *)lhs;
    const ImGuiWindow* const b = *(const ImGuiWindow* const *)rhs;
    if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
        return d;
    if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
        return d;
    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
{
    out_sorted_windows->push_back(window);
    if (window->Active)
    {
        int count = window->DC.ChildWindows.Size;
        if (count > 1)
            ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
        for (int i = 0; i < count; i++)
        {
            ImGuiWindow* child = window->DC.ChildWindows[i];
            if (child->Active)
                AddWindowToSortedBuffer(out_sorted_windows, child);
        }
    }
}

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)
{
    if (draw_list->CmdBuffer.empty())
        return;

    // Remove trailing command if unused
    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();
    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)
    {
        draw_list->CmdBuffer.pop_back();
        if (draw_list->CmdBuffer.empty())
            return;
    }

    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.
    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
    // If this assert triggers because you are drawing lots of stuff manually:
    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.
    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.
    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:
    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.
    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.
    if (sizeof(ImDrawIdx) == 2)
        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

    out_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    g.IO.MetricsRenderWindows++;
    AddDrawListToDrawData(out_render_list, window->DrawList);
    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
    {
        ImGuiWindow* child = window->DC.ChildWindows[i];
        if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active
            AddWindowToDrawData(out_render_list, child);
    }
}

static void AddWindowToDrawDataSelectLayer(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);
    else
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
    int n = Layers[0].Size;
    int size = n;
    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
        size += Layers[i].Size;
    Layers[0].resize(size);
    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
    {
        ImVector<ImDrawList*>& layer = Layers[layer_n];
        if (layer.empty())
            continue;
        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
        n += layer.Size;
        layer.resize(0);
    }
}

static void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* out_draw_data)
{
    ImGuiIO& io = ImGui::GetIO();
    out_draw_data->Valid = true;
    out_draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
    out_draw_data->CmdListsCount = draw_lists->Size;
    out_draw_data->TotalVtxCount = out_draw_data->TotalIdxCount = 0;
    out_draw_data->DisplayPos = ImVec2(0.0f, 0.0f);
    out_draw_data->DisplaySize = io.DisplaySize;
    for (int n = 0; n < draw_lists->Size; n++)
    {
        out_draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;
        out_draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;
    }
}

// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.
void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DrawList->PopClipRect();
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);
    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.
        return;
    IM_ASSERT(g.FrameScopeActive && "Forgot to call ImGui::NewFrame()");

    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    if (g.IO.ImeSetInputScreenPosFn && ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f)
    {
        g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);
        g.PlatformImeLastPos = g.PlatformImePos;
    }

    // Hide implicit "Debug" window if it hasn't been used
    IM_ASSERT(g.CurrentWindowStack.Size == 1);    // Mismatched Begin()/End() calls, did you forget to call end on g.CurrentWindow->Name?
    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
        g.CurrentWindow->Active = false;
    End();

    // Show CTRL+TAB list
    if (g.NavWindowingTarget)
        NavUpdateWindowingList();

    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    if (g.DragDropActive)
    {
        bool is_delivered = g.DragDropPayload.Delivery;
        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)
            ClearDragDrop();
    }

    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)
    {
        g.DragDropWithinSourceOrTarget = true;
        SetTooltip("...");
        g.DragDropWithinSourceOrTarget = false;
    }

    // Initiate moving window
    if (g.ActiveId == 0 && g.HoveredId == 0)
    {
        if (!g.NavWindow || !g.NavWindow->Appearing) // Unless we just made a window/popup appear
        {
            // Click to focus window and start moving (after we're done with all our widgets)
            if (g.IO.MouseClicked[0])
            {
                if (g.HoveredRootWindow != NULL)
                    StartMouseMovingWindow(g.HoveredWindow);
                else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)
                    FocusWindow(NULL);  // Clicking on void disable focus
            }

            // With right mouse button we close popups without changing focus
            // (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)
            if (g.IO.MouseClicked[1])
            {
                // Find the top-most window between HoveredWindow and the front most Modal Window.
                // This is where we can trim the popup stack.
                ImGuiWindow* modal = GetFrontMostPopupModal();
                bool hovered_window_above_modal = false;
                if (modal == NULL)
                    hovered_window_above_modal = true;
                for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)
                {
                    ImGuiWindow* window = g.Windows[i];
                    if (window == modal)
                        break;
                    if (window == g.HoveredWindow)
                        hovered_window_above_modal = true;
                }
                ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);
            }
        }
    }

    // Sort the window list so that all child windows are after their parent
    // We cannot do that on FocusWindow() because childs may not exist yet
    g.WindowsSortBuffer.resize(0);
    g.WindowsSortBuffer.reserve(g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        ImGuiWindow* window = g.Windows[i];
        if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
            continue;
        AddWindowToSortedBuffer(&g.WindowsSortBuffer, window);
    }

    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);  // we done something wrong
    g.Windows.swap(g.WindowsSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;

    // Unlock font atlas
    g.IO.Fonts->Locked = false;

    // Clear Input data for next frame
    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));
    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));

    g.FrameScopeActive = false;
    g.FrameCountEnded = g.FrameCount;
}

void ImGui::Render()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.Initialized);

    if (g.FrameCountEnded != g.FrameCount)
        ImGui::EndFrame();
    g.FrameCountRendered = g.FrameCount;

    // Gather ImDrawList to render (for each active window)
    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;
    g.DrawDataBuilder.Clear();
    ImGuiWindow* windows_to_render_front_most[2];
    windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;
    windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;
    for (int n = 0; n != g.Windows.Size; n++)
    {
        ImGuiWindow* window = g.Windows[n];
        if (IsWindowActiveAndVisible(window) && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])
            AddWindowToDrawDataSelectLayer(window);
    }
    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)
        if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window
            AddWindowToDrawDataSelectLayer(windows_to_render_front_most[n]);
    g.DrawDataBuilder.FlattenIntoSingleLayer();

    // Draw software mouse cursor if requested
    if (g.IO.MouseDrawCursor)
        RenderMouseCursor(&g.OverlayDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);

    if (!g.OverlayDrawList.VtxBuffer.empty())
        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.OverlayDrawList);

    // Setup ImDrawData structure for end-user
    SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);
    g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;
    g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

    // Render. If user hasn't set a callback then they may retrieve the draw data via GetDrawData()
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)
        g.IO.RenderDrawListsFn(&g.DrawData);
#endif
}

const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
{
    const char* text_display_end = text;
    if (!text_end)
        text_end = (const char*)-1;

    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
        text_display_end++;
    return text_display_end;
}

// Pass text data straight to log (without being displayed)
void ImGui::LogText(const char* fmt, ...)
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    va_list args;
    va_start(args, fmt);
    if (g.LogFile)
        vfprintf(g.LogFile, fmt, args);
    else
        g.LogClipboard.appendfv(fmt, args);
    va_end(args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = ImGui::FindRenderedTextEnd(text, text_end);

    const bool log_new_line = ref_pos && (ref_pos->y > window->DC.LogLinePosY + 1);
    if (ref_pos)
        window->DC.LogLinePosY = ref_pos->y;

    const char* text_remaining = text;
    if (g.LogStartDepth > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth
        g.LogStartDepth = window->DC.TreeDepth;
    const int tree_depth = (window->DC.TreeDepth - g.LogStartDepth);
    for (;;)
    {
        // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
        const char* line_end = text_remaining;
        while (line_end < text_end)
            if (*line_end == '\n')
                break;
            else
                line_end++;
        if (line_end >= text_end)
            line_end = NULL;

        const bool is_first_line = (text == text_remaining);
        bool is_last_line = false;
        if (line_end == NULL)
        {
            is_last_line = true;
            line_end = text_end;
        }
        if (line_end != NULL && !(is_last_line && (line_end - text_remaining)==0))
        {
            const int char_count = (int)(line_end - text_remaining);
            if (log_new_line || !is_first_line)
                ImGui::LogText(/*IM_NEWLINE*/ XorString("\r\n %*s%.*s"), tree_depth*4, "", char_count, text_remaining);
            else
                ImGui::LogText(XorString(" %.*s"), char_count, text_remaining);
        }

        if (is_last_line)
            break;
        text_remaining = line_end + 1;
    }
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // Hide anything after a '##' string
    const char* text_display_end;
    if (hide_text_after_hash)
    {
        text_display_end = FindRenderedTextEnd(text, text_end);
    }
    else
    {
        if (!text_end)
            text_end = text + strlen(text); // FIXME-OPT
        text_display_end = text_end;
    }

    if (text != text_display_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_display_end);
    }
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = text + strlen(text); // FIXME-OPT

    if (text != text_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_end);
    }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
    // Hide anything after a '##' string
    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    const int text_len = (int)(text_display_end - text);
    if (text_len == 0)
        return;

    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // Perform CPU side clipping for single clipped element to avoid using scissor state
    ImVec2 pos = pos_min;
    const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

    const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

    // Render
    if (need_clipping)
    {
        ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    }
    else
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
    }
    if (g.LogEnabled)
        LogRenderedText(&pos, text, text_display_end);
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const float border_size = g.Style.FrameBorderSize;
    if (border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min+ImVec2(1,1), p_max+ImVec2(1,1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void ImGui::RenderArrow(ImVec2 p_min, ImGuiDir dir, float scale)
{
    ImGuiContext& g = *GImGui;

    const float h = g.FontSize * 1.00f;
    float r = h * 0.40f * scale;
    ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);

    ImVec2 a, b, c;
    switch (dir)
    {
    case ImGuiDir_Up:
    case ImGuiDir_Down:
        if (dir == ImGuiDir_Up) r = -r;
        a = ImVec2(+0.000f,+0.750f) * r;
        b = ImVec2(-0.866f,-0.750f) * r;
        c = ImVec2(+0.866f,-0.750f) * r;
        break;
    case ImGuiDir_Left:
    case ImGuiDir_Right:
        if (dir == ImGuiDir_Left) r = -r;
        a = ImVec2(+0.750f,+0.000f) * r;
        b = ImVec2(-0.750f,+0.866f) * r;
        c = ImVec2(-0.750f,-0.866f) * r;
        break;
    case ImGuiDir_None:
    case ImGuiDir_COUNT:
        IM_ASSERT(0);
        break;
    }

    g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Text));
}

void ImGui::RenderBullet(ImVec2 pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    window->DrawList->AddCircleFilled(pos, GImGui->FontSize*0.20f, GetColorU32(ImGuiCol_Text), 8);
}

void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    float thickness = ImMax(sz / 5.0f, 1.0f);
    sz -= thickness*0.5f;
    pos += ImVec2(thickness*0.25f, thickness*0.25f);

    float third = sz / 3.0f;
    float bx = pos.x + third;
    float by = pos.y + sz - third*0.5f;
    window->DrawList->PathLineTo(ImVec2(bx - third, by - third));
    window->DrawList->PathLineTo(ImVec2(bx, by));
    window->DrawList->PathLineTo(ImVec2(bx + third*2, by - third*2));
    window->DrawList->PathStroke(col, false, thickness);
}

void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (id != g.NavId)
        return;
    if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
        return;
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    if (window->DC.NavHideHighlightOneFrame)
        return;

    float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    ImRect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    if (flags & ImGuiNavHighlightFlags_TypeDefault)
    {
        const float THICKNESS = 2.0f;
        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
        display_rect.Expand(ImVec2(DISTANCE,DISTANCE));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), display_rect.Max - ImVec2(THICKNESS*0.5f,THICKNESS*0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    if (flags & ImGuiNavHighlightFlags_TypeThin)
    {
        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);
    }
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, GImGui->FontSize)
ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
    ImGuiContext& g = *GImGui;

    const char* text_display_end;
    if (hide_text_after_double_hash)
        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
    else
        text_display_end = text_end;

    ImFont* font = g.Font;
    const float font_size = g.FontSize;
    if (text == text_display_end)
        return ImVec2(0.0f, font_size);
    ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

    // Cancel out character spacing for the last character of a line (it is baked into glyph->AdvanceX field)
    const float font_scale = font_size / font->FontSize;
    const float character_spacing_x = 1.0f * font_scale;
    if (text_size.x > 0.0f)
        text_size.x -= character_spacing_x;
    text_size.x = (float)(int)(text_size.x + 0.95f);

    return text_size;
}

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.LogEnabled)
    {
        // If logging is active, do not perform any clipping
        *out_items_display_start = 0;
        *out_items_display_end = items_count;
        return;
    }
    if (window->SkipItems)
    {
        *out_items_display_start = *out_items_display_end = 0;
        return;
    }

    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
    ImRect unclipped_rect = window->ClipRect;
    if (g.NavMoveRequest)
        unclipped_rect.Add(g.NavScoringRectScreen);

    const ImVec2 pos = window->DC.CursorPos;
    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);
    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);

    // When performing a navigation request, ensure we have one item extra in the direction we are moving to
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Up)
        start--;
    if (g.NavMoveRequest && g.NavMoveClipDir == ImGuiDir_Down)
        end++;

    start = ImClamp(start, 0, items_count);
    end = ImClamp(end + 1, start, items_count);
    *out_items_display_start = start;
    *out_items_display_end = end;
}

// Find window given position, search front-to-back
// FIXME: Note that we have a lag here because WindowRectClipped is updated in Begin() so windows moved by user via SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is called, aka before the next Begin(). Moving window thankfully isn't affected.
static void FindHoveredWindow()
{
    ImGuiContext& g = *GImGui;

    ImGuiWindow* hovered_window = NULL;
    if (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoInputs))
        hovered_window = g.MovingWindow;

    for (int i = g.Windows.Size - 1; i >= 0 && hovered_window == NULL; i--)
    {
        ImGuiWindow* window = g.Windows[i];
        if (!window->Active || window->Hidden)
            continue;
        if (window->Flags & ImGuiWindowFlags_NoInputs)
            continue;

        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
        ImRect bb(window->OuterRectClipped.Min - g.Style.TouchExtraPadding, window->OuterRectClipped.Max + g.Style.TouchExtraPadding);
        if (bb.Contains(g.IO.MousePos))
        {
            if (hovered_window == NULL)
                hovered_window = window;
            if (hovered_window)
                break;
        }
    }

    g.HoveredWindow = hovered_window;
    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
{
    ImGuiContext& g = *GImGui;

    // Clip
    ImRect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

    // Expand for touch input
    const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
    return rect_for_touch.Contains(g.IO.MousePos);
}

int ImGui::GetKeyIndex(ImGuiKey imgui_key)
{
    IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);
    return GImGui->IO.KeyMap[imgui_key];
}

// Note that imgui doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]!
bool ImGui::IsKeyDown(int user_key_index)
{
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));
    return GImGui->IO.KeysDown[user_key_index];
}

int ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)
{
    if (t == 0.0f)
        return 1;
    if (t <= repeat_delay || repeat_rate <= 0.0f)
        return 0;
    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);
    return (count > 0) ? count : 0;
}

int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)
{
    ImGuiContext& g = *GImGui;
    if (key_index < 0) return false;
    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[key_index];
    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);
}

bool ImGui::IsKeyPressed(int user_key_index, bool repeat)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[user_key_index];
    if (t == 0.0f)
        return true;
    if (repeat && t > g.IO.KeyRepeatDelay)
        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
    return false;
}

bool ImGui::IsKeyReleased(int user_key_index)
{
    ImGuiContext& g = *GImGui;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];
}

bool ImGui::IsMouseDown(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDown[button];
}

bool ImGui::IsAnyMouseDown()
{
    ImGuiContext& g = *GImGui;
    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
        if (g.IO.MouseDown[n])
            return true;
    return false;
}

bool ImGui::IsMouseClicked(int button, bool repeat)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    const float t = g.IO.MouseDownDuration[button];
    if (t == 0.0f)
        return true;

    if (repeat && t > g.IO.KeyRepeatDelay)
    {
        float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;
        if ((ImFmod(t - delay, rate) > rate*0.5f) != (ImFmod(t - delay - g.IO.DeltaTime, rate) > rate*0.5f))
            return true;
    }

    return false;
}

bool ImGui::IsMouseReleased(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseReleased[button];
}

bool ImGui::IsMouseDoubleClicked(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDoubleClicked[button];
}

bool ImGui::IsMouseDragging(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (!g.IO.MouseDown[button])
        return false;
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

ImVec2 ImGui::GetMousePos()
{
    return GImGui->IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentPopupStack.Size > 0)
        return g.OpenPopupStack[g.CurrentPopupStack.Size-1].OpenMousePos;
    return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position
bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
{
    if (mouse_pos == NULL)
        mouse_pos = &GImGui->IO.MousePos;
    const float MOUSE_INVALID = -256000.0f;
    return mouse_pos->x >= MOUSE_INVALID && mouse_pos->y >= MOUSE_INVALID;
}

// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    if (g.IO.MouseDown[button])
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            return g.IO.MousePos - g.IO.MouseClickedPos[button];     // Assume we can only get active with left-mouse button (at the moment).
    return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(int button)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

ImGuiMouseCursor ImGui::GetMouseCursor()
{
    return GImGui->MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
{
    GImGui->MouseCursor = cursor_type;
}

void ImGui::CaptureKeyboardFromApp(bool capture)
{
    GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void ImGui::CaptureMouseFromApp(bool capture)
{
    GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool ImGui::IsItemActive()
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId)
    {
        ImGuiWindow* window = g.CurrentWindow;
        return g.ActiveId == window->DC.LastItemId;
    }
    return false;
}

bool ImGui::IsItemDeactivated()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);
}

bool ImGui::IsItemDeactivatedAfterEdit()
{
    ImGuiContext& g = *GImGui;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));
}

bool ImGui::IsItemFocused()
{
    ImGuiContext& g = *GImGui;
    return g.NavId && !g.NavDisableHighlight && g.NavId == g.CurrentWindow->DC.LastItemId;
}

bool ImGui::IsItemClicked(int mouse_button)
{
    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

bool ImGui::IsAnyItemHovered()
{
    ImGuiContext& g = *GImGui;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
    ImGuiContext& g = *GImGui;
    return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
    ImGuiContext& g = *GImGui;
    return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(window->DC.LastItemRect);
}

bool ImGui::IsItemEdited()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_Edited) != 0;
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
void ImGui::SetItemAllowOverlap()
{
    ImGuiContext& g = *GImGui;
    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)
        g.HoveredIdAllowOverlap = true;
    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)
        g.ActiveIdAllowOverlap = true;
}

ImVec2 ImGui::GetItemRectMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.GetSize();
}

static ImRect GetViewportRect()
{
    ImGuiContext& g = *GImGui;
    if (g.IO.DisplayVisibleMin.x != g.IO.DisplayVisibleMax.x && g.IO.DisplayVisibleMin.y != g.IO.DisplayVisibleMax.y)
        return ImRect(g.IO.DisplayVisibleMin, g.IO.DisplayVisibleMax);
    return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
}

// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.
void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)
{
    ImGuiContext& g = *GImGui;
    char window_name[16];
    ImFormatString(window_name, IM_ARRAYSIZE(window_name), XorString("##Tooltip_%02d"), g.TooltipOverrideCount);
    if (override_previous_tooltip)
        if (ImGuiWindow* window = FindWindowByName(window_name))
            if (window->Active)
            {
                // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
                window->Hidden = true;
                window->HiddenFramesRegular = 1;
                ImFormatString(window_name, IM_ARRAYSIZE(window_name), XorString("##Tooltip_%02d"), ++g.TooltipOverrideCount);
            }
    ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip|ImGuiWindowFlags_NoInputs|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoMove|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoNav;
    Begin(window_name, NULL, flags | extra_flags);
}

void ImGui::SetTooltipV(const char* fmt, va_list args)
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
        BeginTooltip();
    else
        BeginTooltipEx(0, true);
    TextV(fmt, args);
    EndTooltip();
}

void ImGui::SetTooltip(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    SetTooltipV(fmt, args);
    va_end(args);
}

void ImGui::BeginTooltip()
{
    ImGuiContext& g = *GImGui;
    if (g.DragDropWithinSourceOrTarget)
    {
        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
        ImVec2 tooltip_pos = g.IO.MousePos + ImVec2(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);
        SetNextWindowPos(tooltip_pos);
        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_PopupBg].w * 0.60f);
        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
        BeginTooltipEx(0, true);
    }
    else
    {
        BeginTooltipEx(0, false);
    }
}

void ImGui::EndTooltip()
{
    IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
    End();
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;
    int current_stack_size = g.CurrentPopupStack.Size;
    ImGuiPopupRef popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    popup_ref.PopupId = id;
    popup_ref.Window = NULL;
    popup_ref.ParentWindow = parent_window;
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window->IDStack.back();
    popup_ref.OpenMousePos = g.IO.MousePos;
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();

    //printf("[%05d] OpenPopupEx(0x%08X)\n", g.FrameCount, id);
    if (g.OpenPopupStack.Size < current_stack_size + 1)
    {
        g.OpenPopupStack.push_back(popup_ref);
    }
    else
    {
        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
        {
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        }
        else
        {
            // Close child popups if any, then flag popup for open/reopen
            g.OpenPopupStack.resize(current_stack_size + 1);
            g.OpenPopupStack[current_stack_size] = popup_ref;
        }

        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        // This is equivalent to what ClosePopupToLevel() does.
        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        //    FocusWindow(parent_window);
    }
}

void ImGui::OpenPopup(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    OpenPopupEx(g.CurrentWindow->GetID(str_id));
}

void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.empty())
        return;

    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
    // Don't close our own child popup windows.
    int n = 0;
    if (ref_window)
    {
        for (n = 0; n < g.OpenPopupStack.Size; n++)
        {
            ImGuiPopupRef& popup = g.OpenPopupStack[n];
            if (!popup.Window)
                continue;
            IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
            if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
                continue;

            // Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)
            bool has_focus = false;
            for (int m = n; m < g.OpenPopupStack.Size && !has_focus; m++)
                has_focus = (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow);
            if (!has_focus)
                break;
        }
    }
    if (n < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the block below
        ClosePopupToLevel(n);
}

ImGuiWindow* ImGui::GetFrontMostPopupModal()
{
    ImGuiContext& g = *GImGui;
    for (int n = g.OpenPopupStack.Size-1; n >= 0; n--)
        if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
            if (popup->Flags & ImGuiWindowFlags_Modal)
                return popup;
    return NULL;
}

void ImGui::ClosePopupToLevel(int remaining)
{
    IM_ASSERT(remaining >= 0);
    ImGuiContext& g = *GImGui;
    ImGuiWindow* focus_window = (remaining > 0) ? g.OpenPopupStack[remaining-1].Window : g.OpenPopupStack[0].ParentWindow;
    if (g.NavLayer == 0)
        focus_window = NavRestoreLastChildNavWindow(focus_window);
    FocusWindow(focus_window);
    focus_window->DC.NavHideHighlightOneFrame = true;
    g.OpenPopupStack.resize(remaining);
}

void ImGui::ClosePopup(ImGuiID id)
{
    if (!IsPopupOpen(id))
        return;
    ImGuiContext& g = *GImGui;
    ClosePopupToLevel(g.OpenPopupStack.Size - 1);
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup()
{
    ImGuiContext& g = *GImGui;
    int popup_idx = g.CurrentPopupStack.Size - 1;
    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.CurrentPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        return;
    while (popup_idx > 0 && g.OpenPopupStack[popup_idx].Window && (g.OpenPopupStack[popup_idx].Window->Flags & ImGuiWindowFlags_ChildMenu))
        popup_idx--;
    ClosePopupToLevel(popup_idx);
}

bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    char name[20];
    if (extra_flags & ImGuiWindowFlags_ChildMenu)
        ImFormatString(name, IM_ARRAYSIZE(name), XorString("##Menu_%02d"), g.CurrentPopupStack.Size);    // Recycle windows based on depth
    else
        ImFormatString(name, IM_ARRAYSIZE(name), XorString("##Popup_%08x"), id); // Not recycling, so we can close/open during the same frame

    bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);
    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
        EndPopup();

    return is_open;
}

bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    if (g.OpenPopupStack.Size <= g.CurrentPopupStack.Size) // Early out for performance
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }
    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags|ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::IsPopupOpen(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == id;
}

bool ImGui::IsPopupOpen(const char* str_id)
{
    ImGuiContext& g = *GImGui;
    return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);
}

bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    const ImGuiID id = window->GetID(name);
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    // Center modal windows by default
    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
    if (g.NextWindowData.PosCond == 0)
        SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    bool is_open = Begin(name, p_open, flags | ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    {
        EndPopup();
        if (is_open)
            ClosePopup(id);
        return false;
    }

    return is_open;
}

void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_None);
    ImGui::NavMoveRequestCancel();
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
    g.NavMoveRequestFlags = move_flags;
    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;
}

void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)
{
    ImGuiContext& g = *GImGui;
    if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != ImGuiNavForward_None || g.NavLayer != 0)
        return;
    IM_ASSERT(move_flags != 0); // No points calling this with no wrapping
    ImRect bb_rel = window->NavRectRel[0];

    ImGuiDir clip_dir = g.NavMoveDir;
    if (g.NavMoveDir == ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = ImGuiDir_Up; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;
        if (move_flags & ImGuiNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = ImGuiDir_Down; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = ImGuiDir_Left; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;
        if (move_flags & ImGuiNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = ImGuiDir_Right; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
}

void ImGui::EndPopup()
{
    ImGuiContext& g = *GImGui; (void)g;
    IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
    IM_ASSERT(g.CurrentPopupStack.Size > 0);

    // Make all menus and popups wrap around for now, may need to expose that policy.
    NavMoveRequestTryWrapping(g.CurrentWindow, ImGuiNavMoveFlags_LoopY);

    End();
}

bool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    {
        ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
        OpenPopupEx(id);
        return true;
    }
    return false;
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
// You can pass a NULL str_id to use the identifier of the last item.
bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)
{
    if (!str_id)
        str_id = "window_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
        if (also_over_items || !IsAnyItemHovered())
            OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)
{
    if (!str_id)
        str_id = "void_context";
    ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
        OpenPopupEx(id);
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize|ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoSavedSettings);
}

static bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* parent_window = g.CurrentWindow;

    flags |= ImGuiWindowFlags_NoTitleBar|ImGuiWindowFlags_NoResize|ImGuiWindowFlags_NoSavedSettings|ImGuiWindowFlags_ChildWindow;
    flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

    // Size
    const ImVec2 content_avail = GetContentRegionAvail();
    ImVec2 size = ImFloor(size_arg);
    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    SetNextWindowSize(size);

    // Name
    char title[256];
    if (name)
        ImFormatString(title, IM_ARRAYSIZE(title), XorString("%s/%s"), parent_window->Name, name);
    else
        ImFormatString(title, IM_ARRAYSIZE(title), XorString("%s/%08X"), parent_window->Name, id);

    const float backup_border_size = g.Style.ChildBorderSize;
    if (!border)
        g.Style.ChildBorderSize = 0.0f;
    bool ret = Begin(title, NULL, flags);
    g.Style.ChildBorderSize = backup_border_size;

    ImGuiWindow* child_window = g.CurrentWindow;
    child_window->ChildId = id;
    child_window->AutoFitChildAxises = auto_fit_axises;

    // Process navigation-in immediately so NavInit can run on first frame
    if (g.NavActivateId == id && !(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(id+1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
        g.ActiveIdSource = ImGuiInputSource_Nav;
    }

    return ret;
}

bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
    IM_ASSERT(id != 0);
    return BeginChildEx(NULL, id, size_arg, border, extra_flags);
}

void ImGui::EndChild()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
    if (window->BeginCount > 1)
    {
        End();
    }
    else
    {
        ImVec2 sz = window->Size;
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
            sz.x = ImMax(4.0f, sz.x);
        if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
            sz.y = ImMax(4.0f, sz.y);
        End();

        ImGuiWindow* parent_window = g.CurrentWindow;
        ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
        ItemSize(sz);
        if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
        {
            ItemAdd(bb, window->ChildId);
            RenderNavHighlight(bb, window->ChildId);

            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child
            if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
                RenderNavHighlight(ImRect(bb.Min - ImVec2(2,2), bb.Max + ImVec2(2,2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
        }
        else
        {
            // Not navigable into
            ItemAdd(bb, 0);
        }
    }
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
    PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);
    bool ret = BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);
    PopStyleVar(3);
    PopStyleColor();
    return ret;
}

void ImGui::EndChildFrame()
{
    EndChild();
}

// Save and compare stack sizes on Begin()/End() to detect usage errors
static void CheckStacksSize(ImGuiWindow* window, bool write)
{
    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
    ImGuiContext& g = *GImGui;
    int* p_backup = &window->DC.StackSizesBackup[0];
    { int current = window->IDStack.Size;       if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!");   p_backup++; }    // Too few or too many PopID()/TreePop()
    { int current = window->DC.GroupStack.Size; if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");                p_backup++; }    // Too few or too many EndGroup()
    { int current = g.CurrentPopupStack.Size;   if (write) *p_backup = current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++;}// Too few or too many EndMenu()/EndPopup()
    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
    { int current = g.ColorModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");       p_backup++; }    // Too few or too many PopStyleColor()
    { int current = g.StyleModifiers.Size;      if (write) *p_backup = current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");           p_backup++; }    // Too few or too many PopStyleVar()
    { int current = g.FontStack.Size;           if (write) *p_backup = current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                   p_backup++; }    // Too few or too many PopFont()
    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
}

ImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow*)
{
    ImVec2 padding = GImGui->Style.DisplaySafeAreaPadding;
    ImRect r_screen = GetViewportRect();
    r_screen.Expand(ImVec2((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
    return r_screen;
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)
{
    ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
    //GImGui->OverlayDrawList.AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
    //GImGui->OverlayDrawList.AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

    // Combo Box policy (we want a connecting edge)
    if (policy == ImGuiPopupPositionPolicy_ComboBox)
    {
        const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
        for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
        {
            const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir) // Already tried this direction?
                continue;
            ImVec2 pos;
            if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
            if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
            if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
            if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
            if (!r_outer.Contains(ImRect(pos, pos + size)))
                continue;
            *last_dir = dir;
            return pos;
        }
    }

    // Default popup policy
    const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
    for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
    {
        const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
        if (n != -1 && dir == *last_dir) // Already tried this direction?
            continue;
        float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
        float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);
        if (avail_w < size.x || avail_h < size.y)
            continue;
        ImVec2 pos;
        pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
        pos.y = (dir == ImGuiDir_Up)   ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down)  ? r_avoid.Max.y : base_pos_clamped.y;
        *last_dir = dir;
        return pos;
    }

    // Fallback, try to keep within display
    *last_dir = ImGuiDir_None;
    ImVec2 pos = ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}

ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    ImRect r_outer = GetWindowAllowedExtentRect(window);
    if (window->Flags & ImGuiWindowFlags_ChildMenu)
    {
        // Child menus typically request _any_ position within the parent menu item, and then our FindBestWindowPosForPopup() function will move the new menu outside the parent bounds.
        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
        IM_ASSERT(g.CurrentWindow == window);
        ImGuiWindow* parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];
        float horizontal_overlap = g.Style.ItemSpacing.x;       // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
        ImRect r_avoid;
        if (parent_window->DC.MenuBarAppending)
            r_avoid = ImRect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());
        else
            r_avoid = ImRect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Popup)
    {
        ImRect r_avoid = ImRect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Position tooltip (always follows mouse)
        float sc = g.Style.MouseCursorScale;
        ImVec2 ref_pos = NavCalcPreferredRefPos();
        ImRect r_avoid;
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
        else
            r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
        ImVec2 pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
        if (window->AutoPosLastDirection == ImGuiDir_None)
            pos = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
        return pos;
    }
    IM_ASSERT(0);
    return window->Pos;
}

static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
{
    window->SetWindowPosAllowFlags       = enabled ? (window->SetWindowPosAllowFlags       | flags) : (window->SetWindowPosAllowFlags       & ~flags);
    window->SetWindowSizeAllowFlags      = enabled ? (window->SetWindowSizeAllowFlags      | flags) : (window->SetWindowSizeAllowFlags      & ~flags);
    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

ImGuiWindow* ImGui::FindWindowByName(const char* name)
{
    ImGuiContext& g = *GImGui;
    ImGuiID id = ImHash(name, 0);
    return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
}

static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;

    // Create window the first time
    ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
    window->Flags = flags;
    g.WindowsById.SetVoidPtr(window->ID, window);

    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
    window->Pos = ImVec2(60, 60);

    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
    if (!(flags & ImGuiWindowFlags_NoSavedSettings))
        if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
        {
            // Retrieve settings from .ini file
            window->SettingsIdx = g.SettingsWindows.index_from_pointer(settings);
            SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
            window->Pos = ImFloor(settings->Pos);
            window->Collapsed = settings->Collapsed;
            if (ImLengthSqr(settings->Size) > 0.00001f)
                size = ImFloor(settings->Size);
        }
    window->Size = window->SizeFull = window->SizeFullAtLastBegin = size;
    window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values

    if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
    {
        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
    else
    {
        if (window->Size.x <= 0.0f)
            window->AutoFitFramesX = 2;
        if (window->Size.y <= 0.0f)
            window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
    }

    if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
        g.Windows.insert(g.Windows.begin(), window); // Quite slow but rare and only once
    else
        g.Windows.push_back(window);
    return window;
}

static ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)
{
    ImGuiContext& g = *GImGui;
    if (g.NextWindowData.SizeConstraintCond != 0)
    {
        // Using -1,-1 on either X/Y axis to preserve the current size.
        ImRect cr = g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        if (g.NextWindowData.SizeCallback)
        {
            ImGuiSizeCallbackData data;
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window->Pos;
            data.CurrentSize = window->SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
    }

    // Minimum size
    if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
    {
        new_size = ImMax(new_size, g.Style.WindowMinSize);
        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows
    }
    return new_size;
}

static ImVec2 CalcSizeContents(ImGuiWindow* window)
{
    ImVec2 sz;
    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));
    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));
    return sz + window->WindowPadding;
}

static ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)
{
    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    if (window->Flags & ImGuiWindowFlags_Tooltip)
    {
        // Tooltip always resize
        return size_contents;
    }
    else
    {
        // When the window cannot fit all contents (either because of constraints, either because screen is too small): we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than DisplaySize-WindowPadding.
        const bool is_popup = (window->Flags & ImGuiWindowFlags_Popup) != 0;
        const bool is_menu = (window->Flags & ImGuiWindowFlags_ChildMenu) != 0;
        ImVec2 size_min = style.WindowMinSize;
        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
            size_min = ImMin(size_min, ImVec2(4.0f, 4.0f));
        ImVec2 size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));
        ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);
        if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & ImGuiWindowFlags_NoScrollbar) && (window->Flags & ImGuiWindowFlags_HorizontalScrollbar))
            size_auto_fit.y += style.ScrollbarSize;
        if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & ImGuiWindowFlags_NoScrollbar))
            size_auto_fit.x += style.ScrollbarSize;
        return size_auto_fit;
    }
}

ImVec2 ImGui::CalcWindowExpectedSize(ImGuiWindow* window)
{
    ImVec2 size_contents = CalcSizeContents(window);
    return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));
}

static float GetScrollMaxX(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));
}

static float GetScrollMaxY(ImGuiWindow* window)
{
    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges)
{
    ImGuiContext& g = *GImGui;
    ImVec2 scroll = window->Scroll;
    if (window->ScrollTarget.x < FLT_MAX)
    {
        float cr_x = window->ScrollTargetCenterRatio.x;
        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);
    }
    if (window->ScrollTarget.y < FLT_MAX)
    {
        // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.
        float cr_y = window->ScrollTargetCenterRatio.y;
        float target_y = window->ScrollTarget.y;
        if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)
            target_y = 0.0f;
        if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)
            target_y = window->SizeContents.y;
        scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);
    }
    scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));
    if (!window->Collapsed && !window->SkipItems)
    {
        scroll.x = ImMin(scroll.x, GetScrollMaxX(window));
        scroll.y = ImMin(scroll.y, GetScrollMaxY(window));
    }
    return scroll;
}

static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)
{
    if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        return ImGuiCol_PopupBg;
    if (flags & ImGuiWindowFlags_ChildWindow)
        return ImGuiCol_ChildBg;
    return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
{
    ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
    ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
    ImVec2 size_expected = pos_max - pos_min;
    ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);
    *out_pos = pos_min;
    if (corner_norm.x == 0.0f)
        out_pos->x -= (size_constrained.x - size_expected.x);
    if (corner_norm.y == 0.0f)
        out_pos->y -= (size_constrained.y - size_expected.y);
    *out_size = size_constrained;
}

struct ImGuiResizeGripDef
{
    ImVec2  CornerPos;
    ImVec2  InnerDir;
    int     AngleMin12, AngleMax12;
};

const ImGuiResizeGripDef resize_grip_def[4] =
{
    { ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right
    { ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left
    { ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left
    { ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right
};

static ImRect GetBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
{
    ImRect rect = window->Rect();
    if (thickness == 0.0f) rect.Max -= ImVec2(1,1);
    if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y,                rect.Max.x - perp_padding, rect.Min.y + thickness);
    if (border_n == 1) return ImRect(rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x,                rect.Max.y - perp_padding);
    if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y);
    if (border_n == 3) return ImRect(rect.Min.x,                rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding);
    IM_ASSERT(0);
    return ImRect();
}

// Handle resize for: Resize Grips, Borders, Gamepad
static void ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])
{
    ImGuiContext& g = *GImGui;
    ImGuiWindowFlags flags = window->Flags;
    if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        return;

    const int resize_border_count = g.IO.ConfigResizeWindowsFromEdges ? 4 : 0;
    const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
    const float grip_hover_size = (float)(int)(grip_draw_size * 0.75f);

    ImVec2 pos_target(FLT_MAX, FLT_MAX);
    ImVec2 size_target(FLT_MAX, FLT_MAX);

    // Manual resize grips
    PushID(XorString("#RESIZE"));
    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    {
        const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
        const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);

        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        ImRect resize_rect(corner, corner + grip.InnerDir * grip_hover_size);
        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        bool hovered, held;
        ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
        if (hovered || held)
            g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
        {
            // Manual auto-fit when double-clicking
            size_target = CalcSizeAfterConstraint(window, size_auto_fit);
            ClearActiveID();
        }
        else if (held)
        {
            // Resize from any of the four corners
            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
            ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + resize_rect.GetSize() * grip.CornerPos; // Corner of the window corresponding to our corner grip
            CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPos, &pos_target, &size_target);
        }
        if (resize_grip_n == 0 || held || hovered)
            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
    }
    for (int border_n = 0; border_n < resize_border_count; border_n++)
    {
        const float BORDER_SIZE = 5.0f;          // FIXME: Only works _inside_ window because of HoveredWindow check.
        const float BORDER_APPEAR_TIMER = 0.05f; // Reduce visual noise
        bool hovered, held;
        ImRect border_rect = GetBorderRect(window, border_n, grip_hover_size, BORDER_SIZE);
        ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);
        if ((hovered && g.HoveredIdTimer > BORDER_APPEAR_TIMER) || held)
        {
            g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
            if (held) *border_held = border_n;
        }
        if (held)
        {
            ImVec2 border_target = window->Pos;
            ImVec2 border_posn;
            if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y); }
            if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + BORDER_SIZE); }
            if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + BORDER_SIZE); }
            if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x); }
            CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);
        }
    }
    PopID();

    // Navigation resize (keyboard/gamepad)
    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)
    {
        ImVec2 nav_resize_delta;
        if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
        if (g.NavInputSource == ImGuiInputSource_NavGamepad)
            nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);
        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)
        {
            const float NAV_RESIZE_SPEED = 600.0f;
            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
            g.NavWindowingToggleLayer = false;
            g.NavDisableMouseHover = true;
            resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
            size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);
        }
    }

    // Apply back modified position/size to window
    if (size_target.x != FLT_MAX)
    {
        window->SizeFull = size_target;
        MarkIniSettingsDirty(window);
    }
    if (pos_target.x != FLT_MAX)
    {
        window->Pos = ImFloor(pos_target);
        MarkIniSettingsDirty(window);
    }

    window->Size = window->SizeFull;
}

void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)
{
    window->ParentWindow = parent_window;
    window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
        window->RootWindow = parent_window->RootWindow;
    if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
}

// Push a new ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    IM_ASSERT(name != NULL);                        // Window name required
    IM_ASSERT(g.FrameScopeActive);                  // Forgot to call ImGui::NewFrame()
    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

    // Find or create
    ImGuiWindow* window = FindWindowByName(name);
    const bool window_just_created = (window == NULL);
    if (window_just_created)
    {
        ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
        window = CreateNewWindow(name, size_on_first_use, flags);
    }

    // Automatically disable manual moving/resizing when NoInputs is set
    if (flags & ImGuiWindowFlags_NoInputs)
        flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

    if (flags & ImGuiWindowFlags_NavFlattened)
        IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);

    const int current_frame = g.FrameCount;
    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
    if (first_begin_of_the_frame)
        window->Flags = (ImGuiWindowFlags)flags;
    else
        flags = window->Flags;

    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
    ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));
    window->HasCloseButton = (p_open != NULL);

    // Update the Appearing flag
    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesForResize > 0);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];
        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        window_just_activated_by_user |= (window != popup_ref.Window);
    }
    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

    // Add to stack
    g.CurrentWindowStack.push_back(window);
    SetCurrentWindow(window);
    CheckStacksSize(window, true);
    if (flags & ImGuiWindowFlags_Popup)
    {
        ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];
        popup_ref.Window = window;
        g.CurrentPopupStack.push_back(popup_ref);
        window->PopupId = popup_ref.PopupId;
    }

    if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))
        window->NavLastIds[0] = 0;

    // Process SetNextWindow***() calls
    bool window_pos_set_by_api = false;
    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    if (g.NextWindowData.PosCond)
    {
        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        {
            // May be processed on the next frame if this is our first frame and we are measuring size
            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
            window->SetWindowPosVal = g.NextWindowData.PosVal;
            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
        }
        else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (g.NextWindowData.SizeCond)
    {
        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (g.NextWindowData.ContentSizeCond)
    {
        // Adjust passed "client size" to become a "window size"
        window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
        if (window->SizeContentsExplicit.y != 0.0f)
            window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
    }
    else if (first_begin_of_the_frame)
    {
        window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);
    }
    if (g.NextWindowData.CollapsedCond)
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    if (g.NextWindowData.FocusCond)
        FocusWindow(window);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    if (first_begin_of_the_frame)
    {
        // Initialize
        const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
        UpdateWindowParentAndRootLinks(window, flags, parent_window);

        window->Active = true;
        window->BeginOrderWithinParent = 0;
        window->BeginOrderWithinContext = g.WindowsActiveCount++;
        window->BeginCount = 0;
        window->ClipRect = ImVec4(-FLT_MAX,-FLT_MAX,+FLT_MAX,+FLT_MAX);
        window->LastFrameActive = current_frame;
        window->IDStack.resize(1);

        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

        // Update contents size from last frame for auto-fitting (or use explicit size)
        window->SizeContents = CalcSizeContents(window);
        if (window->HiddenFramesRegular > 0)
            window->HiddenFramesRegular--;
        if (window->HiddenFramesForResize > 0)
            window->HiddenFramesForResize--;

        // Hide new windows for one frame until they calculate their size
        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
            window->HiddenFramesForResize = 1;

        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        // We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
        if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
        {
            window->HiddenFramesForResize = 1;
            if (flags & ImGuiWindowFlags_AlwaysAutoResize)
            {
                if (!window_size_x_set_by_api)
                    window->Size.x = window->SizeFull.x = 0.f;
                if (!window_size_y_set_by_api)
                    window->Size.y = window->SizeFull.y = 0.f;
                window->SizeContents = ImVec2(0.f, 0.f);
            }
        }

        SetCurrentWindow(window);

        // Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowBorderSize = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildBorderSize : ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
        window->WindowPadding = style.WindowPadding;
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
            window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

        // Collapse window by double-clicking on title bar
        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
        if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))
        {
            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
            ImRect title_bar_rect = window->TitleBarRect();
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
                window->WantCollapseToggle = true;
            if (window->WantCollapseToggle)
            {
                window->Collapsed = !window->Collapsed;
                MarkIniSettingsDirty(window);
                FocusWindow(window);
            }
        }
        else
        {
            window->Collapsed = false;
        }
        window->WantCollapseToggle = false;

        // SIZE

        // Calculate auto-fit size, handle automatic resize
        const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
        ImVec2 size_full_modified(FLT_MAX, FLT_MAX);
        if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        {
            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
            if (!window_size_x_set_by_api)
                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
            if (!window_size_y_set_by_api)
                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
        }
        else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        {
            // Auto-fit may only grow window during the first few frames
            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
            if (!window->Collapsed)
                MarkIniSettingsDirty(window);
        }

        // Apply minimum/maximum window size constraints and final size
        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
        window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

        // SCROLLBAR STATUS

        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
        if (!window->Collapsed)
        {
            // When reading the current size we need to read it after size constraints have been applied
            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
            window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
            window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
            if (window->ScrollbarX && !window->ScrollbarY)
                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
            window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        }

        // POSITION

        // Popup latch its initial position, will position itself when it appears next frame
        if (window_just_activated_by_user)
        {
            window->AutoPosLastDirection = ImGuiDir_None;
            if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)
                window->Pos = g.CurrentPopupStack.back().OpenPopupPos;
        }

        // Position child window
        if (flags & ImGuiWindowFlags_ChildWindow)
        {
            window->BeginOrderWithinParent = parent_window->DC.ChildWindows.Size;
            parent_window->DC.ChildWindows.push_back(window);
            if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
                window->Pos = parent_window->DC.CursorPos;
        }

        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesForResize == 0);
        if (window_pos_with_pivot)
            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
        else if ((flags & ImGuiWindowFlags_ChildMenu) != 0)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
            window->Pos = FindBestWindowPosForPopup(window);

        // Clamp position so it stays visible
        if (!(flags & ImGuiWindowFlags_ChildWindow))
        {
            if (!window_pos_set_by_api && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
            {
                ImVec2 padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
                window->Pos = ImMax(window->Pos + window->Size, padding) - window->Size;
                window->Pos = ImMin(window->Pos, g.IO.DisplaySize - padding);
            }
        }
        window->Pos = ImFloor(window->Pos);

        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

        // Prepare for item focus requests
        window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter+1)) % (window->FocusIdxAllCounter+1);
        window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter+1)) % (window->FocusIdxTabCounter+1);
        window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;
        window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;

        // Apply scrolling
        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
        window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

        // Apply window focus (new and reactivated windows are moved to front)
        bool want_focus = false;
        if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
            if (!(flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) || (flags & ImGuiWindowFlags_Popup))
                want_focus = true;

        // Handle manual resize: Resize Grips, Borders, Gamepad
        int border_held = -1;
        ImU32 resize_grip_col[4] = { 0 };
        const int resize_grip_count = g.IO.ConfigResizeWindowsFromEdges ? 2 : 1; // 4
        const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
        if (!window->Collapsed)
            UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);

        // Default item width. Make it proportional to window size if window manually resizes
        if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
        else
            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

        // DRAWING

        // Setup draw list and outer clipping rectangle
        window->DrawList->Clear();
        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
        ImRect viewport_rect(GetViewportRect());
        if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
        else
            PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

        // Draw modal window background (darkens what is behind them, all viewports)
        const bool dim_bg_for_modal = (flags & ImGuiWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesForResize <= 0;
        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
        if (dim_bg_for_modal || dim_bg_for_window_list)
        {
            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? ImGuiCol_ModalWindowDimBg : ImGuiCol_NavWindowingDimBg, g.DimBgRatio);
            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
        }

        // Draw navigation selection/windowing rectangle background
        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
        {
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
        }

        // Draw window + handle manual resize
        const float window_rounding = window->WindowRounding;
        const float window_border_size = window->WindowBorderSize;
        const ImGuiWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
        const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
        const ImRect title_bar_rect = window->TitleBarRect();
        if (window->Collapsed)
        {
            // Title bar only
            float backup_border_size = style.FrameBorderSize;
            g.Style.FrameBorderSize = window->WindowBorderSize;
            ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
            g.Style.FrameBorderSize = backup_border_size;
        }
        else
        {
            // Window background
            ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));
            if (g.NextWindowData.BgAlphaCond != 0)
            {
                bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(g.NextWindowData.BgAlphaVal) << IM_COL32_A_SHIFT);
                g.NextWindowData.BgAlphaCond = 0;
            }
            window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);

            // Title bar
            ImU32 title_bar_col = GetColorU32(window->Collapsed ? ImGuiCol_TitleBgCollapsed : title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
            if (!(flags & ImGuiWindowFlags_NoTitleBar))
                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);

            // Menu bar
            if (flags & ImGuiWindowFlags_MenuBar)
            {
                ImRect menu_bar_rect = window->MenuBarRect();
                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
                window->DrawList->AddRectFilled(menu_bar_rect.Min, menu_bar_rect.Max, GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
            }

            // Scrollbars
            if (window->ScrollbarX)
                Scrollbar(ImGuiLayoutType_Horizontal);
            if (window->ScrollbarY)
                Scrollbar(ImGuiLayoutType_Vertical);

            // Render resize grips (after their input handling so we don't have a frame of latency)
            if (!(flags & ImGuiWindowFlags_NoResize))
            {
                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
                {
                    const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
                    const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));
                    window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
                }
            }

            // Borders
            if (window_border_size > 0.0f)
                window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), window_rounding, ImDrawCornerFlags_All, window_border_size);
            if (border_held != -1)
            {
                ImRect border = GetBorderRect(window, border_held, grip_draw_size, 0.0f);
                window->DrawList->AddLine(border.Min, border.Max, GetColorU32(ImGuiCol_SeparatorActive), ImMax(1.0f, window_border_size));
            }
            if (style.FrameBorderSize > 0 && !(flags & ImGuiWindowFlags_NoTitleBar))
                window->DrawList->AddLine(title_bar_rect.GetBL() + ImVec2(style.WindowBorderSize, -1), title_bar_rect.GetBR() + ImVec2(-style.WindowBorderSize, -1), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
        }

        // Draw navigation selection/windowing rectangle border
        if (g.NavWindowingTargetAnim == window)
        {
            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
            ImRect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
            {
                bb.Expand(-g.FontSize - 1.0f);
                rounding = window->WindowRounding;
            }
            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
        }

        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
        window->SizeFullAtLastBegin = window->SizeFull;

        // Update various regions. Variables they depends on are set above in this function.
        // FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
        window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
        window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
        window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

        // Setup drawing context
        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
        window->DC.GroupOffset.x = 0.0f;
        window->DC.ColumnsOffset.x = 0.0f;
        window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
        window->DC.CursorPos = window->DC.CursorStartPos;
        window->DC.CursorPosPrevLine = window->DC.CursorPos;
        window->DC.CursorMaxPos = window->DC.CursorStartPos;
        window->DC.CurrentLineSize = window->DC.PrevLineSize = ImVec2(0.0f, 0.0f);
        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
        window->DC.NavHideHighlightOneFrame = false;
        window->DC.NavHasScroll = (GetScrollMaxY() > 0.0f);
        window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
        window->DC.NavLayerActiveMaskNext = 0x00;
        window->DC.MenuBarAppending = false;
        window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;
        window->DC.ChildWindows.resize(0);
        window->DC.LayoutType = ImGuiLayoutType_Vertical;
        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
        window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : ImGuiItemFlags_Default_;
        window->DC.ItemWidth = window->ItemWidthDefault;
        window->DC.TextWrapPos = -1.0f; // disabled
        window->DC.ItemFlagsStack.resize(0);
        window->DC.ItemWidthStack.resize(0);
        window->DC.TextWrapPosStack.resize(0);
        window->DC.ColumnsSet = NULL;
        window->DC.TreeDepth = 0;
        window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
        window->DC.StateStorage = &window->StateStorage;
        window->DC.GroupStack.resize(0);
        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

        if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
        {
            window->DC.ItemFlags = parent_window->DC.ItemFlags;
            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
        }

        if (window->AutoFitFramesX > 0)
            window->AutoFitFramesX--;
        if (window->AutoFitFramesY > 0)
            window->AutoFitFramesY--;

        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        if (want_focus)
        {
            FocusWindow(window);
            NavInitWindow(window, false);
        }

        // Title bar
        if (!(flags & ImGuiWindowFlags_NoTitleBar))
        {
            // Close & collapse button are on layer 1 (same as menus) and don't default focus
            const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
            window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
            window->DC.NavLayerCurrent++;
            window->DC.NavLayerCurrentMask <<= 1;

            // Collapse button
            if (!(flags & ImGuiWindowFlags_NoCollapse))
                if (CollapseButton(window->GetID(XorString("#COLLAPSE")), window->Pos))
                    window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

            // Close button
            if (p_open != NULL)
            {
                const float pad = style.FramePadding.y;
                const float rad = g.FontSize * 0.5f;
                if (CloseButton(window->GetID(XorString("#CLOSE")), window->Rect().GetTR() + ImVec2(-pad - rad, pad + rad), rad + 1))
                    *p_open = false;
            }

            window->DC.NavLayerCurrent--;
            window->DC.NavLayerCurrentMask >>= 1;
            window->DC.ItemFlags = item_flags_backup;

            // Title text (FIXME: refactor text alignment facilities along with RenderText helpers, this is too much code for what it does.)
            ImVec2 text_size = CalcTextSize(name, NULL, true);
            ImRect text_r = title_bar_rect;
            float pad_left = (flags & ImGuiWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            float pad_right = (p_open == NULL)                     ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            if (style.WindowTitleAlign.x > 0.0f)
                pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
            text_r.Min.x += pad_left;
            text_r.Max.x -= pad_right;
            ImRect clip_rect = text_r;
            clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
            RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
        }

        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
        window->OuterRectClipped = window->Rect();
        window->OuterRectClipped.ClipWith(window->ClipRect);

        // Pressing CTRL+C while holding on a window copy its content to the clipboard
        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        // Maybe we can support CTRL+C on every element?
        /*
        if (g.ActiveId == move_id)
            if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
                ImGui::LogToClipboard();
        */

        // Inner rectangle
        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
        window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
        window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
        window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
        //window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

        // Inner clipping rectangle
        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x*0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

        // After Begin() we fill the last item / hovered data based on title bar data. It is a standard behavior (to allow creation of context menus on title bar only, etc.).
        window->DC.LastItemId = window->MoveId;
        window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;
        window->DC.LastItemRect = title_bar_rect;
    }

    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    if (first_begin_of_the_frame)
        window->WriteAccessed = false;

    window->BeginCount++;
    g.NextWindowData.Clear();

    if (flags & ImGuiWindowFlags_ChildWindow)
    {
        // Child window can be out of sight and have "negative" clip windows.
        // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
        IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);

        if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
                window->HiddenFramesRegular = 1;

        // Completely hide along with parent or if parent is collapsed
        if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
            window->HiddenFramesRegular = 1;
    }

    // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
    if (style.Alpha <= 0.0f)
        window->HiddenFramesRegular = 1;

    // Update the Hidden flag
    window->Hidden = (window->HiddenFramesRegular > 0) || (window->HiddenFramesForResize);

    // Return false if we don't intend to display anything to allow user to perform an early out optimization
    window->SkipItems = (window->Collapsed || !window->Active || window->Hidden) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesForResize <= 0;

    return !window->SkipItems;
}

// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)
{
    // Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.
    if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)
        ImGui::SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);

    // Old API feature: override the window background alpha with a parameter.
    if (bg_alpha_override >= 0.0f)
        ImGui::SetNextWindowBgAlpha(bg_alpha_override);

    return ImGui::Begin(name, p_open, flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

void ImGui::End()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    if (window->DC.ColumnsSet != NULL)
        EndColumns();
    PopClipRect();   // Inner window clip rectangle

    // Stop logging
    if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
        LogFinish();

    // Pop from window stack
    g.CurrentWindowStack.pop_back();
    if (window->Flags & ImGuiWindowFlags_Popup)
        g.CurrentPopupStack.pop_back();
    CheckStacksSize(window, false);
    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());
}

// Vertical scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
void ImGui::Scrollbar(ImGuiLayoutType direction)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const bool horizontal = (direction == ImGuiLayoutType_Horizontal);
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(horizontal ? XorString("#SCROLLX") : XorString("#SCROLLY"));

    // Render background
    bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);
    float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;
    const ImRect window_rect = window->Rect();
    const float border_size = window->WindowBorderSize;
    ImRect bb = horizontal
        ? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)
        : ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);
    if (!horizontal)
        bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);
    if (bb.GetWidth() <= 0.0f || bb.GetHeight() <= 0.0f)
        return;

    int window_rounding_corners;
    if (horizontal)
        window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    else
        window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
    window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);
    bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

    // V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
    float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();
    float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;
    float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;
    float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

    // Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
    // But we maintain a minimum size in pixel to allow for the user to still aim inside.
    IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
    const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);
    const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);
    const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

    // Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
    bool held = false;
    bool hovered = false;
    const bool previously_held = (g.ActiveId == id);
    ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

    float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);
    float scroll_ratio = ImSaturate(scroll_v / scroll_max);
    float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
    if (held && grab_h_norm < 1.0f)
    {
        float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;
        float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
        float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

        // Click position in scrollbar normalized space (0.0f->1.0f)
        const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
        SetHoveredID(id);

        bool seek_absolute = false;
        if (!previously_held)
        {
            // On initial click calculate the distance between mouse and the center of the grab
            if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)
            {
                *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
            }
            else
            {
                seek_absolute = true;
                *click_delta_to_grab_center_v = 0.0f;
            }
        }

        // Apply scroll
        // It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position
        const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm*0.5f) / (1.0f - grab_h_norm));
        scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));
        if (horizontal)
            window->Scroll.x = scroll_v;
        else
            window->Scroll.y = scroll_v;

        // Update values for rendering
        scroll_ratio = ImSaturate(scroll_v / scroll_max);
        grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

        // Update distance to grab now that we have seeked and saturated
        if (seek_absolute)
            *click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm*0.5f;
    }

    // Render
    const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab);
    ImRect grab_rect;
    if (horizontal)
        grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, window_rect.Max.x), bb.Max.y);
    else
        grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, window_rect.Max.y));
    window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
}

void ImGui::BringWindowToFront(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* current_front_window = g.Windows.back();
    if (current_front_window == window || current_front_window->RootWindow == window)
        return;
    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.Windows[i] == window)
        {
            g.Windows.erase(g.Windows.Data + i);
            g.Windows.push_back(window);
            break;
        }
}

void ImGui::BringWindowToBack(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;
    if (g.Windows[0] == window)
        return;
    for (int i = 0; i < g.Windows.Size; i++)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
            g.Windows[0] = window;
            break;
        }
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow(ImGuiWindow* window)
{
    ImGuiContext& g = *GImGui;

    if (g.NavWindow != window)
    {
        g.NavWindow = window;
        if (window && g.NavDisableMouseHover)
            g.NavMousePosDirty = true;
        g.NavInitRequest = false;
        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
        g.NavIdIsAlive = false;
        g.NavLayer = 0;
        //printf("[%05d] FocusWindow(\"%s\")\n", g.FrameCount, window ? window->Name : NULL);
    }

    // Passing NULL allow to disable keyboard focus
    if (!window)
        return;

    // Move the root window to the top of the pile
    if (window->RootWindow)
        window = window->RootWindow;

    // Steal focus on active widgets
    if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..
        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)
            ClearActiveID();

    // Bring to front
    if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))
        BringWindowToFront(window);
}

void ImGui::FocusFrontMostActiveWindowIgnoringOne(ImGuiWindow* ignore_window)
{
    ImGuiContext& g = *GImGui;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
        if (g.Windows[i] != ignore_window && g.Windows[i]->WasActive && !(g.Windows[i]->Flags & ImGuiWindowFlags_ChildWindow))
        {
            ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(g.Windows[i]);
            FocusWindow(focus_window);
            return;
        }
}

void ImGui::PushItemWidth(float item_width)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
}

void ImGui::PushMultiItemsWidths(int components, float w_full)
{
    ImGuiWindow* window = GetCurrentWindow();
    const ImGuiStyle& style = GImGui->Style;
    if (w_full <= 0.0f)
        w_full = CalcItemWidth();
    const float w_item_one  = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));
    window->DC.ItemWidthStack.push_back(w_item_last);
    for (int i = 0; i < components-1; i++)
        window->DC.ItemWidthStack.push_back(w_item_one);
    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
}

void ImGui::PopItemWidth()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemWidthStack.pop_back();
    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();
}

float ImGui::CalcItemWidth()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    float w = window->DC.ItemWidth;
    if (w < 0.0f)
    {
        // Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.
        float width_to_right_edge = GetContentRegionAvail().x;
        w = ImMax(1.0f, width_to_right_edge + w);
    }
    w = (float)(int)w;
    return w;
}

void ImGui::SetCurrentFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    IM_ASSERT(font->Scale > 0.0f);
    g.Font = font;
    g.FontBaseSize = g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale;
    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont(ImFont* font)
{
    ImGuiContext& g = *GImGui;
    if (!font)
        font = GetDefaultFont();
    SetCurrentFont(font);
    g.FontStack.push_back(font);
    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void  ImGui::PopFont()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DrawList->PopTextureID();
    g.FontStack.pop_back();
    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (enabled)
        window->DC.ItemFlags |= option;
    else
        window->DC.ItemFlags &= ~option;
    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
}

void ImGui::PopItemFlag()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.ItemFlagsStack.pop_back();
    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();
}

void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
    PushItemFlag(ImGuiItemFlags_AllowKeyboardFocus, allow_keyboard_focus);
}

void ImGui::PopAllowKeyboardFocus()
{
    PopItemFlag();
}

void ImGui::PushButtonRepeat(bool repeat)
{
    PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);
}

void ImGui::PopButtonRepeat()
{
    PopItemFlag();
}

void ImGui::PushTextWrapPos(float wrap_pos_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPos = wrap_pos_x;
    window->DC.TextWrapPosStack.push_back(wrap_pos_x);
}

void ImGui::PopTextWrapPos()
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.TextWrapPosStack.pop_back();
    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
{
    ImGuiContext& g = *GImGui;
    ImGuiColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        ImGuiColorMod& backup = g.ColorModifiers.back();
        g.Style.Colors[backup.Col] = backup.BackupValue;
        g.ColorModifiers.pop_back();
        count--;
    }
}

struct ImGuiStyleVarInfo
{
    ImGuiDataType   Type;
    ImU32           Count;
    ImU32           Offset;
    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },              // ImGuiStyleVar_Alpha
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },      // ImGuiStyleVar_WindowPadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },     // ImGuiStyleVar_WindowRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },   // ImGuiStyleVar_WindowBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },      // ImGuiStyleVar_WindowMinSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },   // ImGuiStyleVar_WindowTitleAlign
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },      // ImGuiStyleVar_ChildRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },    // ImGuiStyleVar_ChildBorderSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },      // ImGuiStyleVar_PopupRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },    // ImGuiStyleVar_PopupBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },       // ImGuiStyleVar_FramePadding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },      // ImGuiStyleVar_FrameRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },    // ImGuiStyleVar_FrameBorderSize
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },        // ImGuiStyleVar_ItemSpacing
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },   // ImGuiStyleVar_ItemInnerSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },      // ImGuiStyleVar_IndentSpacing
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },      // ImGuiStyleVar_ScrollbarSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },  // ImGuiStyleVar_ScrollbarRounding
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },        // ImGuiStyleVar_GrabMinSize
    { ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },       // ImGuiStyleVar_GrabRounding
    { ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },    // ImGuiStyleVar_ButtonTextAlign
};

static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
{
    IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
    return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
    {
        ImGuiContext& g = *GImGui;
        float* pvar = (float*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
{
    const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
    {
        ImGuiContext& g = *GImGui;
        ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.
}

void ImGui::PopStyleVar(int count)
{
    ImGuiContext& g = *GImGui;
    while (count > 0)
    {
        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
        ImGuiStyleMod& backup = g.StyleModifiers.back();
        const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&g.Style);
        if (info->Type == ImGuiDataType_Float && info->Count == 1)      { ((float*)data)[0] = backup.BackupFloat[0]; }
        else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        g.StyleModifiers.pop_back();
        count--;
    }
}

const char* ImGui::GetStyleColorName(ImGuiCol idx)
{
    // Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
    switch (idx)
    {
    case ImGuiCol_Text: return "Text";
    case ImGuiCol_TextDisabled: return "TextDisabled";
    case ImGuiCol_WindowBg: return "WindowBg";
    case ImGuiCol_ChildBg: return "ChildBg";
    case ImGuiCol_PopupBg: return "PopupBg";
    case ImGuiCol_Border: return "Border";
    case ImGuiCol_BorderShadow: return "BorderShadow";
    case ImGuiCol_FrameBg: return "FrameBg";
    case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
    case ImGuiCol_FrameBgActive: return "FrameBgActive";
    case ImGuiCol_TitleBg: return "TitleBg";
    case ImGuiCol_TitleBgActive: return "TitleBgActive";
    case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
    case ImGuiCol_MenuBarBg: return "MenuBarBg";
    case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
    case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
    case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    case ImGuiCol_CheckMark: return "CheckMark";
    case ImGuiCol_SliderGrab: return "SliderGrab";
    case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
    case ImGuiCol_Button: return "Button";
    case ImGuiCol_ButtonHovered: return "ButtonHovered";
    case ImGuiCol_ButtonActive: return "ButtonActive";
    case ImGuiCol_Header: return "Header";
    case ImGuiCol_HeaderHovered: return "HeaderHovered";
    case ImGuiCol_HeaderActive: return "HeaderActive";
    case ImGuiCol_Separator: return "Separator";
    case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
    case ImGuiCol_SeparatorActive: return "SeparatorActive";
    case ImGuiCol_ResizeGrip: return "ResizeGrip";
    case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
    case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
    case ImGuiCol_PlotLines: return "PlotLines";
    case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
    case ImGuiCol_PlotHistogram: return "PlotHistogram";
    case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
    case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
    case ImGuiCol_DragDropTarget: return "DragDropTarget";
    case ImGuiCol_NavHighlight: return "NavHighlight";
    case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
    case ImGuiCol_NavWindowingDimBg: return "NavWindowingDimBg";
    case ImGuiCol_ModalWindowDimBg: return "ModalWindowDimBg";
    }
    IM_ASSERT(0);
    return "Unknown";
}

bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
{
    if (window->RootWindow == potential_parent)
        return true;
    while (window != NULL)
    {
        if (window == potential_parent)
            return true;
        window = window->ParentWindow;
    }
    return false;
}

bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
{
    IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
    ImGuiContext& g = *GImGui;

    if (flags & ImGuiHoveredFlags_AnyWindow)
    {
        if (g.HoveredWindow == NULL)
            return false;
    }
    else
    {
        switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))
        {
        case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_RootWindow:
            if (g.HoveredWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case ImGuiHoveredFlags_ChildWindows:
            if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))
                return false;
            break;
        default:
            if (g.HoveredWindow != g.CurrentWindow)
                return false;
            break;
        }
    }

    if (!IsWindowContentHoverable(g.HoveredRootWindow, flags))
        return false;
    if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)
            return false;
    return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()

    if (flags & ImGuiFocusedFlags_AnyWindow)
        return g.NavWindow != NULL;

    switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))
    {
    case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_RootWindow:
        return g.NavWindow == g.CurrentWindow->RootWindow;
    case ImGuiFocusedFlags_ChildWindows:
        return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);
    default:
        return g.NavWindow == g.CurrentWindow;
    }
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
{
    return window->Active && window == window->RootWindow && !(window->Flags & ImGuiWindowFlags_NoNavFocus);
}

float ImGui::GetWindowWidth()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.x;
}

float ImGui::GetWindowHeight()
{
    ImGuiWindow* window = GImGui->CurrentWindow;
    return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    return window->Pos;
}

void ImGui::SetWindowScrollX(ImGuiWindow* window, float new_scroll_x)
{
    window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.x = new_scroll_x;
    window->DC.CursorMaxPos.x -= window->Scroll.x;
}

void ImGui::SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)
{
    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.y = new_scroll_y;
    window->DC.CursorMaxPos.y -= window->Scroll.y;
}

static void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

    // Set
    const ImVec2 old_pos = window->Pos;
    window->Pos = ImFloor(pos);
    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.
}

void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Size;
}

static void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    if (size.x > 0.0f)
    {
        window->AutoFitFramesX = 0;
        window->SizeFull.x = size.x;
    }
    else
    {
        window->AutoFitFramesX = 2;
        window->AutoFitOnlyGrows = false;
    }
    if (size.y > 0.0f)
    {
        window->AutoFitFramesY = 0;
        window->SizeFull.y = size.y;
    }
    else
    {
        window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
}

void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
{
    SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowSize(window, size, cond);
}

static void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
        return;
    window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    window->Collapsed = collapsed;
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
{
    if (ImGuiWindow* window = FindWindowByName(name))
        SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus()
{
    FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char* name)
{
    if (name)
    {
        if (ImGuiWindow* window = FindWindowByName(name))
            FocusWindow(window);
    }
    else
    {
        FocusWindow(NULL);
    }
}

void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;
    g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

void ImGui::SetNextWindowContentSize(const ImVec2& size)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.
    g.NextWindowData.ContentSizeCond = ImGuiCond_Always;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

void ImGui::SetNextWindowBgAlpha(float alpha)
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.BgAlphaVal = alpha;
    g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

// In window space (not screen space!)
ImVec2 ImGui::GetContentRegionMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImVec2 mx = window->ContentsRegionRect.Max - window->Pos;
    if (window->DC.ColumnsSet)
        mx.x = GetColumnOffset(window->DC.ColumnsSet->Current + 1) - window->WindowPadding.x;
    return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);
}

float ImGui::GetContentRegionAvailWidth()
{
    return GetContentRegionAvail().x;
}

// In window space (not screen space!)
ImVec2 ImGui::GetWindowContentRegionMin()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Min - window->Pos;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Max - window->Pos;
}

float ImGui::GetWindowContentRegionWidth()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.GetWidth();
}

float ImGui::GetTextLineHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

ImDrawList* ImGui::GetWindowDrawList()
{
    ImGuiWindow* window = GetCurrentWindow();
    return window->DrawList;
}

ImFont* ImGui::GetFont()
{
    return GImGui->Font;
}

float ImGui::GetFontSize()
{
    return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
    return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->FontWindowScale = scale;
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2& local_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

void ImGui::SetCursorPosX(float x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
}

void ImGui::SetCursorPosY(float y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
}

ImVec2 ImGui::GetCursorStartPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorStartPos - window->Pos;
}

ImVec2 ImGui::GetCursorScreenPos()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.CursorPos = screen_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

float ImGui::GetScrollX()
{
    return GImGui->CurrentWindow->Scroll.x;
}

float ImGui::GetScrollY()
{
    return GImGui->CurrentWindow->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
    return GetScrollMaxX(GImGui->CurrentWindow);
}

float ImGui::GetScrollMaxY()
{
    return GetScrollMaxY(GImGui->CurrentWindow);
}

void ImGui::SetScrollX(float scroll_x)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.x = scroll_x;
    window->ScrollTargetCenterRatio.x = 0.0f;
}

void ImGui::SetScrollY(float scroll_y)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY
    window->ScrollTargetCenterRatio.y = 0.0f;
}

void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)
{
    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
    window->ScrollTarget.y = (float)(int)(pos_y + window->Scroll.y);
    window->ScrollTargetCenterRatio.y = center_y_ratio;
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHere(float center_y_ratio)
{
    ImGuiWindow* window = GetCurrentWindow();
    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space
    target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.
    SetScrollFromPosY(target_y, center_y_ratio);
}

void ImGui::ActivateItem(ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    g.NavNextActivateId = id;
}

void ImGui::SetKeyboardFocusHere(int offset)
{
    IM_ASSERT(offset >= -1);    // -1 is allowed but not below
    ImGuiWindow* window = GetCurrentWindow();
    window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;
    window->FocusIdxTabRequestNext = INT_MAX;
}

void ImGui::SetItemDefaultFocus()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (!window->Appearing)
        return;
    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)
    {
        g.NavInitRequest = false;
        g.NavInitResultId = g.NavWindow->DC.LastItemId;
        g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);
        NavUpdateAnyRequestFlag();
        if (!IsItemVisible())
            SetScrollHere();
    }
}

void ImGui::SetStateStorage(ImGuiStorage* tree)
{
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.StateStorage;
}

void ImGui::TextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    TextUnformatted(g.TempBuffer, text_end);
}

void ImGui::Text(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextV(fmt, args);
    va_end(args);
}

void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, col);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextColoredV(col, fmt, args);
    va_end(args);
}

void ImGui::TextDisabledV(const char* fmt, va_list args)
{
    PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);
    TextV(fmt, args);
    PopStyleColor();
}

void ImGui::TextDisabled(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextDisabledV(fmt, args);
    va_end(args);
}

void ImGui::TextWrappedV(const char* fmt, va_list args)
{
    bool need_wrap = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);    // Keep existing wrap position is one ia already set
    if (need_wrap) PushTextWrapPos(0.0f);
    TextV(fmt, args);
    if (need_wrap) PopTextWrapPos();
}

void ImGui::TextWrapped(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    TextWrappedV(fmt, args);
    va_end(args);
}

void ImGui::TextUnformatted(const char* text, const char* text_end)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    IM_ASSERT(text != NULL);
    const char* text_begin = text;
    if (text_end == NULL)
        text_end = text + strlen(text); // FIXME-OPT

    const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);
    const float wrap_pos_x = window->DC.TextWrapPos;
    const bool wrap_enabled = wrap_pos_x >= 0.0f;
    if (text_end - text > 2000 && !wrap_enabled)
    {
        // Long text!
        // Perform manual coarse clipping to optimize for long multi-line text
        // From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
        // We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
        const char* line = text;
        const float line_height = GetTextLineHeight();
        const ImRect clip_rect = window->ClipRect;
        ImVec2 text_size(0,0);

        if (text_pos.y <= clip_rect.Max.y)
        {
            ImVec2 pos = text_pos;

            // Lines to skip (can't skip when logging text)
            if (!g.LogEnabled)
            {
                int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);
                if (lines_skippable > 0)
                {
                    int lines_skipped = 0;
                    while (line < text_end && lines_skipped < lines_skippable)
                    {
                        const char* line_end = strchr(line, '\n');
                        if (!line_end)
                            line_end = text_end;
                        line = line_end + 1;
                        lines_skipped++;
                    }
                    pos.y += lines_skipped * line_height;
                }
            }

            // Lines to render
            if (line < text_end)
            {
                ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
                while (line < text_end)
                {
                    const char* line_end = strchr(line, '\n');
                    if (IsClippedEx(line_rect, 0, false))
                        break;

                    const ImVec2 line_size = CalcTextSize(line, line_end, false);
                    text_size.x = ImMax(text_size.x, line_size.x);
                    RenderText(pos, line, line_end, false);
                    if (!line_end)
                        line_end = text_end;
                    line = line_end + 1;
                    line_rect.Min.y += line_height;
                    line_rect.Max.y += line_height;
                    pos.y += line_height;
                }

                // Count remaining lines
                int lines_skipped = 0;
                while (line < text_end)
                {
                    const char* line_end = strchr(line, '\n');
                    if (!line_end)
                        line_end = text_end;
                    line = line_end + 1;
                    lines_skipped++;
                }
                pos.y += lines_skipped * line_height;
            }

            text_size.y += (pos - text_pos).y;
        }

        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(bb);
        ItemAdd(bb, 0);
    }
    else
    {
        const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
        const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

        // Account of baseline offset
        ImRect bb(text_pos, text_pos + text_size);
        ItemSize(text_size);
        if (!ItemAdd(bb, 0))
            return;

        // Render (we don't hide text after ## in this end-user function)
        RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
    }
}

void ImGui::AlignTextToFramePadding()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    window->DC.CurrentLineSize.y = ImMax(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y * 2);
    window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);
}

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2));
    const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y*2) + label_size);
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0))
        return;

    // Render
    const char* value_text_begin = &g.TempBuffer[0];
    const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f,0.5f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
}

void ImGui::LabelText(const char* label, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    LabelTextV(label, fmt, args);
    va_end(args);
}

bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    if (flags & ImGuiButtonFlags_Disabled)
    {
        if (out_hovered) *out_hovered = false;
        if (out_held) *out_held = false;
        if (g.ActiveId == id) ClearActiveID();
        return false;
    }

    // Default behavior requires click+release on same spot
    if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)
        flags |= ImGuiButtonFlags_PressedOnClickRelease;

    ImGuiWindow* backup_hovered_window = g.HoveredWindow;
    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = window;

    bool pressed = false;
    bool hovered = ItemHoverable(bb, id);

    // Drag source doesn't report as hovered
    if (hovered && g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoDisableHover))
        hovered = false;

    // Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
    if (g.DragDropActive && (flags & ImGuiButtonFlags_PressedOnDragDropHold) && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
        if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
        {
            hovered = true;
            SetHoveredID(id);
            if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy
            {
                pressed = true;
                FocusWindow(window);
            }
        }

    if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
        g.HoveredWindow = backup_hovered_window;

    // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
    if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
        hovered = false;

    // Mouse
    if (hovered)
    {
        if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
        {
            //                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat
            // PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds
            // PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..
            // PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)
            // PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..
            // FIXME-NAV: We don't honor those different behaviors.
            if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])
            {
                SetActiveID(id, window);
                if (!(flags & ImGuiButtonFlags_NoNavFocus))
                    SetFocusID(id, window);
                FocusWindow(window);
            }
            if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))
            {
                pressed = true;
                if (flags & ImGuiButtonFlags_NoHoldingActiveID)
                    ClearActiveID();
                else
                    SetActiveID(id, window); // Hold on ID
                FocusWindow(window);
            }
            if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])
            {
                if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
                    pressed = true;
                ClearActiveID();
            }

            // 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
            // Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
            if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))
                pressed = true;
        }

        if (pressed)
            g.NavDisableHighlight = true;
    }

    // Gamepad/Keyboard navigation
    // We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
    if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
        hovered = true;

    if (g.NavActivateDownId == id)
    {
        bool nav_activated_by_code = (g.NavActivateId == id);
        bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);
        if (nav_activated_by_code || nav_activated_by_inputs)
            pressed = true;
        if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)
        {
            // Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
            g.NavActivateId = id; // This is so SetActiveId assign a Nav source
            SetActiveID(id, window);
            if (!(flags & ImGuiButtonFlags_NoNavFocus))
                SetFocusID(id, window);
            g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        }
    }

    bool held = false;
    if (g.ActiveId == id)
    {
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (g.ActiveIdIsJustActivated)
                g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
            if (g.IO.MouseDown[0])
            {
                held = true;
            }
            else
            {
                if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))
                    if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
                        if (!g.DragDropActive)
                            pressed = true;
                ClearActiveID();
            }
            if (!(flags & ImGuiButtonFlags_NoNavFocus))
                g.NavDisableHighlight = true;
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            if (g.NavActivateDownId != id)
                ClearActiveID();
        }
    }

    if (out_hovered) *out_hovered = hovered;
    if (out_held) *out_held = held;

    return pressed;
}

bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImVec2 pos = window->DC.CursorPos;
    if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
        pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;
    ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

    const ImRect bb(pos, pos + size);
    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);
    if (pressed)
        MarkItemEdited(id);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding);
    RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);

    // Automatically close popups
    //if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
    //    CloseCurrentPopup();

    return pressed;
}

bool ImGui::Button(const char* label, const ImVec2& size_arg)
{
    return ButtonEx(label, size_arg, 0);
}

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton(const char* label)
{
    ImGuiContext& g = *GImGui;
    float backup_padding_y = g.Style.FramePadding.y;
    g.Style.FramePadding.y = 0.0f;
    bool pressed = ButtonEx(label, ImVec2(0,0), ImGuiButtonFlags_AlignTextBaseLine);
    g.Style.FramePadding.y = backup_padding_y;
    return pressed;
}

bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(str_id);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const float default_size = GetFrameHeight();
    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
        flags |= ImGuiButtonFlags_Repeat;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);
    RenderArrow(bb.Min + ImVec2(ImMax(0.0f, size.x - g.FontSize - g.Style.FramePadding.x), ImMax(0.0f, size.y - g.FontSize - g.Style.FramePadding.y)), dir);

    return pressed;
}

bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)
{
    float sz = GetFrameHeight();
    return ArrowButtonEx(str_id, dir, ImVec2(sz, sz), 0);
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    // Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
    IM_ASSERT(size_arg.x != 0.0f && size_arg.y != 0.0f);

    const ImGuiID id = window->GetID(str_id);
    ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    return pressed;
}

// Button to close a window
bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    // We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
    // (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
    const ImRect bb(pos - ImVec2(radius,radius), pos + ImVec2(radius,radius));
    bool is_clipped = !ItemAdd(bb, id);

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);
    if (is_clipped)
        return pressed;

    // Render
    ImVec2 center = bb.GetCenter();
    if (hovered)
        window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);

    float cross_extent = (radius * 0.7071f) - 1.0f;
    ImU32 cross_col = GetColorU32(ImGuiCol_Text);
    center -= ImVec2(0.5f, 0.5f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,+cross_extent), center + ImVec2(-cross_extent,-cross_extent), cross_col, 1.0f);
    window->DrawList->AddLine(center + ImVec2(+cross_extent,-cross_extent), center + ImVec2(-cross_extent,+cross_extent), cross_col, 1.0f);

    return pressed;
}

bool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    ImRect bb(pos, pos + ImVec2(g.FontSize, g.FontSize) + g.Style.FramePadding * 2.0f);
    ItemAdd(bb, id);
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_None);

    ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    if (hovered || held)
        window->DrawList->AddCircleFilled(bb.GetCenter() + ImVec2(0.0f, -0.5f), g.FontSize * 0.5f + 1.0f, col, 9);
    RenderArrow(bb.Min + g.Style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);

    // Switch to moving the window after mouse is moved beyond the initial drag threshold
    if (IsItemActive() && IsMouseDragging())
        StartMouseMovingWindow(window);

    return pressed;
}

void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    if (border_col.w > 0.0f)
        bb.Max += ImVec2(2,2);
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    if (border_col.w > 0.0f)
    {
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);
        window->DrawList->AddImage(user_texture_id, bb.Min+ImVec2(1,1), bb.Max-ImVec2(1,1), uv0, uv1, GetColorU32(tint_col));
    }
    else
    {
        window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));
    }
}

// frame_padding < 0: uses FramePadding from style (default)
// frame_padding = 0: no framing
// frame_padding > 0: set framing size
// The color used are the button colors.
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    // Default to using texture ID as ID. User can still push string/integer prefixes.
    // We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
    PushID((void*)user_texture_id);
    const ImGuiID id = window->GetID("#image");
    PopID();

    const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding*2);
    const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);
    ItemSize(bb);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
    RenderNavHighlight(bb, id);
    RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));
    if (bg_col.w > 0.0f)
        window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));
    window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

    return pressed;
}

// Start logging ImGui output to TTY
void ImGui::LogToTTY(int max_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = stdout;
    g.LogEnabled = true;
    g.LogStartDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

// Start logging ImGui output to given file
void ImGui::LogToFile(int max_depth, const char* filename)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    if (!filename)
    {
        filename = g.IO.LogFilename;
        if (!filename)
            return;
    }

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = ImFileOpen(filename, "ab");
    if (!g.LogFile)
    {
        IM_ASSERT(g.LogFile != NULL); // Consider this an error
        return;
    }
    g.LogEnabled = true;
    g.LogStartDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

// Start logging ImGui output to clipboard
void ImGui::LogToClipboard(int max_depth)
{
    ImGuiContext& g = *GImGui;
    if (g.LogEnabled)
        return;
    ImGuiWindow* window = g.CurrentWindow;

    IM_ASSERT(g.LogFile == NULL);
    g.LogFile = NULL;
    g.LogEnabled = true;
    g.LogStartDepth = window->DC.TreeDepth;
    if (max_depth >= 0)
        g.LogAutoExpandMaxDepth = max_depth;
}

void ImGui::LogFinish()
{
    ImGuiContext& g = *GImGui;
    if (!g.LogEnabled)
        return;

    LogText(IM_NEWLINE);
    if (g.LogFile != NULL)
    {
        if (g.LogFile == stdout)
            fflush(g.LogFile);
        else
            fclose(g.LogFile);
        g.LogFile = NULL;
    }
    if (g.LogClipboard.size() > 1)
    {
        SetClipboardText(g.LogClipboard.begin());
        g.LogClipboard.clear();
    }
    g.LogEnabled = false;
}

// Helper to display logging buttons
void ImGui::LogButtons()
{
    ImGuiContext& g = *GImGui;

    PushID("LogButtons");
    const bool log_to_tty = Button("Log To TTY"); SameLine();
    const bool log_to_file = Button("Log To File"); SameLine();
    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
    PushItemWidth(80.0f);
    PushAllowKeyboardFocus(false);
    SliderInt("Depth", &g.LogAutoExpandMaxDepth, 0, 9, NULL);
    PopAllowKeyboardFocus();
    PopItemWidth();
    PopID();

    // Start logging at the end of the function so that the buttons don't appear in the log
    if (log_to_tty)
        LogToTTY(g.LogAutoExpandMaxDepth);
    if (log_to_file)
        LogToFile(g.LogAutoExpandMaxDepth, g.IO.LogFilename);
    if (log_to_clipboard)
        LogToClipboard(g.LogAutoExpandMaxDepth);
}

bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)
{
    if (flags & ImGuiTreeNodeFlags_Leaf)
        return true;

    // We only write to the tree storage if the user clicks (or explicitly use SetNextTreeNode*** functions)
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiStorage* storage = window->DC.StateStorage;

    bool is_open;
    if (g.NextTreeNodeOpenCond != 0)
    {
        if (g.NextTreeNodeOpenCond & ImGuiCond_Always)
        {
            is_open = g.NextTreeNodeOpenVal;
            storage->SetInt(id, is_open);
        }
        else
        {
            // We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
            const int stored_value = storage->GetInt(id, -1);
            if (stored_value == -1)
            {
                is_open = g.NextTreeNodeOpenVal;
                storage->SetInt(id, is_open);
            }
            else
            {
                is_open = stored_value != 0;
            }
        }
        g.NextTreeNodeOpenCond = 0;
    }
    else
    {
        is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
    }

    // When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
    // NB- If we are above max depth we still allow manually opened nodes to be logged.
    if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)
        is_open = true;

    return is_open;
}

bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;
    const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

    if (!label_end)
        label_end = FindRenderedTextEnd(label);
    const ImVec2 label_size = CalcTextSize(label, label_end, false);

    // We vertically grow up to current line height up the typical widget height.
    const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float frame_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + style.FramePadding.y*2), label_size.y + padding.y*2);
    ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));
    if (display_frame)
    {
        // Framed header expand a little outside the default padding
        frame_bb.Min.x -= (float)(int)(window->WindowPadding.x*0.5f) - 1;
        frame_bb.Max.x += (float)(int)(window->WindowPadding.x*0.5f) - 1;
    }

    const float text_offset_x = (g.FontSize + (display_frame ? padding.x*3 : padding.x*2));   // Collapser arrow width + Spacing
    const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x*2 : 0.0f);   // Include collapser
    ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

    // For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
    // (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)
    const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x*2, frame_bb.Max.y);
    bool is_open = TreeNodeBehaviorIsOpen(id, flags);

    // Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
    // For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
    // This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
    if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        window->DC.TreeDepthMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);

    bool item_add = ItemAdd(interact_bb, id);
    window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
    window->DC.LastItemDisplayRect = frame_bb;

    if (!item_add)
    {
        if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
            TreePushRawID(id);
        return is_open;
    }

    // Flags that affects opening behavior:
    // - 0(default) ..................... single-click anywhere to open
    // - OpenOnDoubleClick .............. double-click anywhere to open
    // - OpenOnArrow .................... single-click on arrow to open
    // - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
    ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers | ((flags & ImGuiTreeNodeFlags_AllowItemOverlap) ? ImGuiButtonFlags_AllowItemOverlap : 0);
    if (!(flags & ImGuiTreeNodeFlags_Leaf))
        button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
    if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
        button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);

    bool hovered, held, pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
    if (!(flags & ImGuiTreeNodeFlags_Leaf))
    {
        bool toggled = false;
        if (pressed)
        {
            toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);
            if (flags & ImGuiTreeNodeFlags_OpenOnArrow)
                toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);
            if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
                toggled |= g.IO.MouseDoubleClicked[0];
            if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
                toggled = false;
        }

        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)
        {
            toggled = true;
            NavMoveRequestCancel();
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?
        {
            toggled = true;
            NavMoveRequestCancel();
        }

        if (toggled)
        {
            is_open = !is_open;
            window->DC.StateStorage->SetInt(id, is_open);
        }
    }
    if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)
        SetItemAllowOverlap();

    // Render
    const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
    const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);
    if (display_frame)
    {
        // Framed type
        RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);
        RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);
        RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);
        if (g.LogEnabled)
        {
            // NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
            const char log_prefix[] = "\n##";
            const char log_suffix[] = "##";
            LogRenderedText(&text_pos, log_prefix, log_prefix+3);
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
            LogRenderedText(&text_pos, log_suffix+1, log_suffix+3);
        }
        else
        {
            RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
        }
    }
    else
    {
        // Unframed typed for tree nodes
        if (hovered || (flags & ImGuiTreeNodeFlags_Selected))
        {
            RenderFrame(frame_bb.Min, frame_bb.Max, col, false);
            RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);
        }

        if (flags & ImGuiTreeNodeFlags_Bullet)
            RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize*0.50f + text_base_offset_y));
        else if (!(flags & ImGuiTreeNodeFlags_Leaf))
            RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize*0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);
        if (g.LogEnabled)
            LogRenderedText(&text_pos, ">");
        RenderText(text_pos, label, label_end, false);
    }

    if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
        TreePushRawID(id);
    return is_open;
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader, label);
}

bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (p_open && !*p_open)
        return false;

    ImGuiID id = window->GetID(label);
    bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);
    if (p_open)
    {
        // Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
        ImGuiContext& g = *GImGui;
        ImGuiItemHoveredDataBackup last_item_backup;
        float button_radius = g.FontSize * 0.5f;
        ImVec2 button_center = ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_radius, window->DC.LastItemRect.GetCenter().y);
        if (CloseButton(window->GetID((void*)(intptr_t)(id+1)), button_center, button_radius))
            *p_open = false;
        last_item_backup.Restore();
    }

    return is_open;
}

bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    return TreeNodeBehavior(window->GetID(label), flags, label, NULL);
}

bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
{
    return TreeNodeExV(str_id, 0, fmt, args);
}

bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
{
    return TreeNodeExV(ptr_id, 0, fmt, args);
}

bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(str_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
    va_end(args);
    return is_open;
}

bool ImGui::TreeNode(const char* label)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    return TreeNodeBehavior(window->GetID(label), 0, label, NULL);
}

void ImGui::TreeAdvanceToLabelPos()
{
    ImGuiContext& g = *GImGui;
    g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing()
{
    ImGuiContext& g = *GImGui;
    return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}

void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow->SkipItems)
        return;
    g.NextTreeNodeOpenVal = is_open;
    g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::PushID(const char* str_id)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));
}

void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));
}

void ImGui::PushID(const void* ptr_id)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void ImGui::PushID(int int_id)
{
    const void* ptr_id = (void*)(intptr_t)int_id;
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void ImGui::PopID()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char* str_id)
{
    return GImGui->CurrentWindow->GetID(str_id);
}

ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
{
    return GImGui->CurrentWindow->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void* ptr_id)
{
    return GImGui->CurrentWindow->GetID(ptr_id);
}

void ImGui::Bullet()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
    {
        SameLine(0, style.FramePadding.x*2);
        return;
    }

    // Render and stay on same line
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    SameLine(0, style.FramePadding.x*2);
}

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV(const char* fmt, va_list args)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const char* text_begin = g.TempBuffer;
    const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
    const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
    const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
    const float line_height = ImMax(ImMin(window->DC.CurrentLineSize.y, g.FontSize + g.Style.FramePadding.y*2), g.FontSize);
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x*2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding
    ItemSize(bb);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize*0.5f, line_height*0.5f));
    RenderText(bb.Min+ImVec2(g.FontSize + style.FramePadding.x*2, text_base_offset_y), text_begin, text_end, false);
}

void ImGui::BulletText(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    BulletTextV(fmt, args);
    va_end(args);
}

static inline int DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format)
{
    if (data_type == ImGuiDataType_S32 || data_type == ImGuiDataType_U32)   // Signedness doesn't matter when pushing the argument
        return ImFormatString(buf, buf_size, format, *(const ImU32*)data_ptr);
    if (data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)   // Signedness doesn't matter when pushing the argument
        return ImFormatString(buf, buf_size, format, *(const ImU64*)data_ptr);
    if (data_type == ImGuiDataType_Float)
        return ImFormatString(buf, buf_size, format, *(const float*)data_ptr);
    if (data_type == ImGuiDataType_Double)
        return ImFormatString(buf, buf_size, format, *(const double*)data_ptr);
    IM_ASSERT(0);
    return 0;
}

// FIXME: Adding support for clamping on boundaries of the data type would be nice.
static void DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)
{
    IM_ASSERT(op == '+' || op == '-');
    switch (data_type)
    {
        case ImGuiDataType_S32:
            if (op == '+')      *(int*)output = *(const int*)arg1 + *(const int*)arg2;
            else if (op == '-') *(int*)output = *(const int*)arg1 - *(const int*)arg2;
            return;
        case ImGuiDataType_U32:
            if (op == '+')      *(unsigned int*)output = *(const unsigned int*)arg1 + *(const ImU32*)arg2;
            else if (op == '-') *(unsigned int*)output = *(const unsigned int*)arg1 - *(const ImU32*)arg2;
            return;
        case ImGuiDataType_S64:
            if (op == '+')      *(ImS64*)output = *(const ImS64*)arg1 + *(const ImS64*)arg2;
            else if (op == '-') *(ImS64*)output = *(const ImS64*)arg1 - *(const ImS64*)arg2;
            return;
        case ImGuiDataType_U64:
            if (op == '+')      *(ImU64*)output = *(const ImU64*)arg1 + *(const ImU64*)arg2;
            else if (op == '-') *(ImU64*)output = *(const ImU64*)arg1 - *(const ImU64*)arg2;
            return;
        case ImGuiDataType_Float:
            if (op == '+')      *(float*)output = *(const float*)arg1 + *(const float*)arg2;
            else if (op == '-') *(float*)output = *(const float*)arg1 - *(const float*)arg2;
            return;
        case ImGuiDataType_Double:
            if (op == '+')      *(double*)output = *(const double*)arg1 + *(const double*)arg2;
            else if (op == '-') *(double*)output = *(const double*)arg1 - *(const double*)arg2;
            return;
        case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
}

struct ImGuiDataTypeInfo
{
    size_t      Size;
    const char* PrintFmt;   // Unused
    const char* ScanFmt;
};

static const ImGuiDataTypeInfo GDataTypeInfo[] =
{
    { sizeof(int),          "%d",   "%d"    },
    { sizeof(unsigned int), "%u",   "%u"    },
#ifdef _MSC_VER
    { sizeof(ImS64),        "%I64d","%I64d" },
    { sizeof(ImU64),        "%I64u","%I64u" },
#else
    { sizeof(ImS64),        "%lld", "%lld"  },
    { sizeof(ImU64),        "%llu", "%llu"  },
#endif
    { sizeof(float),        "%f",   "%f"    },  // float are promoted to double in va_arg
    { sizeof(double),       "%f",   "%lf"   },
};
IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
static bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    while (ImCharIsBlankA(*buf))
        buf++;

    // We don't support '-' op because it would conflict with inputing negative value.
    // Instead you can use +-100 to subtract from an existing value
    char op = buf[0];
    if (op == '+' || op == '*' || op == '/')
    {
        buf++;
        while (ImCharIsBlankA(*buf))
            buf++;
    }
    else
    {
        op = 0;
    }
    if (!buf[0])
        return false;

    // Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
    IM_ASSERT(data_type < ImGuiDataType_COUNT);
    int data_backup[2];
    IM_ASSERT(GDataTypeInfo[data_type].Size <= sizeof(data_backup));
    memcpy(data_backup, data_ptr, GDataTypeInfo[data_type].Size);

    if (format == NULL)
        format = GDataTypeInfo[data_type].ScanFmt;

    int arg1i = 0;
    if (data_type == ImGuiDataType_S32)
    {
        int* v = (int*)data_ptr;
        int arg0i = *v;
        float arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0i) < 1)
            return false;
        // Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
        if (op == '+')      { if (sscanf(buf, "%d", &arg1i)) *v = (int)(arg0i + arg1i); }                   // Add (use "+-" to subtract)
        else if (op == '*') { if (sscanf(buf, "%f", &arg1f)) *v = (int)(arg0i * arg1f); }                   // Multiply
        else if (op == '/') { if (sscanf(buf, "%f", &arg1f) && arg1f != 0.0f) *v = (int)(arg0i / arg1f); }  // Divide
        else                { if (sscanf(buf, format, &arg1i) == 1) *v = arg1i; }                           // Assign constant
    }
    else if (data_type == ImGuiDataType_U32 || data_type == ImGuiDataType_S64 || data_type == ImGuiDataType_U64)
    {
        // Assign constant
        // FIXME: We don't bother handling support for legacy operators since they are a little too crappy. Instead we may implement a proper expression evaluator in the future.
        sscanf(buf, format, data_ptr);
    }
    else if (data_type == ImGuiDataType_Float)
    {
        // For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
        format = "%f";
        float* v = (float*)data_ptr;
        float arg0f = *v, arg1f = 0.0f;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    else if (data_type == ImGuiDataType_Double)
    {
        format = "%lf"; // scanf differentiate float/double unlike printf which forces everything to double because of ellipsis
        double* v = (double*)data_ptr;
        double arg0f = *v, arg1f = 0.0;
        if (op && sscanf(initial_value_buf, format, &arg0f) < 1)
            return false;
        if (sscanf(buf, format, &arg1f) < 1)
            return false;
        if (op == '+')      { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
        else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
        else if (op == '/') { if (arg1f != 0.0f) *v = arg0f / arg1f; } // Divide
        else                { *v = arg1f; }                            // Assign constant
    }
    return memcmp(data_backup, data_ptr, GDataTypeInfo[data_type].Size) != 0;
}

// Create text input in place of a slider (when CTRL+Clicking on slider)
// FIXME: Logic is messy and confusing.
bool ImGui::InputScalarAsWidgetReplacement(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    // Our replacement widget will override the focus ID (registered previously to allow for a TAB focus to happen)
    // On the first frame, g.ScalarAsInputTextId == 0, then on subsequent frames it becomes == id
    SetActiveID(g.ScalarAsInputTextId, window);
    g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
    SetHoveredID(0);
    FocusableItemUnregister(window);

    char fmt_buf[32];
    char data_buf[32];
    format = ImParseFormatTrimDecorations(format, fmt_buf, IM_ARRAYSIZE(fmt_buf));
    DataTypeFormatString(data_buf, IM_ARRAYSIZE(data_buf), data_type, data_ptr, format);
    ImStrTrimBlanks(data_buf);
    ImGuiInputTextFlags flags = ImGuiInputTextFlags_AutoSelectAll | ((data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImGuiInputTextFlags_CharsScientific : ImGuiInputTextFlags_CharsDecimal);
    bool value_changed = InputTextEx(label, data_buf, IM_ARRAYSIZE(data_buf), bb.GetSize(), flags);
    if (g.ScalarAsInputTextId == 0)     // First frame we started displaying the InputText widget
    {
        IM_ASSERT(g.ActiveId == id);    // InputText ID expected to match the Slider ID
        g.ScalarAsInputTextId = g.ActiveId;
        SetHoveredID(id);
    }
    if (value_changed)
        return DataTypeApplyOpFromText(data_buf, g.InputTextState.InitialText.Data, data_type, data_ptr, NULL);
    return false;
}

// We don't use strchr() because our strings are usually very short and often start with '%'
const char* ImParseFormatFindStart(const char* fmt)
{
    while (char c = fmt[0])
    {
        if (c == '%' && fmt[1] != '%')
            return fmt;
        else if (c == '%')
            fmt++;
        fmt++;
    }
    return fmt;
}

const char* ImParseFormatFindEnd(const char* fmt)
{
    // Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
    if (fmt[0] != '%')
        return fmt;
    const unsigned int ignored_uppercase_mask = (1 << ('I'-'A')) | (1 << ('L'-'A'));
    const unsigned int ignored_lowercase_mask = (1 << ('h'-'a')) | (1 << ('j'-'a')) | (1 << ('l'-'a')) | (1 << ('t'-'a')) | (1 << ('w'-'a')) | (1 << ('z'-'a'));
    for (char c; (c = *fmt) != 0; fmt++)
    {
        if (c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0)
            return fmt + 1;
        if (c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0)
            return fmt + 1;
    }
    return fmt;
}

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -> return fmt
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, int buf_size)
{
    const char* fmt_start = ImParseFormatFindStart(fmt);
    if (fmt_start[0] != '%')
        return fmt;
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);
    if (fmt_end[0] == 0) // If we only have leading decoration, we don't need to copy the data.
        return fmt_start;
    ImStrncpy(buf, fmt_start, ImMin((int)(fmt_end + 1 - fmt_start), buf_size));
    return buf;
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
int ImParseFormatPrecision(const char* fmt, int default_precision)
{
    fmt = ImParseFormatFindStart(fmt);
    if (fmt[0] != '%')
        return default_precision;
    fmt++;
    while (*fmt >= '0' && *fmt <= '9')
        fmt++;
    int precision = INT_MAX;
    if (*fmt == '.')
    {
        fmt = ImAtoi<int>(fmt + 1, &precision);
        if (precision < 0 || precision > 99)
            precision = default_precision;
    }
    if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
        precision = -1;
    if ((*fmt == 'g' || *fmt == 'G') && precision == INT_MAX)
        precision = -1;
    return (precision == INT_MAX) ? default_precision : precision;
}

static float GetMinimumStepAtDecimalPrecision(int decimal_precision)
{
    static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
    if (decimal_precision < 0)
        return FLT_MIN;
    return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : ImPow(10.0f, (float)-decimal_precision);
}

template<typename TYPE, typename SIGNEDTYPE>
static inline TYPE RoundScalarWithFormat(const char* format, ImGuiDataType data_type, TYPE v)
{
    const char* fmt_start = ImParseFormatFindStart(format);
    if (fmt_start[0] != '%' || fmt_start[1] == '%') // Don't apply if the value is not visible in the format string
        return v;
    char v_str[64];
    ImFormatString(v_str, IM_ARRAYSIZE(v_str), fmt_start, v);
    const char* p = v_str;
    while (*p == ' ')
        p++;
    if (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double)
        v = (TYPE)ImAtof(p);
    else
        ImAtoi(p, (SIGNEDTYPE*)&v);
    return v;
}

template<typename TYPE, typename FLOATTYPE>
static inline float SliderBehaviorCalcRatioFromValue(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos)
{
    if (v_min == v_max)
        return 0.0f;

    const bool is_power = (power != 1.0f) && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double);
    const TYPE v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
    if (is_power)
    {
        if (v_clamped < 0.0f)
        {
            const float f = 1.0f - (float)((v_clamped - v_min) / (ImMin((TYPE)0, v_max) - v_min));
            return (1.0f - ImPow(f, 1.0f/power)) * linear_zero_pos;
        }
        else
        {
            const float f = (float)((v_clamped - ImMax((TYPE)0, v_min)) / (v_max - ImMax((TYPE)0, v_min)));
            return linear_zero_pos + ImPow(f, 1.0f/power) * (1.0f - linear_zero_pos);
        }
    }

    // Linear slider
    return (float)((FLOATTYPE)(v_clamped - v_min) / (FLOATTYPE)(v_max - v_min));
}

// FIXME: Move some of the code into SliderBehavior(). Current responsability is larger than what the equivalent DragBehaviorT<> does, we also do some rendering, etc.
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
static bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const bool is_horizontal = (flags & ImGuiSliderFlags_Vertical) == 0;
    const bool is_decimal = (data_type == ImGuiDataType_Float) || (data_type == ImGuiDataType_Double);
    const bool is_power = (power != 1.0f) && is_decimal;

    const float grab_padding = 2.0f;
    const float slider_sz = is_horizontal ? (bb.GetWidth() - grab_padding * 2.0f) : (bb.GetHeight() - grab_padding * 2.0f);
    float grab_sz = style.GrabMinSize;
    SIGNEDTYPE v_range = (v_min < v_max ? v_max - v_min : v_min - v_max);
    if (!is_decimal && v_range >= 0)                                             // v_range < 0 may happen on integer overflows
        grab_sz = ImMax((float)(slider_sz / (v_range + 1)), style.GrabMinSize);  // For integer sliders: if possible have the grab size represent 1 unit
    grab_sz = ImMin(grab_sz, slider_sz);
    const float slider_usable_sz = slider_sz - grab_sz;
    const float slider_usable_pos_min = (is_horizontal ? bb.Min.x : bb.Min.y) + grab_padding + grab_sz*0.5f;
    const float slider_usable_pos_max = (is_horizontal ? bb.Max.x : bb.Max.y) - grab_padding - grab_sz*0.5f;

    // For power curve sliders that cross over sign boundary we want the curve to be symmetric around 0.0f
    float linear_zero_pos;   // 0.0->1.0f
    if (is_power && v_min * v_max < 0.0f)
    {
        // Different sign
        const FLOATTYPE linear_dist_min_to_0 = ImPow(v_min >= 0 ? (FLOATTYPE)v_min : -(FLOATTYPE)v_min, (FLOATTYPE)1.0f/power);
        const FLOATTYPE linear_dist_max_to_0 = ImPow(v_max >= 0 ? (FLOATTYPE)v_max : -(FLOATTYPE)v_max, (FLOATTYPE)1.0f/power);
        linear_zero_pos = (float)(linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0));
    }
    else
    {
        // Same sign
        linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;
    }

    // Process interacting with the slider
    bool value_changed = false;
    if (g.ActiveId == id)
    {
        bool set_new_value = false;
        float clicked_t = 0.0f;
        if (g.ActiveIdSource == ImGuiInputSource_Mouse)
        {
            if (!g.IO.MouseDown[0])
            {
                ClearActiveID();
            }
            else
            {
                const float mouse_abs_pos = is_horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
                clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;
                if (!is_horizontal)
                    clicked_t = 1.0f - clicked_t;
                set_new_value = true;
            }
        }
        else if (g.ActiveIdSource == ImGuiInputSource_Nav)
        {
            const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);
            float delta = is_horizontal ? delta2.x : -delta2.y;
            if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            {
                ClearActiveID();
            }
            else if (delta != 0.0f)
            {
                clicked_t = SliderBehaviorCalcRatioFromValue<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
                const int decimal_precision = is_decimal ? ImParseFormatPrecision(format, 3) : 0;
                if ((decimal_precision > 0) || is_power)
                {
                    delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds
                    if (IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta /= 10.0f;
                }
                else
                {
                    if ((v_range >= -100.0f && v_range <= 100.0f) || IsNavInputDown(ImGuiNavInput_TweakSlow))
                        delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (float)v_range; // Gamepad/keyboard tweak speeds in integer steps
                    else
                        delta /= 100.0f;
                }
                if (IsNavInputDown(ImGuiNavInput_TweakFast))
                    delta *= 10.0f;
                set_new_value = true;
                if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
                    set_new_value = false;
                else
                    clicked_t = ImSaturate(clicked_t + delta);
            }
        }

        if (set_new_value)
        {
            TYPE v_new;
            if (is_power)
            {
                // Account for power curve scale on both sides of the zero
                if (clicked_t < linear_zero_pos)
                {
                    // Negative: rescale to the negative range before powering
                    float a = 1.0f - (clicked_t / linear_zero_pos);
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMin(v_max, (TYPE)0), v_min, a);
                }
                else
                {
                    // Positive: rescale to the positive range before powering
                    float a;
                    if (ImFabs(linear_zero_pos - 1.0f) > 1.e-6f)
                        a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);
                    else
                        a = clicked_t;
                    a = ImPow(a, power);
                    v_new = ImLerp(ImMax(v_min, (TYPE)0), v_max, a);
                }
            }
            else
            {
                // Linear slider
                if (is_decimal)
                {
                    v_new = ImLerp(v_min, v_max, clicked_t);
                }
                else
                {
                    // For integer values we want the clicking position to match the grab box so we round above
                    // This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
                    FLOATTYPE v_new_off_f = (v_max - v_min) * clicked_t;
                    TYPE v_new_off_floor = (TYPE)(v_new_off_f);
                    TYPE v_new_off_round = (TYPE)(v_new_off_f + (FLOATTYPE)0.5);
                    if (!is_decimal && v_new_off_floor < v_new_off_round)
                        v_new = v_min + v_new_off_round;
                    else
                        v_new = v_min + v_new_off_floor;
                }
            }

            // Round to user desired precision based on format string
            v_new = RoundScalarWithFormat<TYPE,SIGNEDTYPE>(format, data_type, v_new);

            // Apply result
            if (*v != v_new)
            {
                *v = v_new;
                value_changed = true;
            }
        }
    }

    // Output grab position so it can be displayed by the caller
    float grab_t = SliderBehaviorCalcRatioFromValue<TYPE,FLOATTYPE>(data_type, *v, v_min, v_max, power, linear_zero_pos);
    if (!is_horizontal)
        grab_t = 1.0f - grab_t;
    const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
    if (is_horizontal)
        *out_grab_bb = ImRect(grab_pos - grab_sz*0.5f, bb.Min.y + grab_padding, grab_pos + grab_sz*0.5f, bb.Max.y - grab_padding);
    else
        *out_grab_bb = ImRect(bb.Min.x + grab_padding, grab_pos - grab_sz*0.5f, bb.Max.x - grab_padding, grab_pos + grab_sz*0.5f);

    return value_changed;
}

// For 32-bits and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
bool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)
{
    switch (data_type)
    {
    case ImGuiDataType_S32:
        IM_ASSERT(*(const ImS32*)v_min >= IM_S32_MIN/2 && *(const ImS32*)v_max <= IM_S32_MAX/2);
        return SliderBehaviorT<ImS32, ImS32, float >(bb, id, data_type, (ImS32*)v,  *(const ImS32*)v_min,  *(const ImS32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U32:
        IM_ASSERT(*(const ImU32*)v_min <= IM_U32_MAX/2);
        return SliderBehaviorT<ImU32, ImS32, float >(bb, id, data_type, (ImU32*)v,  *(const ImU32*)v_min,  *(const ImU32*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_S64:
        IM_ASSERT(*(const ImS64*)v_min >= IM_S64_MIN/2 && *(const ImS64*)v_max <= IM_S64_MAX/2);
        return SliderBehaviorT<ImS64, ImS64, double>(bb, id, data_type, (ImS64*)v,  *(const ImS64*)v_min,  *(const ImS64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_U64:
        IM_ASSERT(*(const ImU64*)v_min <= IM_U64_MAX/2);
        return SliderBehaviorT<ImU64, ImS64, double>(bb, id, data_type, (ImU64*)v,  *(const ImU64*)v_min,  *(const ImU64*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Float:
        IM_ASSERT(*(const float*)v_min >= -FLT_MAX/2.0f && *(const float*)v_max <= FLT_MAX/2.0f);
        return SliderBehaviorT<float, float, float >(bb, id, data_type, (float*)v,  *(const float*)v_min,  *(const float*)v_max,  format, power, flags, out_grab_bb);
    case ImGuiDataType_Double:
        IM_ASSERT(*(const double*)v_min >= -DBL_MAX/2.0f && *(const double*)v_max <= DBL_MAX/2.0f);
        return SliderBehaviorT<double,double,double>(bb, id, data_type, (double*)v, *(const double*)v_min, *(const double*)v_max, format, power, flags, out_grab_bb);
    case ImGuiDataType_COUNT: break;
    }
    IM_ASSERT(0);
    return false;
}

// FIXME-LEGACY: Prior to 1.61 our DragInt() function internally used floats and because of this the compile-time default value for format was "%.0f".
// Even though we changed the compile-time default, we expect users to have carried %f around, which would break the display of DragInt() calls.
// To honor backward compatibility we are rewriting the format string, unless IMGUI_DISABLE_OBSOLETE_FUNCTIONS is enabled. What could possibly go wrong?!
static const char* PatchFormatStringFloatToInt(const char* fmt)
{
    if (fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '0' && fmt[3] == 'f' && fmt[4] == 0) // Fast legacy path for "%.0f" which is expected to be the most common case.
        return "%d";
    const char* fmt_start = ImParseFormatFindStart(fmt);    // Find % (if any, and ignore %%)
    const char* fmt_end = ImParseFormatFindEnd(fmt_start);  // Find end of format specifier, which itself is an exercise of confidence/recklessness (because snprintf is dependent on libc or user).
    if (fmt_end > fmt_start && fmt_end[-1] == 'f')
    {
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
        if (fmt_start == fmt && fmt_end[0] == 0)
            return "%d";
        ImGuiContext& g = *GImGui;
        ImFormatString(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), XorString("%.*s%%d%s"), (int)(fmt_start - fmt), fmt, fmt_end); // Honor leading and trailing decorations, but lose alignment/precision.
        return g.TempBuffer;
#else
        IM_ASSERT(0 && "DragInt(): Invalid format string!"); // Old versions used a default parameter of "%.0f", please replace with e.g. "%d"
#endif
    }
    return fmt;
}

bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    // NB- we don't call ItemSize() yet because we may turn into a text edit box below
    if (!ItemAdd(total_bb, id, &frame_bb))
    {
        ItemSize(total_bb, style.FramePadding.y);
        return false;
    }

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Slider turns it into an input box
    bool start_text_input = false;
    const bool tab_focus_requested = FocusableItemRegister(window, id);
    const bool hovered = ItemHoverable(frame_bb, id);
    if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)
        {
            start_text_input = true;
            g.ScalarAsInputTextId = 0;
        }
    }
    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);

    ItemSize(total_bb, style.FramePadding.y);

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_None, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    return value_changed;
}

bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)
{
    return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(frame_bb, id))
        return false;

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    const bool hovered = ItemHoverable(frame_bb, id);
    if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
    }


    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding);

    // Slider behavior
    ImRect grab_bb;
    const bool value_changed = SliderBehavior(frame_bb, id, data_type, v, v_min, v_max, format, power, ImGuiSliderFlags_Vertical, &grab_bb);
    if (value_changed)
        MarkItemEdited(id);

    // Render grab
    window->DrawList->AddRectFilled(grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab), style.GrabRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    // For the vertical slider we allow centered text to overlap the frame padding
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f,0.0f));
    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    return value_changed;
}

bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
{
    float v_deg = (*v_rad) * 360.0f / (2*IM_PI);
    bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, "%.0f deg", 1.0f);
    *v_rad = v_deg * (2*IM_PI) / 360.0f;
    return value_changed;
}

bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)
{
    return SliderScalar(label, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power)
{
    return VSliderScalar(label, size, ImGuiDataType_Float, v, &v_min, &v_max, format, power);
}

bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format)
{
    return VSliderScalar(label, size, ImGuiDataType_S32, v, &v_min, &v_max, format);
}

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= SliderScalar("##v", data_type, v, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power);
}

bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)
{
    return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power);
}

bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 2, &v_min, &v_max, format);
}

bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 3, &v_min, &v_max, format);
}

bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format)
{
    return SliderScalarN(label, ImGuiDataType_S32, v, 4, &v_min, &v_max, format);
}

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
template<typename TYPE, typename SIGNEDTYPE, typename FLOATTYPE>
static bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power)
{
    ImGuiContext& g = *GImGui;

    // Default tweak speed
    bool has_min_max = (v_min != v_max) && (v_max - v_max < FLT_MAX);
    if (v_speed == 0.0f && has_min_max)
        v_speed = (float)((v_max - v_min) * g.DragSpeedDefaultRatio);

    // Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
    float adjust_delta = 0.0f;
    if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid() && g.IO.MouseDragMaxDistanceSqr[0] > 1.0f*1.0f)
    {
        adjust_delta = g.IO.MouseDelta.x;
        if (g.IO.KeyAlt)
            adjust_delta *= 1.0f/100.0f;
        if (g.IO.KeyShift)
            adjust_delta *= 10.0f;
    }
    else if (g.ActiveIdSource == ImGuiInputSource_Nav)
    {
        int decimal_precision = (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) ? ImParseFormatPrecision(format, 3) : 0;
        adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard|ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f/10.0f, 10.0f).x;
        v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
    }
    adjust_delta *= v_speed;

    // Clear current value on activation
    // Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
    bool is_just_activated = g.ActiveIdIsJustActivated;
    bool is_already_past_limits_and_pushing_outward = has_min_max && ((*v >= v_max && adjust_delta > 0.0f) || (*v <= v_min && adjust_delta < 0.0f));
    if (is_just_activated || is_already_past_limits_and_pushing_outward)
    {
        g.DragCurrentAccum = 0.0f;
        g.DragCurrentAccumDirty = false;
    }
    else if (adjust_delta != 0.0f)
    {
        g.DragCurrentAccum += adjust_delta;
        g.DragCurrentAccumDirty = true;
    }

    if (!g.DragCurrentAccumDirty)
        return false;

    TYPE v_cur = *v;
    FLOATTYPE v_old_ref_for_accum_remainder = (FLOATTYPE)0.0f;

    const bool is_power = (power != 1.0f && (data_type == ImGuiDataType_Float || data_type == ImGuiDataType_Double) && has_min_max);
    if (is_power)
    {
        // Offset + round to user desired precision, with a curve on the v_min..v_max range to get more precision on one side of the range
        FLOATTYPE v_old_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        FLOATTYPE v_new_norm_curved = v_old_norm_curved + (g.DragCurrentAccum / (v_max - v_min));
        v_cur = v_min + (TYPE)ImPow(ImSaturate((float)v_new_norm_curved), power) * (v_max - v_min);
        v_old_ref_for_accum_remainder = v_old_norm_curved;
    }
    else
    {
        v_cur += (TYPE)g.DragCurrentAccum;
    }

    // Round to user desired precision based on format string
    v_cur = RoundScalarWithFormat<TYPE, SIGNEDTYPE>(format, data_type, v_cur);

    // Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
    g.DragCurrentAccumDirty = false;
    if (is_power)
    {
        FLOATTYPE v_cur_norm_curved = ImPow((FLOATTYPE)(v_cur - v_min) / (FLOATTYPE)(v_max - v_min), (FLOATTYPE)1.0f / power);
        g.DragCurrentAccum -= (float)(v_cur_norm_curved - v_old_ref_for_accum_remainder);
    }
    else
    {
        g.DragCurrentAccum -= (float)((SIGNEDTYPE)v_cur - (SIGNEDTYPE)*v);
    }

    // Lose zero sign for float/double
    if (v_cur == (TYPE)-0)
        v_cur = (TYPE)0;

    // Clamp values (handle overflow/wrap-around)
    if (*v != v_cur && has_min_max)
    {
        if (v_cur < v_min || (v_cur > *v && adjust_delta < 0.0f))
            v_cur = v_min;
        if (v_cur > v_max || (v_cur < *v && adjust_delta > 0.0f))
            v_cur = v_max;
    }

    // Apply result
    if (*v == v_cur)
        return false;
    *v = v_cur;
    return true;
}

bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiContext& g = *GImGui;
    if (g.ActiveId == id)
    {
        if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])
            ClearActiveID();
        else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
            ClearActiveID();
    }
    if (g.ActiveId != id)
        return false;

    switch (data_type)
    {
    case ImGuiDataType_S32:    return DragBehaviorT<ImS32, ImS32, float >(data_type, (ImS32*)v,  v_speed, v_min ? *(const ImS32* )v_min : IM_S32_MIN, v_max ? *(const ImS32* )v_max : IM_S32_MAX, format, power);
    case ImGuiDataType_U32:    return DragBehaviorT<ImU32, ImS32, float >(data_type, (ImU32*)v,  v_speed, v_min ? *(const ImU32* )v_min : IM_U32_MIN, v_max ? *(const ImU32* )v_max : IM_U32_MAX, format, power);
    case ImGuiDataType_S64:    return DragBehaviorT<ImS64, ImS64, double>(data_type, (ImS64*)v,  v_speed, v_min ? *(const ImS64* )v_min : IM_S64_MIN, v_max ? *(const ImS64* )v_max : IM_S64_MAX, format, power);
    case ImGuiDataType_U64:    return DragBehaviorT<ImU64, ImS64, double>(data_type, (ImU64*)v,  v_speed, v_min ? *(const ImU64* )v_min : IM_U64_MIN, v_max ? *(const ImU64* )v_max : IM_U64_MAX, format, power);
    case ImGuiDataType_Float:  return DragBehaviorT<float, float, float >(data_type, (float*)v,  v_speed, v_min ? *(const float* )v_min : -FLT_MAX,   v_max ? *(const float* )v_max : FLT_MAX,    format, power);
    case ImGuiDataType_Double: return DragBehaviorT<double,double,double>(data_type, (double*)v, v_speed, v_min ? *(const double*)v_min : -DBL_MAX,   v_max ? *(const double*)v_max : DBL_MAX,    format, power);
    case ImGuiDataType_COUNT:  break;
    }
    IM_ASSERT(0);
    return false;
}

bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    if (power != 1.0f)
        IM_ASSERT(v_min != NULL && v_max != NULL); // When using a power curve the drag needs to have known bounds

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const float w = CalcItemWidth();

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

    // NB- we don't call ItemSize() yet because we may turn into a text edit box below
    if (!ItemAdd(total_bb, id, &frame_bb))
    {
        ItemSize(total_bb, style.FramePadding.y);
        return false;
    }
    const bool hovered = ItemHoverable(frame_bb, id);

    // Default format string when passing NULL
    // Patch old "%.0f" format string to use "%d", read function comments for more details.
    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;
    else if (data_type == ImGuiDataType_S32 && strcmp(format, "%d") != 0)
        format = PatchFormatStringFloatToInt(format);

    // Tabbing or CTRL-clicking on Drag turns it into an input box
    bool start_text_input = false;
    const bool tab_focus_requested = FocusableItemRegister(window, id);
    if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
    {
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
        if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0] || g.NavInputId == id)
        {
            start_text_input = true;
            g.ScalarAsInputTextId = 0;
        }
    }
    if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
        return InputScalarAsWidgetReplacement(frame_bb, id, label, data_type, v, format);

    // Actual drag behavior
    ItemSize(total_bb, style.FramePadding.y);
    const bool value_changed = DragBehavior(id, data_type, v, v_speed, v_min, v_max, format, power);
    if (value_changed)
        MarkItemEdited(id);

    // Draw frame
    const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

    // Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
    char value_buf[64];
    const char* value_buf_end = value_buf + DataTypeFormatString(value_buf, IM_ARRAYSIZE(value_buf), data_type, v, format);
    RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

    return value_changed;
}

bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min, const void* v_max, const char* format, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= DragScalar("##v", data_type, v, v_speed, v_min, v_max, format, power);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power)
{
    return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power);
}

bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2);

    bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, format_max ? format_max : format, power);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();
    return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalar(label, ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format)
{
    return DragScalarN(label, ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format);
}

bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    PushID(label);
    BeginGroup();
    PushMultiItemsWidths(2);

    bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);
    value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, format_max ? format_max : format);
    PopItemWidth();
    SameLine(0, g.Style.ItemInnerSpacing.x);

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    PopID();

    return value_changed;
}

void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    if (graph_size.x == 0.0f)
        graph_size.x = CalcItemWidth();
    if (graph_size.y == 0.0f)
        graph_size.y = label_size.y + (style.FramePadding.y * 2);

    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(graph_size.x, graph_size.y));
    const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, 0, &frame_bb))
        return;
    const bool hovered = ItemHoverable(inner_bb, 0);

    // Determine scale from values if not specified
    if (scale_min == FLT_MAX || scale_max == FLT_MAX)
    {
        float v_min = FLT_MAX;
        float v_max = -FLT_MAX;
        for (int i = 0; i < values_count; i++)
        {
            const float v = values_getter(data, i);
            v_min = ImMin(v_min, v);
            v_max = ImMax(v_max, v);
        }
        if (scale_min == FLT_MAX)
            scale_min = v_min;
        if (scale_max == FLT_MAX)
            scale_max = v_max;
    }

    RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

    if (values_count > 0)
    {
        int res_w = ImMin((int)graph_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
        int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

        // Tooltip on hover
        int v_hovered = -1;
        if (hovered)
        {
            const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
            const int v_idx = (int)(t * item_count);
            IM_ASSERT(v_idx >= 0 && v_idx < values_count);

            const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
            const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
            if (plot_type == ImGuiPlotType_Lines)
                SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx+1, v1);
            else if (plot_type == ImGuiPlotType_Histogram)
                SetTooltip("%d: %8.4g", v_idx, v0);
            v_hovered = v_idx;
        }

        const float t_step = 1.0f / (float)res_w;
        const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

        float v0 = values_getter(data, (0 + values_offset) % values_count);
        float t0 = 0.0f;
        ImVec2 tp0 = ImVec2( t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale) );                       // Point in the normalized space of our target rectangle
        float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands

        const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
        const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

        for (int n = 0; n < res_w; n++)
        {
            const float t1 = t0 + t_step;
            const int v1_idx = (int)(t0 * item_count + 0.5f);
            IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
            const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
            const ImVec2 tp1 = ImVec2( t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale) );

            // NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
            ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
            ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
            if (plot_type == ImGuiPlotType_Lines)
            {
                window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }
            else if (plot_type == ImGuiPlotType_Histogram)
            {
                if (pos1.x >= pos0.x + 2.0f)
                    pos1.x -= 1.0f;
                window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
            }

            t0 = t1;
            tp0 = tp1;
        }
    }

    // Text overlay
    if (overlay_text)
        RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f,0.0f));

    if (label_size.x > 0.0f)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);
}

struct ImGuiPlotArrayGetterData
{
    const float* Values;
    int Stride;

    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }
};

static float Plot_ArrayGetter(void* data, int idx)
{
    ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
    const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);
    return v;
}

void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
    ImGuiPlotArrayGetterData data(values, stride);
    PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
    PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    ImVec2 pos = window->DC.CursorPos;
    ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y*2.0f));
    ItemSize(bb, style.FramePadding.y);
    if (!ItemAdd(bb, 0))
        return;

    // Render
    fraction = ImSaturate(fraction);
    RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
    const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
    RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);

    // Default displaying the fraction as percentage string, but user can override it
    char overlay_buf[32];
    if (!overlay)
    {
        ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction*100+0.01f);
        overlay = overlay_buf;
    }

    ImVec2 overlay_size = CalcTextSize(overlay, NULL);
    if (overlay_size.x > 0.0f)
        RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f,0.5f), &bb);
}

bool ImGui::Checkbox(const char* label, bool* v)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2, label_size.y + style.FramePadding.y*2)); // We want a square shape to we use Y twice
    ItemSize(check_bb, style.FramePadding.y);

    ImRect total_bb = check_bb;
    if (label_size.x > 0)
        SameLine(0, style.ItemInnerSpacing.x);
    const ImRect text_bb(window->DC.CursorPos + ImVec2(0,style.FramePadding.y), window->DC.CursorPos + ImVec2(0,style.FramePadding.y) + label_size);
    if (label_size.x > 0)
    {
        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);
        total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));
    }

    if (!ItemAdd(total_bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
    {
        *v = !(*v);
        MarkItemEdited(id);
    }

    RenderNavHighlight(total_bb, id);
    RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
    if (*v)
    {
        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());
        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));
        RenderCheckMark(check_bb.Min + ImVec2(pad,pad), GetColorU32(ImGuiCol_CheckMark), check_bb.GetWidth() - pad*2.0f);
    }

    if (g.LogEnabled)
        LogRenderedText(&text_bb.Min, *v ? "[x]" : "[ ]");
    if (label_size.x > 0.0f)
        RenderText(text_bb.Min, label);

    return pressed;
}

bool ImGui::Checkbox(const char* label, float* v)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y * 2, label_size.y + style.FramePadding.y * 2)); // We want a square shape to we use Y twice
	ItemSize(check_bb, style.FramePadding.y);

	ImRect total_bb = check_bb;
	if (label_size.x > 0)
		SameLine(0, style.ItemInnerSpacing.x);
	const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);
	if (label_size.x > 0)
	{
		ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);
		total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));
	}

	if (!ItemAdd(total_bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
	if (pressed)
	{
		*v = !(*v);
		MarkItemEdited(id);
	}

	RenderNavHighlight(total_bb, id);
	RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), true, style.FrameRounding);
	if (*v)
	{
		const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());
		const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));
		RenderCheckMark(check_bb.Min + ImVec2(pad, pad), GetColorU32(ImGuiCol_CheckMark), check_bb.GetWidth() - pad * 2.0f);
	}

	if (g.LogEnabled)
		LogRenderedText(&text_bb.Min, *v ? "[x]" : "[ ]");
	if (label_size.x > 0.0f)
		RenderText(text_bb.Min, label);

	return pressed;
}

bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
{
    bool v = ((*flags & flags_value) == flags_value);
    bool pressed = Checkbox(label, &v);
    if (pressed)
    {
        if (v)
            *flags |= flags_value;
        else
            *flags &= ~flags_value;
    }

    return pressed;
}

bool ImGui::RadioButton(const char* label, bool active)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y*2-1, label_size.y + style.FramePadding.y*2-1));
    ItemSize(check_bb, style.FramePadding.y);

    ImRect total_bb = check_bb;
    if (label_size.x > 0)
        SameLine(0, style.ItemInnerSpacing.x);
    const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);
    if (label_size.x > 0)
    {
        ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);
        total_bb.Add(text_bb);
    }

    if (!ItemAdd(total_bb, id))
        return false;

    ImVec2 center = check_bb.GetCenter();
    center.x = (float)(int)center.x + 0.5f;
    center.y = (float)(int)center.y + 0.5f;
    const float radius = check_bb.GetHeight() * 0.5f;

    bool hovered, held;
    bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
    if (pressed)
        MarkItemEdited(id);

    RenderNavHighlight(total_bb, id);
    window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);
    if (active)
    {
        const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());
        const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));
        window->DrawList->AddCircleFilled(center, radius-pad, GetColorU32(ImGuiCol_CheckMark), 16);
    }

    if (style.FrameBorderSize > 0.0f)
    {
        window->DrawList->AddCircle(center+ImVec2(1,1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);
        window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);
    }

    if (label_size.x > 0.0f)
        RenderText(text_bb.Min, label);

    return pressed;
}

bool ImGui::RadioButton(const char* label, int* v, int v_button)
{
    const bool pressed = RadioButton(label, *v == v_button);
    if (pressed)
        *v = v_button;
    return pressed;
}

static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)
{
    int line_count = 0;
    const char* s = text_begin;
    while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding
        if (c == '\n')
            line_count++;
    s--;
    if (s[0] != '\n' && s[0] != '\r')
        line_count++;
    *out_text_end = s;
    return line_count;
}

static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)
{
    ImFont* font = GImGui->Font;
    const float line_height = GImGui->FontSize;
    const float scale = line_height / font->FontSize;

    ImVec2 text_size = ImVec2(0,0);
    float line_width = 0.0f;

    const ImWchar* s = text_begin;
    while (s < text_end)
    {
        unsigned int c = (unsigned int)(*s++);
        if (c == '\n')
        {
            text_size.x = ImMax(text_size.x, line_width);
            text_size.y += line_height;
            line_width = 0.0f;
            if (stop_on_new_line)
                break;
            continue;
        }
        if (c == '\r')
            continue;

        const float char_width = font->GetCharAdvance((unsigned short)c) * scale;
        line_width += char_width;
    }

    if (text_size.x < line_width)
        text_size.x = line_width;

    if (out_offset)
        *out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

    if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n
        text_size.y += line_height;

    if (remaining)
        *remaining = s;

    return text_size;
}

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImGuiStb
{

static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }
static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }
static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx+char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }
static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }
static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
{
    const ImWchar* text = obj->TextW.Data;
    const ImWchar* text_remaining = NULL;
    const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);
    r->x0 = 0.0f;
    r->x1 = size.x;
    r->baseline_y_delta = size.y;
    r->ymin = 0.0f;
    r->ymax = size.y;
    r->num_chars = (int)(text_remaining - (text + line_start_idx));
}

static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }
static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }
#ifdef __APPLE__    // FIXME: Move setting to IO structure
static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->TextW[idx-1] ) && is_separator( obj->TextW[idx] ) ) : 1; }
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }
#else
static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }
#endif
#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)
{
    ImWchar* dst = obj->TextW.Data + pos;

    // We maintain our buffer length in both UTF-8 and wchar formats
    obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);
    obj->CurLenW -= n;

    // Offset remaining text
    const ImWchar* src = obj->TextW.Data + pos + n;
    while (ImWchar c = *src++)
        *dst++ = c;
    *dst = '\0';
}

static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
{
    const bool is_resizable = (obj->UserFlags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int text_len = obj->CurLenW;
    IM_ASSERT(pos <= text_len);

    const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
    if (!is_resizable && (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufCapacityA))
        return false;

    // Grow internal buffer if needed
    if (new_text_len + text_len + 1 > obj->TextW.Size)
    {
        if (!is_resizable)
            return false;
        IM_ASSERT(text_len < obj->TextW.Size);
        obj->TextW.resize(text_len + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1);
    }

    ImWchar* text = obj->TextW.Data;
    if (pos != text_len)
        memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));
    memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

    obj->CurLenW += new_text_len;
    obj->CurLenA += new_text_len_utf8;
    obj->TextW[obj->CurLenW] = '\0';

    return true;
}

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_SHIFT        0x20000

#define STB_TEXTEDIT_IMPLEMENTATION
#include "stb_textedit.h"

}

void ImGuiInputTextState::OnKeyPressed(int key)
{
    stb_textedit_key(this, &StbState, key);
    CursorFollow = true;
    CursorAnimReset();
}

ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()
{
    memset(this, 0, sizeof(*this));
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)
{
    IM_ASSERT(pos + bytes_count <= BufTextLen);
    char* dst = Buf + pos;
    const char* src = Buf + pos + bytes_count;
    while (char c = *src++)
        *dst++ = c;
    *dst = '\0';

    if (CursorPos + bytes_count >= pos)
        CursorPos -= bytes_count;
    else if (CursorPos >= pos)
        CursorPos = pos;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen -= bytes_count;
}

void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)
{
    const bool is_resizable = (Flags & ImGuiInputTextFlags_CallbackResize) != 0;
    const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
    if (new_text_len + BufTextLen >= BufSize)
    {
        if (!is_resizable)
            return;

        // Contrary to STB_TEXTEDIT_INSERTCHARS() this is working in the UTF8 buffer, hence the midly similar code (until we remove the U16 buffer alltogether!)
        ImGuiContext& g = *GImGui;
        ImGuiInputTextState* edit_state = &g.InputTextState;
        IM_ASSERT(edit_state->ID != 0 && g.ActiveId == edit_state->ID);
        IM_ASSERT(Buf == edit_state->TempBuffer.Data);
        int new_buf_size = BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(256, new_text_len)) + 1;
        edit_state->TempBuffer.reserve(new_buf_size + 1);
        Buf = edit_state->TempBuffer.Data;
        BufSize = edit_state->BufCapacityA = new_buf_size;
    }

    if (BufTextLen != pos)
        memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
    memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
    Buf[BufTextLen + new_text_len] = '\0';

    if (CursorPos >= pos)
        CursorPos += new_text_len;
    SelectionStart = SelectionEnd = CursorPos;
    BufDirty = true;
    BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    unsigned int c = *p_char;

    if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))
    {
        bool pass = false;
        pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));
        pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));
        if (!pass)
            return false;
    }

    if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.
        return false;

    if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))
    {
        if (flags & ImGuiInputTextFlags_CharsDecimal)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsScientific)
            if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsHexadecimal)
            if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
                return false;

        if (flags & ImGuiInputTextFlags_CharsUppercase)
            if (c >= 'a' && c <= 'z')
                *p_char = (c += (unsigned int)('A'-'a'));

        if (flags & ImGuiInputTextFlags_CharsNoBlank)
            if (ImCharIsBlankW(c))
                return false;
    }

    if (flags & ImGuiInputTextFlags_CallbackCharFilter)
    {
        ImGuiInputTextCallbackData callback_data;
        memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
        callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
        callback_data.EventChar = (ImWchar)c;
        callback_data.Flags = flags;
        callback_data.UserData = user_data;
        if (callback(&callback_data) != 0)
            return false;
        *p_char = callback_data.EventChar;
        if (!callback_data.EventChar)
            return false;
    }

    return true;
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match 
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/stl/imgui_stl.h
// (FIXME: Rather messy function partly because we are doing UTF8 > u16 > UTF8 conversions on the go to more easily handle stb_textedit calls. Ideally we should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline)));        // Can't use both together (they both use up/down keys)
    IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)

    ImGuiContext& g = *GImGui;
    const ImGuiIO& io = g.IO;
    const ImGuiStyle& style = g.Style;

    const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;
    const bool is_editable = (flags & ImGuiInputTextFlags_ReadOnly) == 0;
    const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;
    const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;
    const bool is_resizable = (flags & ImGuiInputTextFlags_CallbackResize) != 0;
    if (is_resizable)
        IM_ASSERT(callback != NULL); // Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!

    if (is_multiline) // Open group before calling GetID() because groups tracks id created within their scope, 
        BeginGroup();
    const ImGuiID id = window->GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y*2.0f); // Arbitrary default of 8 lines high for multi-line
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

    ImGuiWindow* draw_window = window;
    if (is_multiline)
    {
        ItemAdd(total_bb, id, &frame_bb);
        if (!BeginChildFrame(id, frame_bb.GetSize()))
        {
            EndChildFrame();
            EndGroup();
            return false;
        }
        draw_window = GetCurrentWindow();
        draw_window->DC.NavLayerActiveMaskNext |= draw_window->DC.NavLayerCurrentMask; // This is to ensure that EndChild() will display a navigation highlight
        size.x -= draw_window->ScrollbarSizes.x;
    }
    else
    {
        ItemSize(total_bb, style.FramePadding.y);
        if (!ItemAdd(total_bb, id, &frame_bb))
            return false;
    }
    const bool hovered = ItemHoverable(frame_bb, id);
    if (hovered)
        g.MouseCursor = ImGuiMouseCursor_TextInput;

    // Password pushes a temporary font with only a fallback glyph
    if (is_password)
    {
        const ImFontGlyph* glyph = g.Font->FindGlyph('*');
        ImFont* password_font = &g.InputTextPasswordFont;
        password_font->FontSize = g.Font->FontSize;
        password_font->Scale = g.Font->Scale;
        password_font->DisplayOffset = g.Font->DisplayOffset;
        password_font->Ascent = g.Font->Ascent;
        password_font->Descent = g.Font->Descent;
        password_font->ContainerAtlas = g.Font->ContainerAtlas;
        password_font->FallbackGlyph = glyph;
        password_font->FallbackAdvanceX = glyph->AdvanceX;
        IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
        PushFont(password_font);
    }

    // NB: we are only allowed to access 'edit_state' if we are the active widget.
    ImGuiInputTextState& edit_state = g.InputTextState;

    const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion|ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing
    const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);
    const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

    const bool user_clicked = hovered && io.MouseClicked[0];
    const bool user_scrolled = is_multiline && g.ActiveId == 0 && edit_state.ID == id && g.ActiveIdPreviousFrame == draw_window->GetIDNoKeepAlive(XorString("#SCROLLY"));
    const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));

    bool clear_active_id = false;

    bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);
    if (focus_requested || user_clicked || user_scrolled || user_nav_input_start)
    {
        if (g.ActiveId != id)
        {
            // Start edition
            // Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
            // From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
            const int prev_len_w = edit_state.CurLenW;
            const int init_buf_len = (int)strlen(buf);
            edit_state.TextW.resize(buf_size+1);             // wchar count <= UTF-8 count. we use +1 to make sure that .Data isn't NULL so it doesn't crash.
            edit_state.InitialText.resize(init_buf_len + 1); // UTF-8. we use +1 to make sure that .Data isn't NULL so it doesn't crash.
            memcpy(edit_state.InitialText.Data, buf, init_buf_len + 1);
            const char* buf_end = NULL;
            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, buf_size, buf, NULL, &buf_end);
            edit_state.CurLenA = (int)(buf_end - buf); // We can't get the result from ImStrncpy() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.
            edit_state.CursorAnimReset();

            // Preserve cursor position and undo/redo stack if we come back to same widget
            // FIXME: We should probably compare the whole buffer to be on the safety side. Comparing buf (utf8) and edit_state.Text (wchar).
            const bool recycle_state = (edit_state.ID == id) && (prev_len_w == edit_state.CurLenW);
            if (recycle_state)
            {
                // Recycle existing cursor/selection/undo stack but clamp position
                // Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
                edit_state.CursorClamp();
            }
            else
            {
                edit_state.ID = id;
                edit_state.ScrollX = 0.0f;
                stb_textedit_initialize_state(&edit_state.StbState, !is_multiline);
                if (!is_multiline && focus_requested_by_code)
                    select_all = true;
            }
            if (flags & ImGuiInputTextFlags_AlwaysInsertMode)
                edit_state.StbState.insert_mode = true;
            if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))
                select_all = true;
        }
        SetActiveID(id, window);
        SetFocusID(id, window);
        FocusWindow(window);
        if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))
            g.ActiveIdAllowNavDirFlags |= ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));
    }
    else if (io.MouseClicked[0])
    {
        // Release focus when we click outside
        clear_active_id = true;
    }

    bool value_changed = false;
    bool enter_pressed = false;
    int backup_current_text_length = 0;

    if (g.ActiveId == id)
    {
        if (!is_editable && !g.ActiveIdIsJustActivated)
        {
            // When read-only we always use the live data passed to the function
            edit_state.TextW.resize(buf_size+1);
            const char* buf_end = NULL;
            edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, buf, NULL, &buf_end);
            edit_state.CurLenA = (int)(buf_end - buf);
            edit_state.CursorClamp();
        }

        backup_current_text_length = edit_state.CurLenA;
        edit_state.BufCapacityA = buf_size;
        edit_state.UserFlags = flags;
        edit_state.UserCallback = callback;
        edit_state.UserCallbackData = callback_user_data;

        // Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
        // Down the line we should have a cleaner library-wide concept of Selected vs Active.
        g.ActiveIdAllowOverlap = !io.MouseDown[0];
        g.WantTextInputNextFrame = 1;

        // Edit in progress
        const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + edit_state.ScrollX;
        const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize*0.5f));

        const bool is_osx = io.ConfigMacOSXBehaviors;
        if (select_all || (hovered && !is_osx && io.MouseDoubleClicked[0]))
        {
            edit_state.SelectAll();
            edit_state.SelectedAllMouseLock = true;
        }
        else if (hovered && is_osx && io.MouseDoubleClicked[0])
        {
            // Double-click select a word only, OS X style (by simulating keystrokes)
            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
            edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
        }
        else if (io.MouseClicked[0] && !edit_state.SelectedAllMouseLock)
        {
            if (hovered)
            {
                stb_textedit_click(&edit_state, &edit_state.StbState, mouse_x, mouse_y);
                edit_state.CursorAnimReset();
            }
        }
        else if (io.MouseDown[0] && !edit_state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))
        {
            stb_textedit_drag(&edit_state, &edit_state.StbState, mouse_x, mouse_y);
            edit_state.CursorAnimReset();
            edit_state.CursorFollow = true;
        }
        if (edit_state.SelectedAllMouseLock && !io.MouseDown[0])
            edit_state.SelectedAllMouseLock = false;

        if (io.InputCharacters[0])
        {
            // Process text input (before we check for Return because using some IME will effectively send a Return?)
            // We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
            bool ignore_inputs = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeySuper);
            if (!ignore_inputs && is_editable && !user_nav_input_start)
                for (int n = 0; n < IM_ARRAYSIZE(io.InputCharacters) && io.InputCharacters[n]; n++)
                {
                    // Insert character if they pass filtering
                    unsigned int c = (unsigned int)io.InputCharacters[n];
                    if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        edit_state.OnKeyPressed((int)c);
                }

            // Consume characters
            memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));
        }
    }

    bool cancel_edit = false;
    if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)
    {
        // Handle key-presses
        const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
        const bool is_osx = io.ConfigMacOSXBehaviors;
        const bool is_shortcut_key = (is_osx ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl
        const bool is_osx_shift_shortcut = is_osx && io.KeySuper && io.KeyShift && !io.KeyCtrl && !io.KeyAlt;
        const bool is_wordmove_key_down = is_osx ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
        const bool is_startend_key_down = is_osx && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
        const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;
        const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

        const bool is_cut   = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && is_editable && !is_password && (!is_multiline || edit_state.HasSelection());
        const bool is_copy  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only  && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || edit_state.HasSelection());
        const bool is_paste = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && is_editable;
        const bool is_undo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Z)) && is_editable && is_undoable);
        const bool is_redo  = ((is_shortcut_key && IsKeyPressedMap(ImGuiKey_Y)) || (is_osx_shift_shortcut && IsKeyPressedMap(ImGuiKey_Z))) && is_editable && is_undoable;

        if (IsKeyPressedMap(ImGuiKey_LeftArrow))                        { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_RightArrow))                  { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline)     { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline)   { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Home))                        { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_End))                         { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Delete) && is_editable)       { edit_state.OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }
        else if (IsKeyPressedMap(ImGuiKey_Backspace) && is_editable)
        {
            if (!edit_state.HasSelection())
            {
                if (is_wordmove_key_down) edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT|STB_TEXTEDIT_K_SHIFT);
                else if (is_osx && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) edit_state.OnKeyPressed(STB_TEXTEDIT_K_LINESTART|STB_TEXTEDIT_K_SHIFT);
            }
            edit_state.OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
        }
        else if (IsKeyPressedMap(ImGuiKey_Enter))
        {
            bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
            if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))
            {
                enter_pressed = clear_active_id = true;
            }
            else if (is_editable)
            {
                unsigned int c = '\n'; // Insert new line
                if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                    edit_state.OnKeyPressed((int)c);
            }
        }
        else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && is_editable)
        {
            unsigned int c = '\t'; // Insert TAB
            if (InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                edit_state.OnKeyPressed((int)c);
        }
        else if (IsKeyPressedMap(ImGuiKey_Escape))
        {
            clear_active_id = cancel_edit = true;
        }
        else if (is_undo || is_redo)
        {
            edit_state.OnKeyPressed(is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO);
            edit_state.ClearSelection();
        }
        else if (is_shortcut_key && IsKeyPressedMap(ImGuiKey_A))
        {
            edit_state.SelectAll();
            edit_state.CursorFollow = true;
        }
        else if (is_cut || is_copy)
        {
            // Cut, Copy
            if (io.SetClipboardTextFn)
            {
                const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;
                const int ie = edit_state.HasSelection() ? ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end) : edit_state.CurLenW;
                edit_state.TempBuffer.resize((ie-ib) * 4 + 1);
                ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data+ib, edit_state.TextW.Data+ie);
                SetClipboardText(edit_state.TempBuffer.Data);
            }
            if (is_cut)
            {
                if (!edit_state.HasSelection())
                    edit_state.SelectAll();
                edit_state.CursorFollow = true;
                stb_textedit_cut(&edit_state, &edit_state.StbState);
            }
        }
        else if (is_paste)
        {
            if (const char* clipboard = GetClipboardText())
            {
                // Filter pasted buffer
                const int clipboard_len = (int)strlen(clipboard);
                ImWchar* clipboard_filtered = (ImWchar*)ImGui::MemAlloc((clipboard_len+1) * sizeof(ImWchar));
                int clipboard_filtered_len = 0;
                for (const char* s = clipboard; *s; )
                {
                    unsigned int c;
                    s += ImTextCharFromUtf8(&c, s, NULL);
                    if (c == 0)
                        break;
                    if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, callback_user_data))
                        continue;
                    clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;
                }
                clipboard_filtered[clipboard_filtered_len] = 0;
                if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation
                {
                    stb_textedit_paste(&edit_state, &edit_state.StbState, clipboard_filtered, clipboard_filtered_len);
                    edit_state.CursorFollow = true;
                }
                ImGui::MemFree(clipboard_filtered);
            }
        }
    }

    if (g.ActiveId == id)
    {
        const char* apply_new_text = NULL;
        int apply_new_text_length = 0;
        if (cancel_edit)
        {
            // Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
            if (is_editable && strcmp(buf, edit_state.InitialText.Data) != 0)
            {
                apply_new_text = edit_state.InitialText.Data;
                apply_new_text_length = edit_state.InitialText.Size - 1;
            }
        }

        // When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
        // If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.
        bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);
        if (apply_edit_back_to_user_buffer)
        {
            // Apply new value immediately - copy modified buffer back
            // Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
            // FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
            // FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
            if (is_editable)
            {
                edit_state.TempBuffer.resize(edit_state.TextW.Size * 4 + 1);
                ImTextStrToUtf8(edit_state.TempBuffer.Data, edit_state.TempBuffer.Size, edit_state.TextW.Data, NULL);
            }

            // User callback
            if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)
            {
                IM_ASSERT(callback != NULL);

                // The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
                ImGuiInputTextFlags event_flag = 0;
                ImGuiKey event_key = ImGuiKey_COUNT;
                if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))
                {
                    event_flag = ImGuiInputTextFlags_CallbackCompletion;
                    event_key = ImGuiKey_Tab;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_UpArrow;
                }
                else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))
                {
                    event_flag = ImGuiInputTextFlags_CallbackHistory;
                    event_key = ImGuiKey_DownArrow;
                }
                else if (flags & ImGuiInputTextFlags_CallbackAlways)
                    event_flag = ImGuiInputTextFlags_CallbackAlways;

                if (event_flag)
                {
                    ImGuiInputTextCallbackData callback_data;
                    memset(&callback_data, 0, sizeof(ImGuiInputTextCallbackData));
                    callback_data.EventFlag = event_flag;
                    callback_data.Flags = flags;
                    callback_data.UserData = callback_user_data;

                    callback_data.EventKey = event_key;
                    callback_data.Buf = edit_state.TempBuffer.Data;
                    callback_data.BufTextLen = edit_state.CurLenA;
                    callback_data.BufSize = edit_state.BufCapacityA;
                    callback_data.BufDirty = false;

                    // We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
                    ImWchar* text = edit_state.TextW.Data;
                    const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.cursor);
                    const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_start);
                    const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_end);

                    // Call user code
                    callback(&callback_data);

                    // Read back what user may have modified
                    IM_ASSERT(callback_data.Buf == edit_state.TempBuffer.Data);  // Invalid to modify those fields
                    IM_ASSERT(callback_data.BufSize == edit_state.BufCapacityA);
                    IM_ASSERT(callback_data.Flags == flags);
                    if (callback_data.CursorPos != utf8_cursor_pos)            { edit_state.StbState.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos); edit_state.CursorFollow = true; }
                    if (callback_data.SelectionStart != utf8_selection_start)  { edit_state.StbState.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart); }
                    if (callback_data.SelectionEnd != utf8_selection_end)      { edit_state.StbState.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd); }
                    if (callback_data.BufDirty)
                    {
                        IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
                        if (callback_data.BufTextLen > backup_current_text_length && is_resizable)
                            edit_state.TextW.resize(edit_state.TextW.Size + (callback_data.BufTextLen - backup_current_text_length));
                        edit_state.CurLenW = ImTextStrFromUtf8(edit_state.TextW.Data, edit_state.TextW.Size, callback_data.Buf, NULL);
                        edit_state.CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
                        edit_state.CursorAnimReset();
                    }
                }
            }

            // Will copy result string if modified
            if (is_editable && strcmp(edit_state.TempBuffer.Data, buf) != 0)
            {
                apply_new_text = edit_state.TempBuffer.Data;
                apply_new_text_length = edit_state.CurLenA;
            }
        }

        // Copy result to user buffer
        if (apply_new_text)
        {
            IM_ASSERT(apply_new_text_length >= 0);
            if (backup_current_text_length != apply_new_text_length && is_resizable)
            {
                ImGuiInputTextCallbackData callback_data;
                callback_data.EventFlag = ImGuiInputTextFlags_CallbackResize;
                callback_data.Flags = flags;
                callback_data.Buf = buf;
                callback_data.BufTextLen = apply_new_text_length;
                callback_data.BufSize = ImMax(buf_size, apply_new_text_length + 1);
                callback_data.UserData = callback_user_data;
                callback(&callback_data);
                buf = callback_data.Buf;
                buf_size = callback_data.BufSize;
                apply_new_text_length = ImMin(callback_data.BufTextLen, buf_size - 1);
                IM_ASSERT(apply_new_text_length <= buf_size);
            }

            // If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
            ImStrncpy(buf, edit_state.TempBuffer.Data, ImMin(apply_new_text_length + 1, buf_size));
            value_changed = true;
        }

        // Clear temporary user storage
        edit_state.UserFlags = 0;
        edit_state.UserCallback = NULL;
        edit_state.UserCallbackData = NULL;
    }

    // Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
    if (clear_active_id && g.ActiveId == id)
        ClearActiveID();

    // Render
    // Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is set 'buf' might still be the old value. We set buf to NULL to prevent accidental usage from now on.
    const char* buf_display = (g.ActiveId == id && is_editable) ? edit_state.TempBuffer.Data : buf; buf = NULL;

    // Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
    // without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
    // Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
    const int buf_display_max_length = 2 * 1024 * 1024;

    if (!is_multiline)
    {
        RenderNavHighlight(frame_bb, id);
        RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
    }

    const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size
    ImVec2 render_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
    ImVec2 text_size(0.f, 0.f);
    const bool is_currently_scrolling = (edit_state.ID == id && is_multiline && g.ActiveId == draw_window->GetIDNoKeepAlive(XorString("#SCROLLY")));
    if (g.ActiveId == id || is_currently_scrolling)
    {
        edit_state.CursorAnim += io.DeltaTime;

        // This is going to be messy. We need to:
        // - Display the text (this alone can be more easily clipped)
        // - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
        // - Measure text height (for scrollbar)
        // We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
        // FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
        const ImWchar* text_begin = edit_state.TextW.Data;
        ImVec2 cursor_offset, select_start_offset;

        {
            // Count lines + find lines numbers straddling 'cursor' and 'select_start' position.
            const ImWchar* searches_input_ptr[2];
            searches_input_ptr[0] = text_begin + edit_state.StbState.cursor;
            searches_input_ptr[1] = NULL;
            int searches_remaining = 1;
            int searches_result_line_number[2] = { -1, -999 };
            if (edit_state.StbState.select_start != edit_state.StbState.select_end)
            {
                searches_input_ptr[1] = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);
                searches_result_line_number[1] = -1;
                searches_remaining++;
            }

            // Iterate all lines to find our line numbers
            // In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
            searches_remaining += is_multiline ? 1 : 0;
            int line_count = 0;
            for (const ImWchar* s = text_begin; *s != 0; s++)
                if (*s == '\n')
                {
                    line_count++;
                    if (searches_result_line_number[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_number[0] = line_count; if (--searches_remaining <= 0) break; }
                    if (searches_result_line_number[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_number[1] = line_count; if (--searches_remaining <= 0) break; }
                }
            line_count++;
            if (searches_result_line_number[0] == -1) searches_result_line_number[0] = line_count;
            if (searches_result_line_number[1] == -1) searches_result_line_number[1] = line_count;

            // Calculate 2d position by finding the beginning of the line and measuring distance
            cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;
            cursor_offset.y = searches_result_line_number[0] * g.FontSize;
            if (searches_result_line_number[1] >= 0)
            {
                select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;
                select_start_offset.y = searches_result_line_number[1] * g.FontSize;
            }

            // Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
            if (is_multiline)
                text_size = ImVec2(size.x, line_count * g.FontSize);
        }

        // Scroll
        if (edit_state.CursorFollow)
        {
            // Horizontal scroll in chunks of quarter width
            if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))
            {
                const float scroll_increment_x = size.x * 0.25f;
                if (cursor_offset.x < edit_state.ScrollX)
                    edit_state.ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);
                else if (cursor_offset.x - size.x >= edit_state.ScrollX)
                    edit_state.ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);
            }
            else
            {
                edit_state.ScrollX = 0.0f;
            }

            // Vertical scroll
            if (is_multiline)
            {
                float scroll_y = draw_window->Scroll.y;
                if (cursor_offset.y - g.FontSize < scroll_y)
                    scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
                else if (cursor_offset.y - size.y >= scroll_y)
                    scroll_y = cursor_offset.y - size.y;
                draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // To avoid a frame of lag
                draw_window->Scroll.y = scroll_y;
                render_pos.y = draw_window->DC.CursorPos.y;
            }
        }
        edit_state.CursorFollow = false;
        const ImVec2 render_scroll = ImVec2(edit_state.ScrollX, 0.0f);

        // Draw selection
        if (edit_state.StbState.select_start != edit_state.StbState.select_end)
        {
            const ImWchar* text_selected_begin = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);
            const ImWchar* text_selected_end = text_begin + ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end);

            float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
            float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
            ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);
            ImVec2 rect_pos = render_pos + select_start_offset - render_scroll;
            for (const ImWchar* p = text_selected_begin; p < text_selected_end; )
            {
                if (rect_pos.y > clip_rect.w + g.FontSize)
                    break;
                if (rect_pos.y < clip_rect.y)
                {
                    while (p < text_selected_end)
                        if (*p++ == '\n')
                            break;
                }
                else
                {
                    ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);
                    if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((unsigned short)' ') * 0.50f); // So we can see selected empty lines
                    ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos +ImVec2(rect_size.x, bg_offy_dn));
                    rect.ClipWith(clip_rect);
                    if (rect.Overlaps(clip_rect))
                        draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
                }
                rect_pos.x = render_pos.x - render_scroll.x;
                rect_pos.y += g.FontSize;
            }
        }

        const int buf_display_len = edit_state.CurLenA;
        if (is_multiline || buf_display_len < buf_display_max_length)
            draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + buf_display_len, 0.0f, is_multiline ? NULL : &clip_rect);

        // Draw blinking cursor
        bool cursor_is_visible = (!g.IO.ConfigCursorBlink) || (g.InputTextState.CursorAnim <= 0.0f) || ImFmod(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;
        ImVec2 cursor_screen_pos = render_pos + cursor_offset - render_scroll;
        ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y-g.FontSize+0.5f, cursor_screen_pos.x+1.0f, cursor_screen_pos.y-1.5f);
        if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
            draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

        // Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
        if (is_editable)
            g.PlatformImePos = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);
    }
    else
    {
        // Render text only
        const char* buf_end = NULL;
        if (is_multiline)
            text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width
        else
            buf_end = buf_display + strlen(buf_display);
        if (is_multiline || (buf_end - buf_display) < buf_display_max_length)
            draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);
    }

    if (is_multiline)
    {
        Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line
        EndChildFrame();
        EndGroup();
    }

    if (is_password)
        PopFont();

    // Log as text
    if (g.LogEnabled && !is_password)
        LogRenderedText(&render_pos, buf_display, NULL);

    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if (value_changed)
        MarkItemEdited(id);

    if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)
        return enter_pressed;
    else
        return value_changed;
}

bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
    return InputTextEx(label, buf, (int)buf_size, ImVec2(0,0), flags, callback, user_data);
}

bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)
{
    return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
}

// NB: format here must be a simple "%xx" format string with no prefix/suffix (unlike the Drag/Slider functions "format" argument)
bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* data_ptr, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    IM_ASSERT(data_type >= 0 && data_type < ImGuiDataType_COUNT);
    if (format == NULL)
        format = GDataTypeInfo[data_type].PrintFmt;

    char buf[64];
    DataTypeFormatString(buf, IM_ARRAYSIZE(buf), data_type, data_ptr, format);

    bool value_changed = false;
    if ((extra_flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)
        extra_flags |= ImGuiInputTextFlags_CharsDecimal;
    extra_flags |= ImGuiInputTextFlags_AutoSelectAll;

    if (step != NULL)
    {
        const float button_size = GetFrameHeight();

        BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
        PushID(label);
        PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2));
        if (InputText("", buf, IM_ARRAYSIZE(buf), extra_flags)) // PushId(label) + "" gives us the expected ID from outside point of view
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);
        PopItemWidth();

        // Step buttons
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("-", ImVec2(button_size, button_size), ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))
        {
            DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        if (ButtonEx("+", ImVec2(button_size, button_size), ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))
        {
            DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast ? step_fast : step);
            value_changed = true;
        }
        SameLine(0, style.ItemInnerSpacing.x);
        TextUnformatted(label, FindRenderedTextEnd(label));

        PopID();
        EndGroup();
    }
    else
    {
        if (InputText(label, buf, IM_ARRAYSIZE(buf), extra_flags))
            value_changed = DataTypeApplyOpFromText(buf, g.InputTextState.InitialText.Data, data_type, data_ptr, format);
    }

    return value_changed;
}

bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    extra_flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Float, (void*)v, (void*)(step>0.0f ? &step : NULL), (void*)(step_fast>0.0f ? &step_fast : NULL), format, extra_flags);
}

bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    extra_flags |= ImGuiInputTextFlags_CharsScientific;
    return InputScalar(label, ImGuiDataType_Double, (void*)v, (void*)(step>0.0 ? &step : NULL), (void*)(step_fast>0.0 ? &step_fast : NULL), format, extra_flags);
}

bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
{
    // Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
    const char* format = (extra_flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
    return InputScalar(label, ImGuiDataType_S32, (void*)v, (void*)(step>0 ? &step : NULL), (void*)(step_fast>0 ? &step_fast : NULL), format, extra_flags);
}

bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags extra_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    BeginGroup();
    PushID(label);
    PushMultiItemsWidths(components);
    size_t type_size = GDataTypeInfo[data_type].Size;
    for (int i = 0; i < components; i++)
    {
        PushID(i);
        value_changed |= InputScalar("##v", data_type, v, step, step_fast, format, extra_flags);
        SameLine(0, g.Style.ItemInnerSpacing.x);
        PopID();
        PopItemWidth();
        v = (void*)((char*)v + type_size);
    }
    PopID();

    TextUnformatted(label, FindRenderedTextEnd(label));
    EndGroup();
    return value_changed;
}

bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, extra_flags);
}

// Prefer using "const char* format" directly, which is more flexible and consistent with other API.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputFloat(label, v, step, step_fast, format, extra_flags);
}

bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 2, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 3, NULL, NULL, format, extra_flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
    char format[16] = "%f";
    if (decimal_precision >= 0)
        ImFormatString(format, IM_ARRAYSIZE(format), "%%.%df", decimal_precision);
    return InputScalarN(label, ImGuiDataType_Float, v, 4, NULL, NULL, format, extra_flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 2, NULL, NULL, "%d", extra_flags);
}

bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 3, NULL, NULL, "%d", extra_flags);
}

bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
{
    return InputScalarN(label, ImGuiDataType_S32, v, 4, NULL, NULL, "%d", extra_flags);
}

static float CalcMaxPopupHeightFromItemCount(int items_count)
{
    ImGuiContext& g = *GImGui;
    if (items_count <= 0)
        return FLT_MAX;
    return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
{
    // Always consume the SetNextWindowSizeConstraint() call in our early return paths
    ImGuiContext& g = *GImGui;
    ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;
    g.NextWindowData.SizeConstraintCond = 0;

    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
    const ImVec2 label_size = CalcTextSize(label, NULL, true);
    const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();
    const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y*2.0f));
    const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    ItemSize(total_bb, style.FramePadding.y);
    if (!ItemAdd(total_bb, id, &frame_bb))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);
    bool popup_open = IsPopupOpen(id);

    const ImRect value_bb(frame_bb.Min, frame_bb.Max - ImVec2(arrow_size, 0.0f));
    const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
    RenderNavHighlight(frame_bb, id);
    if (!(flags & ImGuiComboFlags_NoPreview))
        window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Max.y), frame_col, style.FrameRounding, ImDrawCornerFlags_Left);
    if (!(flags & ImGuiComboFlags_NoArrowButton))
    {
        window->DrawList->AddRectFilled(ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button), style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);
        RenderArrow(ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), ImGuiDir_Down);
    }
    RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);
    if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
        RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, preview_value, NULL, NULL, ImVec2(0.0f,0.0f));
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    if ((pressed || g.NavActivateId == id) && !popup_open)
    {
        if (window->DC.NavLayerCurrent == 0)
            window->NavLastIds[0] = id;
        OpenPopupEx(id);
        popup_open = true;
    }

    if (!popup_open)
        return false;

    if (backup_next_window_size_constraint)
    {
        g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;
        g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
    }
    else
    {
        if ((flags & ImGuiComboFlags_HeightMask_) == 0)
            flags |= ImGuiComboFlags_HeightRegular;
        IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one
        int popup_max_height_in_items = -1;
        if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
        else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
        else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
        SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
    }

    char name[16];
    ImFormatString(name, IM_ARRAYSIZE(name), XorString("##Combo_%02d"), g.CurrentPopupStack.Size); // Recycle windows based on depth

    // Peak into expected window size so we can position it
    if (ImGuiWindow* popup_window = FindWindowByName(name))
        if (popup_window->WasActive)
        {
            ImVec2 size_expected = CalcWindowExpectedSize(popup_window);
            if (flags & ImGuiComboFlags_PopupAlignLeft)
                popup_window->AutoPosLastDirection = ImGuiDir_Left;
            ImRect r_outer = GetWindowAllowedExtentRect(popup_window);
            ImVec2 pos = FindBestWindowPosForPopupEx(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, r_outer, frame_bb, ImGuiPopupPositionPolicy_ComboBox);
            SetNextWindowPos(pos);
        }

    // Horizontally align ourselves with the framed text
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(style.FramePadding.x, style.WindowPadding.y));
    bool ret = Begin(name, NULL, window_flags);
    PopStyleVar();
    if (!ret)
    {
        EndPopup();
        IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
        return false;
    }
    return true;
}

void ImGui::EndCombo()
{
    EndPopup();
}

// Getter for the old Combo() API: const char*[]
static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
    const char* const* items = (const char* const*)data;
    if (out_text)
        *out_text = items[idx];
    return true;
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)
{
    // FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
    const char* items_separated_by_zeros = (const char*)data;
    int items_count = 0;
    const char* p = items_separated_by_zeros;
    while (*p)
    {
        if (idx == items_count)
            break;
        p += strlen(p) + 1;
        items_count++;
    }
    if (!*p)
        return false;
    if (out_text)
        *out_text = p;
    return true;
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
{
    ImGuiContext& g = *GImGui;

    // Call the getter to obtain the preview string which is a parameter to BeginCombo()
    const char* preview_value = NULL;
    if (*current_item >= 0 && *current_item < items_count)
        items_getter(data, *current_item, &preview_value);

    // The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
    if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)
        SetNextWindowSizeConstraints(ImVec2(0,0), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));

    if (!BeginCombo(label, preview_value, ImGuiComboFlags_None))
        return false;

    // Display items
    // FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
    bool value_changed = false;
    for (int i = 0; i < items_count; i++)
    {
        PushID((void*)(intptr_t)i);
        const bool item_selected = (i == *current_item);
        const char* item_text;
        if (!items_getter(data, i, &item_text))
            item_text = XorString("*Unknown item*");
        if (Selectable(item_text, item_selected))
        {
            value_changed = true;
            *current_item = i;
        }
        if (item_selected)
            SetItemDefaultFocus();
        PopID();
    }

    EndCombo();
    return value_changed;
}

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
{
    const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
    return value_changed;
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0" 
bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
{
    int items_count = 0;
    const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
    while (*p)
    {
        p += strlen(p) + 1;
        items_count++;
    }
    bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
    return value_changed;
}

// Tip: pass an empty label (e.g. "##dummy") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet) // FIXME-OPT: Avoid if vertically clipped.
        PopClipRect();

    ImGuiID id = window->GetID(label);
    ImVec2 label_size = CalcTextSize(label, NULL, true);
    ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
    ImVec2 pos = window->DC.CursorPos;
    pos.y += window->DC.CurrentLineTextBaseOffset;
    ImRect bb_inner(pos, pos + size);
    ItemSize(bb_inner);

    // Fill horizontal space.
    ImVec2 window_padding = window->WindowPadding;
    float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;
    float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - window->DC.CursorPos.x);
    ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);
    ImRect bb(pos, pos + size_draw);
    if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))
        bb.Max.x += window_padding.x;

    // Selectables are tightly packed together, we extend the box to cover spacing between selectable.
    float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);
    float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);
    float spacing_R = style.ItemSpacing.x - spacing_L;
    float spacing_D = style.ItemSpacing.y - spacing_U;
    bb.Min.x -= spacing_L;
    bb.Min.y -= spacing_U;
    bb.Max.x += spacing_R;
    bb.Max.y += spacing_D;
    if (!ItemAdd(bb, (flags & ImGuiSelectableFlags_Disabled) ? 0 : id))
    {
        if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
            PushColumnClipRect();
        return false;
    }

    // We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
    ImGuiButtonFlags button_flags = 0;
    if (flags & ImGuiSelectableFlags_NoHoldingActiveID) button_flags |= ImGuiButtonFlags_NoHoldingActiveID;
    if (flags & ImGuiSelectableFlags_PressedOnClick) button_flags |= ImGuiButtonFlags_PressedOnClick;
    if (flags & ImGuiSelectableFlags_PressedOnRelease) button_flags |= ImGuiButtonFlags_PressedOnRelease;
    if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;
    if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held, button_flags);
    if (flags & ImGuiSelectableFlags_Disabled)
        selected = false;

    // Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)
    if (pressed || hovered)
        if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerCurrent)
        {
            g.NavDisableHighlight = true;
            SetNavID(id, window->DC.NavLayerCurrent);
        }
    if (pressed)
        MarkItemEdited(id);

    // Render
    if (hovered || selected)
    {
        const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
        RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
        RenderNavHighlight(bb, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
    }

    if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
    {
        PushColumnClipRect();
        bb.Max.x -= (GetContentRegionMax().x - max_x);
    }

    if (flags & ImGuiSelectableFlags_Disabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
    RenderTextClipped(bb_inner.Min, bb.Max, label, NULL, &label_size, ImVec2(0.0f,0.0f));
    if (flags & ImGuiSelectableFlags_Disabled) PopStyleColor();

    // Automatically close popups
    if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))
        CloseCurrentPopup();
    return pressed;
}

bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
    if (Selectable(label, *p_selected, flags, size_arg))
    {
        *p_selected = !*p_selected;
        return true;
    }
    return false;
}

// FIXME: Rename to BeginListBox()
// Helper to calculate the size of a listbox and display a label on the right.
// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an empty label "##empty"
bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    const ImGuiStyle& style = GetStyle();
    const ImGuiID id = GetID(label);
    const ImVec2 label_size = CalcTextSize(label, NULL, true);

    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
    ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);
    ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
    ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
    ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
    window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

    BeginGroup();
    if (label_size.x > 0)
        RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

    BeginChildFrame(id, frame_bb.GetSize());
    return true;
}

// FIXME: Rename to BeginListBox()
bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)
{
    // Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
    // We don't add +0.40f if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
    // I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
    if (height_in_items < 0)
        height_in_items = ImMin(items_count, 7);
    float height_in_items_f = height_in_items < items_count ? (height_in_items + 0.40f) : (height_in_items + 0.00f);

    // We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
    ImVec2 size;
    size.x = 0.0f;
    size.y = GetTextLineHeightWithSpacing() * height_in_items_f + GetStyle().ItemSpacing.y;
    return ListBoxHeader(label, size);
}

// FIXME: Rename to EndListBox()
void ImGui::ListBoxFooter()
{
    ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;
    const ImRect bb = parent_window->DC.LastItemRect;
    const ImGuiStyle& style = GetStyle();

    EndChildFrame();

    // Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
    // We call SameLine() to restore DC.CurrentLine* data
    SameLine();
    parent_window->DC.CursorPos = bb.Min;
    ItemSize(bb, style.FramePadding.y);
    EndGroup();
}

bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)
{
    const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);
    return value_changed;
}

bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
{
    if (!ListBoxHeader(label, items_count, height_in_items))
        return false;

    // Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
    ImGuiContext& g = *GImGui;
    bool value_changed = false;
    ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
    while (clipper.Step())
        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
        {
            const bool item_selected = (i == *current_item);
            const char* item_text;
            if (!items_getter(data, i, &item_text))
                item_text = "*Unknown item*";

            PushID(i);
            if (Selectable(item_text, item_selected))
            {
                *current_item = i;
                value_changed = true;
            }
            if (item_selected)
                SetItemDefaultFocus();
            PopID();
        }
    ListBoxFooter();
    if (value_changed)
        MarkItemEdited(g.CurrentWindow->DC.LastItemId);

    return value_changed;
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    ImGuiStyle& style = g.Style;
    ImVec2 pos = window->DC.CursorPos;
    ImVec2 label_size = CalcTextSize(label, NULL, true);

    ImGuiSelectableFlags flags = ImGuiSelectableFlags_PressedOnRelease | (enabled ? 0 : ImGuiSelectableFlags_Disabled);
    bool pressed;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
        // Note that in this situation we render neither the shortcut neither the selected tick mark
        float w = label_size.x;
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);
        pressed = Selectable(label, false, flags, ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);
        float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));
        if (shortcut_size.x > 0.0f)
        {
            PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
            RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);
            PopStyleColor();
        }
        if (selected)
            RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize  * 0.866f);
    }
    return pressed;
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)
{
    if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled))
    {
        if (p_selected)
            *p_selected = !*p_selected;
        return true;
    }
    return false;
}

// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
bool ImGui::BeginMainMenuBar()
{
    ImGuiContext& g = *GImGui;
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0f));
    SetNextWindowPos(ImVec2(0.0f, 0.0f));
    SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.NextWindowData.MenuBarOffsetMinVal.y + g.FontBaseSize + g.Style.FramePadding.y));
    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
    PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0,0));
    ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar;
    bool is_open = Begin("##MainMenuBar", NULL, window_flags) && BeginMenuBar();
    PopStyleVar(2);
    g.NextWindowData.MenuBarOffsetMinVal = ImVec2(0.0f, 0.0f);
    if (!is_open)
    {
        End();
        return false;
    }
    return true;
}

void ImGui::EndMainMenuBar()
{
    EndMenuBar();

    // When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
    ImGuiContext& g = *GImGui;
    if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)
        FocusFrontMostActiveWindowIgnoringOne(g.NavWindow);

    End();
}

bool ImGui::BeginMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;
    if (!(window->Flags & ImGuiWindowFlags_MenuBar))
        return false;

    IM_ASSERT(!window->DC.MenuBarAppending);
    BeginGroup(); // Backup position on layer 0
    PushID("##menubar");

    // We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
    // We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
    ImRect bar_rect = window->MenuBarRect();
    ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));
    clip_rect.ClipWith(window->OuterRectClipped);
    PushClipRect(clip_rect.Min, clip_rect.Max, false);

    window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffset.x, bar_rect.Min.y + window->DC.MenuBarOffset.y);
    window->DC.LayoutType = ImGuiLayoutType_Horizontal;
    window->DC.NavLayerCurrent++;
    window->DC.NavLayerCurrentMask <<= 1;
    window->DC.MenuBarAppending = true;
    AlignTextToFramePadding();
    return true;
}

void ImGui::EndMenuBar()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
    if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
    {
        ImGuiWindow* nav_earliest_child = g.NavWindow;
        while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))
            nav_earliest_child = nav_earliest_child->ParentWindow;
        if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)
        {
            // To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
            // This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
            IM_ASSERT(window->DC.NavLayerActiveMaskNext & 0x02); // Sanity check
            FocusWindow(window);
            SetNavIDWithRectRel(window->NavLastIds[1], 1, window->NavRectRel[1]);
            g.NavLayer = 1;
            g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
            g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
            NavMoveRequestCancel();
        }
    }

    IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
    IM_ASSERT(window->DC.MenuBarAppending);
    PopClipRect();
    PopID();
    window->DC.MenuBarOffset.x = window->DC.CursorPos.x - window->MenuBarRect().Min.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.
    window->DC.GroupStack.back().AdvanceCursor = false;
    EndGroup(); // Restore position on layer 0
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    window->DC.NavLayerCurrent--;
    window->DC.NavLayerCurrentMask >>= 1;
    window->DC.MenuBarAppending = false;
}

bool ImGui::BeginMenu(const char* label, bool enabled)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const ImGuiID id = window->GetID(label);

    ImVec2 label_size = CalcTextSize(label, NULL, true);

    bool pressed;
    bool menu_is_open = IsPopupOpen(id);
    bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].OpenParentId == window->IDStack.back());
    ImGuiWindow* backed_nav_window = g.NavWindow;
    if (menuset_is_open)
        g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

    // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu (using FindBestWindowPosForPopup).
    ImVec2 popup_pos, pos = window->DC.CursorPos;
    if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
    {
        // Menu inside an horizontal menu bar
        // Selectable extend their highlight by half ItemSpacing in each direction.
        // For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
        popup_pos = ImVec2(pos.x - window->WindowPadding.x, pos.y - style.FramePadding.y + window->MenuBarHeight());
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
        PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);
        float w = label_size.x;
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        PopStyleVar();
        window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
    }
    else
    {
        // Menu inside a menu
        popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
        float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame
        float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
        pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlags_PressedOnClick | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
        if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
        RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);
        if (!enabled) PopStyleColor();
    }

    const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);
    if (menuset_is_open)
        g.NavWindow = backed_nav_window;

    bool want_open = false, want_close = false;
    if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
    {
        // Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
        bool moving_within_opened_triangle = false;
        if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))
        {
            if (ImGuiWindow* next_window = g.OpenPopupStack[g.CurrentPopupStack.Size].Window)
            {
                ImRect next_window_rect = next_window->Rect();
                ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;
                ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();
                ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();
                float extra = ImClamp(ImFabs(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.
                ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;   // to avoid numerical issues
                tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);            // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
                tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);
                moving_within_opened_triangle = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
                //window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug
            }
        }

        want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);
        want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);

        if (g.NavActivateId == id)
        {
            want_close = menu_is_open;
            want_open = !menu_is_open;
        }
        if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }
    else
    {
        // Menu bar
        if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it
        {
            want_close = true;
            want_open = menu_is_open = false;
        }
        else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others
        {
            want_open = true;
        }
        else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open
        {
            want_open = true;
            NavMoveRequestCancel();
        }
    }

    if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
        want_close = true;
    if (want_close && IsPopupOpen(id))
        ClosePopupToLevel(g.CurrentPopupStack.Size);

    if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.CurrentPopupStack.Size)
    {
        // Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
        OpenPopup(label);
        return false;
    }

    menu_is_open |= want_open;
    if (want_open)
        OpenPopup(label);

    if (menu_is_open)
    {
        // Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
        SetNextWindowPos(popup_pos, ImGuiCond_Always);
        ImGuiWindowFlags flags = ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus;
        if (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
            flags |= ImGuiWindowFlags_ChildWindow;
        menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    }

    return menu_is_open;
}

void ImGui::EndMenu()
{
    // Nav: When a left move request _within our child menu_ failed, close the menu.
    // A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
    // However, it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)
    {
        ClosePopupToLevel(g.OpenPopupStack.Size - 1);
        NavMoveRequestCancel();
    }

    EndPopup();
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;

    int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
    BeginTooltipEx(0, true);

    const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;
    if (text_end > text)
    {
        TextUnformatted(text, text_end);
        Separator();
    }

    ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
    ColorButton(XorString("##preview"), ImVec4(col[0], col[1], col[2], col[3]), (flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
    SameLine();
    if (flags & ImGuiColorEditFlags_NoAlpha)
        Text(XorString("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)"), cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);
    else
        Text(XorString("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)"), cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
    EndTooltip();
}

static inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)
{
    float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
    int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
    int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
    int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
    return IM_COL32(r, g, b, 0xFF);
}

// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.
void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)
    {
        ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204,204,204,255), col));
        ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128,128,128,255), col));
        window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);

        int yi = 0;
        for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
        {
            float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
            if (y2 <= y1)
                continue;
            for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)
            {
                float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
                if (x2 <= x1)
                    continue;
                int rounding_corners_flags_cell = 0;
                if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }
                if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }
                rounding_corners_flags_cell &= rounding_corners_flags;
                window->DrawList->AddRectFilled(ImVec2(x1,y1), ImVec2(x2,y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);
            }
        }
    }
    else
    {
        window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);
    }
}

void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)
{
    ImGuiContext& g = *GImGui;
    if ((flags & ImGuiColorEditFlags__InputsMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputsMask;
    if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;
    if ((flags & ImGuiColorEditFlags__PickerMask) == 0)
        flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask)));   // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))); // Check only 1 option is selected
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask)));   // Check only 1 option is selected
    g.ColorEditOptions = flags;
}

// A little colored square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiID id = window->GetID(desc_id);
    float default_size = GetFrameHeight();
    if (size.x == 0.0f)
        size.x = default_size;
    if (size.y == 0.0f)
        size.y = default_size;
    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
    if (!ItemAdd(bb, id))
        return false;

    bool hovered, held;
    bool pressed = ButtonBehavior(bb, id, &hovered, &held);

    if (flags & ImGuiColorEditFlags_NoAlpha)
        flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

    ImVec4 col_without_alpha(col.x, col.y, col.z, 1.0f);
    float grid_step = ImMin(size.x, size.y) / 2.99f;
    float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
    ImRect bb_inner = bb;
    float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
    bb_inner.Expand(off);
    if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col.w < 1.0f)
    {
        float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);
        RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight| ImDrawCornerFlags_BotRight);
        window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_without_alpha), rounding, ImDrawCornerFlags_TopLeft|ImDrawCornerFlags_BotLeft);
    }
    else
    {
        // Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
        ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col : col_without_alpha;
        if (col_source.w < 1.0f)
            RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
        else
            window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);
    }
    RenderNavHighlight(bb, id);
    if (g.Style.FrameBorderSize > 0.0f)
        RenderFrameBorder(bb.Min, bb.Max, rounding);
    else
        window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

    // Drag and Drop Source
    // NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
    if (g.ActiveId == id && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropSource())
    {
        if (flags & ImGuiColorEditFlags_NoAlpha)
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col, sizeof(float) * 3, ImGuiCond_Once);
        else
            SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col, sizeof(float) * 4, ImGuiCond_Once);
        ColorButton(desc_id, col, flags);
        SameLine();
        TextUnformatted(XorString("Color"));
        EndDragDropSource();
    }

    // Tooltip
    if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)
        ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

    if (pressed)
        MarkItemEdited(id);

    return pressed;
}

bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
}

void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)
{
    bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__InputsMask);
    bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);
    if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup(XorString("context")))
        return;
    ImGuiContext& g = *GImGui;
    ImGuiColorEditFlags opts = g.ColorEditOptions;
    if (allow_opt_inputs)
    {
        if (RadioButton(XorString("RGB"), (opts & ImGuiColorEditFlags_RGB) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_RGB;
        if (RadioButton(XorString("HSV"), (opts & ImGuiColorEditFlags_HSV) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HSV;
        if (RadioButton(XorString("HEX"), (opts & ImGuiColorEditFlags_HEX) != 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HEX;
    }
    if (allow_opt_datatype)
    {
        if (allow_opt_inputs) Separator();
        if (RadioButton(XorString("0..255"),     (opts & ImGuiColorEditFlags_Uint8) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;
        if (RadioButton(XorString("0.00..1.00"), (opts & ImGuiColorEditFlags_Float) != 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;
    }

    if (allow_opt_inputs || allow_opt_datatype)
        Separator();
    if (Button(XorString("Copy as.."), ImVec2(-1,0)))
        OpenPopup(XorString("Copy"));
    if (BeginPopup(XorString("Copy")))
    {
        int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
        char buf[64];
        ImFormatString(buf, IM_ARRAYSIZE(buf), XorString("(%.3ff, %.3ff, %.3ff, %.3ff)"), col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if (Selectable(buf))
            SetClipboardText(buf);
        ImFormatString(buf, IM_ARRAYSIZE(buf), XorString("(%d,%d,%d,%d)"), cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        if (flags & ImGuiColorEditFlags_NoAlpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), XorString("0x%02X%02X%02X"), cr, cg, cb);
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), XorString("0x%02X%02X%02X%02X"), cr, cg, cb, ca);
        if (Selectable(buf))
            SetClipboardText(buf);
        EndPopup();
    }

    g.ColorEditOptions = opts;
    EndPopup();
}

void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)
{
    bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);
    bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);
    if ((!allow_opt_picker && !allow_opt_alpha_bar) || !ImGui::BeginPopup(XorString("context")))
        return;
    ImGuiContext& g = *GImGui;
    if (allow_opt_picker)
    {
        ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (ImGui::GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
        ImGui::PushItemWidth(picker_size.x);
        for (int picker_type = 0; picker_type < 2; picker_type++)
        {
            // Draw small/thumbnail version of each picker type (over an invisible button for selection)
            if (picker_type > 0) ImGui::Separator();
            ImGui::PushID(picker_type);
            ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs|ImGuiColorEditFlags_NoOptions|ImGuiColorEditFlags_NoLabel|ImGuiColorEditFlags_NoSidePreview|(flags & ImGuiColorEditFlags_NoAlpha);
            if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
            if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
            ImVec2 backup_pos = ImGui::GetCursorScreenPos();
            if (ImGui::Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
                g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);
            ImGui::SetCursorScreenPos(backup_pos);
            ImVec4 dummy_ref_col;
            memcpy(&dummy_ref_col.x, ref_col, sizeof(float) * (picker_flags & ImGuiColorEditFlags_NoAlpha ? 3 : 4));
            ImGui::ColorPicker4("##dummypicker", &dummy_ref_col.x, picker_flags);
            ImGui::PopID();
        }
        ImGui::PopItemWidth();
    }
    if (allow_opt_alpha_bar)
    {
        if (allow_opt_picker) ImGui::Separator();
        ImGui::CheckboxFlags("Alpha Bar", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
    }
    ImGui::EndPopup();
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return false;

    ImGuiContext& g = *GImGui;
    const ImGuiStyle& style = g.Style;
    const float square_sz = GetFrameHeight();
    const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
    const float w_items_all = CalcItemWidth() - w_extra;
    const char* label_display_end = FindRenderedTextEnd(label);

    BeginGroup();
    PushID(label);

    // If we're not showing any slider there's no point in doing any HSV conversions
    const ImGuiColorEditFlags flags_untouched = flags;
    if (flags & ImGuiColorEditFlags_NoInputs)
        flags = (flags & (~ImGuiColorEditFlags__InputsMask)) | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_NoOptions;

    // Context menu: display and modify options (before defaults are applied)
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        ColorEditOptionsPopup(col, flags);

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__InputsMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputsMask);
    if (!(flags & ImGuiColorEditFlags__DataTypeMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);
    flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask));

    const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
    const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
    const int components = alpha ? 4 : 3;

    // Convert to the formats we need
    float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
    if (flags & ImGuiColorEditFlags_HSV)
        ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
    int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

    bool value_changed = false;
    bool value_changed_as_float = false;

    if ((flags & (ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB/HSV 0..255 Sliders
        const float w_item_one  = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components-1)) / (float)components));
        const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components-1)));

        const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? XorString("M:0.000") : XorString("M:000")).x);
        const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
        const char* fmt_table_int[3][4] =
        {
            {   "%3d",   "%3d",   "%3d",   "%3d" }, // Short display
            { "R:%3d", "G:%3d", "B:%3d", "A:%3d" }, // Long display for RGBA
            { "H:%3d", "S:%3d", "V:%3d", "A:%3d" }  // Long display for HSVA
        };
        const char* fmt_table_float[3][4] =
        {
            {   "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
            { "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
            { "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
        };
        const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_HSV) ? 2 : 1;

        PushItemWidth(w_item_one);
        for (int n = 0; n < components; n++)
        {
            if (n > 0)
                SameLine(0, style.ItemInnerSpacing.x);
            if (n + 1 == components)
                PushItemWidth(w_item_last);
            if (flags & ImGuiColorEditFlags_Float)
                value_changed = value_changed_as_float = value_changed | DragFloat(ids[n], &f[n], 1.0f/255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
            else
                value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);
            if (!(flags & ImGuiColorEditFlags_NoOptions))
                OpenPopupOnItemClick(XorString("context"));
        }
        PopItemWidth();
        PopItemWidth();
    }
    else if ((flags & ImGuiColorEditFlags_HEX) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        // RGB Hexadecimal Input
        char buf[64];
        if (alpha)
            ImFormatString(buf, IM_ARRAYSIZE(buf), XorString("#%02X%02X%02X%02X"), ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255), ImClamp(i[3],0,255));
        else
            ImFormatString(buf, IM_ARRAYSIZE(buf), XorString("#%02X%02X%02X"), ImClamp(i[0],0,255), ImClamp(i[1],0,255), ImClamp(i[2],0,255));
        PushItemWidth(w_items_all);
        if (InputText(XorString("##Text"), buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))
        {
            value_changed = true;
            char* p = buf;
            while (*p == '#' || ImCharIsBlankA(*p))
                p++;
            i[0] = i[1] = i[2] = i[3] = 0;
            if (alpha)
                sscanf(p, XorString("%02X%02X%02X%02X"), (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)
            else
                sscanf(p, XorString("%02X%02X%02X"), (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick(XorString("context"));
        PopItemWidth();
    }

    ImGuiWindow* picker_active_window = NULL;
    if (!(flags & ImGuiColorEditFlags_NoSmallPreview))
    {
        if (!(flags & ImGuiColorEditFlags_NoInputs))
            SameLine(0, style.ItemInnerSpacing.x);

        const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
        if (ColorButton(XorString("##ColorButton"), col_v4, flags))
        {
            if (!(flags & ImGuiColorEditFlags_NoPicker))
            {
                // Store current color and open a picker
                g.ColorPickerRef = col_v4;
                OpenPopup(XorString("picker"));
                SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1,style.ItemSpacing.y));
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick(XorString("context"));

        if (BeginPopup(XorString("picker")))
        {
            picker_active_window = g.CurrentWindow;
            if (label != label_display_end)
            {
                TextUnformatted(label, label_display_end);
                Separator();
            }
            ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
            ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
            PushItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
            value_changed |= ColorPicker4(XorString("##picker"), col, picker_flags, &g.ColorPickerRef.x);
            PopItemWidth();
            EndPopup();
        }
    }

    if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        TextUnformatted(label, label_display_end);
    }

    // Convert back
    if (picker_active_window == NULL)
    {
        if (!value_changed_as_float)
            for (int n = 0; n < 4; n++)
                f[n] = i[n] / 255.0f;
        if (flags & ImGuiColorEditFlags_HSV)
            ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
        if (value_changed)
        {
            col[0] = f[0];
            col[1] = f[1];
            col[2] = f[2];
            if (alpha)
                col[3] = f[3];
        }
    }

    PopID();
    EndGroup();

    // Drag and Drop Target
    // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
    if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && !(flags & ImGuiColorEditFlags_NoDragDrop) && BeginDragDropTarget())
    {
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * 3);
            value_changed = true;
        }
        if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
        {
            memcpy((float*)col, payload->Data, sizeof(float) * components);
            value_changed = true;
        }
        EndDragDropTarget();
    }

    // When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
    if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)
        window->DC.LastItemId = g.ActiveId;

    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    return value_changed;
}

bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
    float col4[4] = { col[0], col[1], col[2], 1.0f };
    if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
        return false;
    col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];
    return true;
}

static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)
{
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x + 1,         pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + half_sz.x,             pos.y), half_sz,                              ImGuiDir_Right, IM_COL32_WHITE);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left,  IM_COL32_BLACK);
    ImGui::RenderArrowPointingAt(draw_list, ImVec2(pos.x + bar_w - half_sz.x,     pos.y), half_sz,                              ImGuiDir_Left,  IM_COL32_WHITE);
}

// ColorPicker
// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImDrawList* draw_list = window->DrawList;

    ImGuiStyle& style = g.Style;
    ImGuiIO& io = g.IO;

    PushID(label);
    BeginGroup();

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
        flags |= ImGuiColorEditFlags_NoSmallPreview;

    // Context menu: display and store options.
    if (!(flags & ImGuiColorEditFlags_NoOptions))

    // Read stored options
    if (!(flags & ImGuiColorEditFlags__PickerMask))
        flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))); // Check that only 1 is selected
    if (!(flags & ImGuiColorEditFlags_NoOptions))
        flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

    // Setup
    int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
    bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);
    ImVec2 picker_pos = window->DC.CursorPos;
    float square_sz = GetFrameHeight();
    float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
    float sv_picker_size = ImMax(bars_width * 1, CalcItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
    float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
    float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
    float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);

    float backup_initial_col[4];
    memcpy(backup_initial_col, col, components * sizeof(float));

    float wheel_thickness = sv_picker_size * 0.08f;
    float wheel_r_outer = sv_picker_size * 0.50f;
    float wheel_r_inner = wheel_r_outer - wheel_thickness;
    ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width)*0.5f, picker_pos.y + sv_picker_size*0.5f);

    // Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
    float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
    ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
    ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
    ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

    float H,S,V;
    ColorConvertRGBtoHSV(col[0], col[1], col[2], H, S, V);

    bool value_changed = false, value_changed_h = false, value_changed_sv = false;

    PushItemFlag(ImGuiItemFlags_NoNav, true);
    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Hue wheel + SV triangle logic
        InvisibleButton(XorString("hsv"), ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
        if (IsItemActive())
        {
            ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
            ImVec2 current_off = g.IO.MousePos - wheel_center;
            float initial_dist2 = ImLengthSqr(initial_off);
            if (initial_dist2 >= (wheel_r_inner-1)*(wheel_r_inner-1) && initial_dist2 <= (wheel_r_outer+1)*(wheel_r_outer+1))
            {
                // Interactive with Hue wheel
                H = ImAtan2(current_off.y, current_off.x) / IM_PI*0.5f;
                if (H < 0.0f)
                    H += 1.0f;
                value_changed = value_changed_h = true;
            }
            float cos_hue_angle = ImCos(-H * 2.0f * IM_PI);
            float sin_hue_angle = ImSin(-H * 2.0f * IM_PI);
            if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))
            {
                // Interacting with SV triangle
                ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
                if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
                    current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
                float uu, vv, ww;
                ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
                V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
                S = ImClamp(uu / V, 0.0001f, 1.0f);
                value_changed = value_changed_sv = true;
            }
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick(XorString("context"));
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // SV rectangle logic
        InvisibleButton(XorString("sv"), ImVec2(sv_picker_size, sv_picker_size));
        if (IsItemActive())
        {
            S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size-1));
            V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_sv = true;
        }
        if (!(flags & ImGuiColorEditFlags_NoOptions))
            OpenPopupOnItemClick(XorString("context"));

        // Hue bar logic
        SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
        InvisibleButton(XorString("hue"), ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = value_changed_h = true;
        }
    }

    // Alpha bar logic
    if (alpha_bar)
    {
        SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
        InvisibleButton(XorString("alpha"), ImVec2(bars_width, sv_picker_size));
        if (IsItemActive())
        {
            col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size-1));
            value_changed = true;
        }
    }
    PopItemFlag(); // ImGuiItemFlags_NoNav

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        SameLine(0, style.ItemInnerSpacing.x);
        BeginGroup();
    }

    if (!(flags & ImGuiColorEditFlags_NoLabel))
    {
        const char* label_display_end = FindRenderedTextEnd(label);
        if (label != label_display_end)
        {
            if ((flags & ImGuiColorEditFlags_NoSidePreview))
                SameLine(0, style.ItemInnerSpacing.x);
            TextUnformatted(label, label_display_end);
        }
    }

    if (!(flags & ImGuiColorEditFlags_NoSidePreview))
    {
        PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
        ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
        if ((flags & ImGuiColorEditFlags_NoLabel))
            Text(XorString(u8"eC"));
        ColorButton(XorString("##current"), col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2));
        if (ref_col != NULL)
        {
            Text(XorString(u8"C"));
            ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
            if (ColorButton(XorString("##original"), ref_col_v4, (flags & (ImGuiColorEditFlags_HDR|ImGuiColorEditFlags_AlphaPreview|ImGuiColorEditFlags_AlphaPreviewHalf|ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2)))
            {
                memcpy(col, ref_col, components * sizeof(float));
                value_changed = true;
            }
        }
        PopItemFlag();
        EndGroup();
    }

    // Convert back color to RGB
    if (value_changed_h || value_changed_sv)
        ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10*1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);

    // R,G,B and H,S,V slider color editor
    bool value_changed_fix_hue_wrap = false;
    if ((flags & ImGuiColorEditFlags_NoInputs) == 0)
    {
        PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
        ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
        ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
        if (flags & ImGuiColorEditFlags_RGB || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            if (ColorEdit4(XorString("##rgb"), col, sub_flags | ImGuiColorEditFlags_RGB))
            {
                // FIXME: Hackily differenciating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
                // For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
                value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap);
                value_changed = true;
            }
        if (flags & ImGuiColorEditFlags_HSV || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            value_changed |= ColorEdit4(XorString("##hsv"), col, sub_flags | ImGuiColorEditFlags_HSV);
        if (flags & ImGuiColorEditFlags_HEX || (flags & ImGuiColorEditFlags__InputsMask) == 0)
            value_changed |= ColorEdit4(XorString("##hex"), col, sub_flags | ImGuiColorEditFlags_HEX);
        PopItemWidth();
    }

    // Try to cancel hue wrap (after ColorEdit4 call), if any
    if (value_changed_fix_hue_wrap)
    {
        float new_H, new_S, new_V;
        ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
        if (new_H <= 0 && H > 0)
        {
            if (new_V <= 0 && V != new_V)
                ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
            else if (new_S <= 0)
                ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);
        }
    }

    ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
    ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
    ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 1.0f));

    const ImU32 hue_colors[6+1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };
    ImVec2 sv_cursor_pos;

    if (flags & ImGuiColorEditFlags_PickerHueWheel)
    {
        // Render Hue Wheel
        const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
        const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
        for (int n = 0; n < 6; n++)
        {
            const float a0 = (n)     /6.0f * 2.0f * IM_PI - aeps;
            const float a1 = (n+1.0f)/6.0f * 2.0f * IM_PI + aeps;
            const int vert_start_idx = draw_list->VtxBuffer.Size;
            draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer)*0.5f, a0, a1, segment_per_arc);
            draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);
            const int vert_end_idx = draw_list->VtxBuffer.Size;

            // Paint colors over existing vertices
            ImVec2 gradient_p0(wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner);
            ImVec2 gradient_p1(wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner);
            ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n+1]);
        }

        // Render Cursor + preview on Hue Wheel
        float cos_hue_angle = ImCos(H * 2.0f * IM_PI);
        float sin_hue_angle = ImSin(H * 2.0f * IM_PI);
        ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner+wheel_r_outer)*0.5f);
        float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
        int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);
        draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad+1, IM_COL32(128,128,128,255), hue_cursor_segments);
        draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);

        // Render SV triangle (rotated according to hue)
        ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
        ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
        ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
        ImVec2 uv_white = GetFontTexUvWhitePixel();
        draw_list->PrimReserve(6, 6);
        draw_list->PrimVtx(tra, uv_white, hue_color32);
        draw_list->PrimVtx(trb, uv_white, hue_color32);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);
        draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);
        draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);
        draw_list->AddTriangle(tra, trb, trc, IM_COL32(128,128,128,255), 1.5f);
        sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
    }
    else if (flags & ImGuiColorEditFlags_PickerHueBar)
    {
        // Render SV Square
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);
        draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);
        RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size,sv_picker_size), 0.0f);
        sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S)     * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
        sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

        // Render Hue Bar
        for (int i = 0; i < 6; ++i)
            draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);
        float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);
        RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    // Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
    float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
    draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad+1, IM_COL32(128,128,128,255), 12);
    draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);

    // Render alpha bar
    if (alpha_bar)
    {
        float alpha = ImSaturate(col[3]);
        ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
        RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0,0,0,0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
        draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);
        float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);
        RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
        RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
    }

    EndGroup();

    if (value_changed && memcmp(backup_initial_col, col, components * sizeof(float)) == 0)
        value_changed = false;
    if (value_changed)
        MarkItemEdited(window->DC.LastItemId);

    PopID();

    return value_changed;
}

// Horizontal/vertical separating line
void ImGui::Separator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    // Those flags should eventually be overridable by the user
    ImGuiSeparatorFlags flags = (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
    IM_ASSERT(ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))));   // Check that only 1 option is selected
    if (flags & ImGuiSeparatorFlags_Vertical)
    {
        VerticalSeparator();
        return;
    }

    // Horizontal Separator
    if (window->DC.ColumnsSet)
        PopClipRect();

    float x1 = window->Pos.x;
    float x2 = window->Pos.x + window->Size.x;
    if (!window->DC.GroupStack.empty())
        x1 += window->DC.Indent.x;

    const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y+1.0f));
    ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.
    if (!ItemAdd(bb, 0))
    {
        if (window->DC.ColumnsSet)
            PushColumnClipRect();
        return;
    }

    window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x,bb.Min.y), GetColorU32(ImGuiCol_Separator));
    if (g.LogEnabled)
            LogRenderedText(NULL, /*IM_NEWLINE*/ XorString("\r\n --------------------------------"));

    if (window->DC.ColumnsSet)
    {
        PushColumnClipRect();
        window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;
    }
}

void ImGui::VerticalSeparator()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ImGuiContext& g = *GImGui;

    float y1 = window->DC.CursorPos.y;
    float y2 = window->DC.CursorPos.y + window->DC.CurrentLineSize.y;
    const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));
    ItemSize(ImVec2(bb.GetWidth(), 0.0f));
    if (!ItemAdd(bb, 0))
        return;

    window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));
    if (g.LogEnabled)
        LogText(" |");
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
bool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
    window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;
    bool item_add = ItemAdd(bb, id);
    window->DC.ItemFlags = item_flags_backup;
    if (!item_add)
        return false;

    bool hovered, held;
    ImRect bb_interact = bb;
    bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
    ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);
    if (g.ActiveId != id)
        SetItemAllowOverlap();

    if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay))
        SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

    ImRect bb_render = bb;
    if (held)
    {
        ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;
        float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

        // Minimum pane size
        float size_1_maximum_delta = ImMax(0.0f, *size1 - min_size1);
        float size_2_maximum_delta = ImMax(0.0f, *size2 - min_size2);
        if (mouse_delta < -size_1_maximum_delta)
            mouse_delta = -size_1_maximum_delta;
        if (mouse_delta > size_2_maximum_delta)
            mouse_delta = size_2_maximum_delta;

        // Apply resize
        if (mouse_delta != 0.0f)
        {
            if (mouse_delta < 0.0f)
                IM_ASSERT(*size1 + mouse_delta >= min_size1);
            if (mouse_delta > 0.0f)
               IM_ASSERT(*size2 - mouse_delta >= min_size2);
            *size1 += mouse_delta;
            *size2 -= mouse_delta;
            bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
            MarkItemEdited(id);
        }
    }

    // Render
    const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
    window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);

    return held;
}

void ImGui::Spacing()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;
    ItemSize(ImVec2(0,0));
}

void ImGui::Dummy(const ImVec2& size)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
    ItemSize(bb);
    ItemAdd(bb, 0);
}

bool ImGui::IsRectVisible(const ImVec2& size)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
void ImGui::BeginGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);
    ImGuiGroupData& group_data = window->DC.GroupStack.back();
    group_data.BackupCursorPos = window->DC.CursorPos;
    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    group_data.BackupIndent = window->DC.Indent;
    group_data.BackupGroupOffset = window->DC.GroupOffset;
    group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;
    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;
    group_data.BackupLogLinePosY = window->DC.LogLinePosY;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.AdvanceCursor = true;

    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    window->DC.Indent = window->DC.GroupOffset;
    window->DC.CursorMaxPos = window->DC.CursorPos;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return
}

void ImGui::EndGroup()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(!window->DC.GroupStack.empty());    // Mismatched BeginGroup()/EndGroup() calls

    ImGuiGroupData& group_data = window->DC.GroupStack.back();

    ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);
    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

    window->DC.CursorPos = group_data.BackupCursorPos;
    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    window->DC.Indent = group_data.BackupIndent;
    window->DC.GroupOffset = group_data.BackupGroupOffset;
    window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;
    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
    window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f; // To enforce Log carriage return

    if (group_data.AdvanceCursor)
    {
        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
        ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);
        ItemAdd(group_bb, 0);
    }

    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
    // (and if you grep for LastItemId you'll notice it is only used in that context.
    if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveId;
    else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveIdPreviousFrame;
    window->DC.LastItemRect = group_bb;

    window->DC.GroupStack.pop_back();

    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}

// Gets back to previous line and continue with horizontal layout
//      pos_x == 0      : follow right after previous item
//      pos_x != 0      : align to specified x position (relative to window/group left)
//      spacing_w < 0   : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0  : enforce spacing amount
void ImGui::SameLine(float pos_x, float spacing_w)
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    if (pos_x != 0.0f)
    {
        if (spacing_w < 0.0f) spacing_w = 0.0f;
        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    else
    {
        if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;
        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
    window->DC.CurrentLineSize = window->DC.PrevLineSize;
    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

void ImGui::NewLine()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems)
        return;

    ImGuiContext& g = *GImGui;
    const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
    window->DC.LayoutType = ImGuiLayoutType_Vertical;
    if (window->DC.CurrentLineSize.y > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
        ItemSize(ImVec2(0,0));
    else
        ItemSize(ImVec2(0.0f, g.FontSize));
    window->DC.LayoutType = backup_layout_type;
}

void ImGui::NextColumn()
{
    ImGuiWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.ColumnsSet == NULL)
        return;

    ImGuiContext& g = *GImGui;
    PopItemWidth();
    PopClipRect();

    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (++columns->Current < columns->Count)
    {
        // Columns 1+ cancel out IndentX
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;
        window->DrawList->ChannelsSetCurrent(columns->Current);
    }
    else
    {
        window->DC.ColumnsOffset.x = 0.0f;
        window->DrawList->ChannelsSetCurrent(0);
        columns->Current = 0;
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrentLineSize = ImVec2(0.0f, 0.0f);
    window->DC.CurrentLineTextBaseOffset = 0.0f;

    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup
}

int ImGui::GetColumnIndex()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Current : 0;
}

int ImGui::GetColumnsCount()
{
    ImGuiWindow* window = GetCurrentWindowRead();
    return window->DC.ColumnsSet ? window->DC.ColumnsSet->Count : 1;
}

static float OffsetNormToPixels(const ImGuiColumnsSet* columns, float offset_norm)
{
    return offset_norm * (columns->MaxX - columns->MinX);
}

static float PixelsToOffsetNorm(const ImGuiColumnsSet* columns, float offset)
{
    return offset / (columns->MaxX - columns->MinX);
}

static inline float GetColumnsRectHalfWidth() { return 4.0f; }

static float GetDraggedColumnOffset(ImGuiColumnsSet* columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + GetColumnsRectHalfWidth() - window->Pos.x;
    x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))
        x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float ImGui::GetColumnOffset(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(ImGuiColumnsSet* columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return OffsetNormToPixels(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count-1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
    ImGuiWindow* window = GetCurrentWindowRead();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    if (column_index < 0)
        column_index = columns->Current;

    PushClipRect(columns->Columns[column_index].ClipRect.Min, columns->Columns[column_index].ClipRect.Max, false);
}

static ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow* window, ImGuiID id)
{
    for (int n = 0; n < window->ColumnsStorage.Size; n++)
        if (window->ColumnsStorage[n].ID == id)
            return &window->ColumnsStorage[n];

    window->ColumnsStorage.push_back(ImGuiColumnsSet());
    ImGuiColumnsSet* columns = &window->ColumnsStorage.back();
    columns->ID = id;
    return columns;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count > 1);
    IM_ASSERT(window->DC.ColumnsSet == NULL); // Nested columns are currently not supported

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    ImGuiID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    // Acquire storage for the columns set
    ImGuiColumnsSet* columns = FindOrAddColumnsSet(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.ColumnsSet = columns;

    // Set state for first column
    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);
    columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range
    columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);
    columns->StartPosY = window->DC.CursorPos.y;
    columns->StartMaxPosX = window->DC.CursorMaxPos.x;
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize defaults
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            ImGuiColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        ImGuiColumnData* column = &columns->Columns[n];
        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n) - 1.0f);
        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWith(window->ClipRect);
    }

    window->DrawList->ChannelsSplit(columns->Count);
    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);
}

void ImGui::EndColumns()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    ImGuiColumnsSet* columns = window->DC.ColumnsSet;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    PopClipRect();
    window->DrawList->ChannelsMerge();

    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->StartMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    bool is_being_resized = false;
    if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)
    {
        const float y1 = columns->StartPosY;
        const float y2 = window->DC.CursorPos.y;
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            float x = window->Pos.x + GetColumnOffset(n);
            const ImGuiID column_id = columns->ID + ImGuiID(n);
            const float column_hw = GetColumnsRectHalfWidth(); // Half-width for interaction
            const ImRect column_rect(ImVec2(x - column_hw, y1), ImVec2(x + column_hw, y2));
            KeepAliveID(column_id);
            if (IsClippedEx(column_rect, column_id, false))
                continue;

            bool hovered = false, held = false;
            if (!(columns->Flags & ImGuiColumnsFlags_NoResize))
            {
                ButtonBehavior(column_rect, column_id, &hovered, &held);
                if (hovered || held)
                    g.MouseCursor = ImGuiMouseCursor_ResizeEW;
                if (held && !(columns->Columns[n].Flags & ImGuiColumnsFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column (we clip the Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.)
            const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
            const float xi = (float)(int)x;
            window->DrawList->AddLine(ImVec2(xi, ImMax(y1 + 1.0f, window->ClipRect.Min.y)), ImVec2(xi, ImMin(y2, window->ClipRect.Max.y)), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->DC.ColumnsSet = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
}

// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]
void ImGui::Columns(int columns_count, const char* id, bool border)
{
    ImGuiWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);
    //flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
    if (window->DC.ColumnsSet != NULL && window->DC.ColumnsSet->Count == columns_count && window->DC.ColumnsSet->Flags == flags)
        return;

    if (window->DC.ColumnsSet != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

void ImGui::Indent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::Unindent(float indent_w)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = GetCurrentWindow();
    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void ImGui::TreePush(const char* str_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(str_id ? str_id : "#TreePush");
}

void ImGui::TreePush(const void* ptr_id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    PushID(ptr_id ? ptr_id : (const void*)"#TreePush");
}

void ImGui::TreePushRawID(ImGuiID id)
{
    ImGuiWindow* window = GetCurrentWindow();
    Indent();
    window->DC.TreeDepth++;
    window->IDStack.push_back(id);
}

void ImGui::TreePop()
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    Unindent();

    window->DC.TreeDepth--;
    if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
        if (g.NavIdIsAlive && (window->DC.TreeDepthMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))
        {
            SetNavID(window->IDStack.back(), g.NavLayer);
            NavMoveRequestCancel();
        }
    window->DC.TreeDepthMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;

    IM_ASSERT(window->IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
    PopID();
}

void ImGui::Value(const char* prefix, bool b)
{
    Text("%s: %s", prefix, (b ? "true" : "false"));
}

void ImGui::Value(const char* prefix, int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, unsigned int v)
{
    Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, float v, const char* float_format)
{
    if (float_format)
    {
        char fmt[64];
        ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
        Text(fmt, prefix, v);
    }
    else
    {
        Text("%s: %.3f", prefix, v);
    }
}

//-----------------------------------------------------------------------------
// DRAG AND DROP
//-----------------------------------------------------------------------------

void ImGui::ClearDragDrop()
{
    ImGuiContext& g = *GImGui;
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = 0;
    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

// Call when current ID is active.
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;

    bool source_drag_active = false;
    ImGuiID source_id = 0;
    ImGuiID source_parent_id = 0;
    int mouse_button = 0;
    if (!(flags & ImGuiDragDropFlags_SourceExtern))
    {
        source_id = window->DC.LastItemId;
        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case
            return false;
        if (g.IO.MouseDown[mouse_button] == false)
            return false;

        if (source_id == 0)
        {
            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
            if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
            {
                IM_ASSERT(0);
                return false;
            }

            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
            bool is_hovered = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) != 0;
            if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))
                return false;
            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);
            if (is_hovered)
                SetHoveredID(source_id);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
                g.ActiveIdAllowOverlap = is_hovered;
        }
        else
        {
            g.ActiveIdAllowOverlap = false;
        }
        if (g.ActiveId != source_id)
            return false;
        source_parent_id = window->IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);
    }
    else
    {
        window = NULL;
        source_id = ImHash(XorString("#SourceExtern"), 0);
        source_drag_active = true;
    }

    if (source_drag_active)
    {
        if (!g.DragDropActive)
        {
            IM_ASSERT(source_id != 0);
            ClearDragDrop();
            ImGuiPayload& payload = g.DragDropPayload;
            payload.SourceId = source_id;
            payload.SourceParentId = source_parent_id;
            g.DragDropActive = true;
            g.DragDropSourceFlags = flags;
            g.DragDropMouseButton = mouse_button;
        }
        g.DragDropSourceFrameCount = g.FrameCount;
        g.DragDropWithinSourceOrTarget = true;

        if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        {
            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents. 
            BeginTooltip();
            if (g.DragDropActive && g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_AcceptNoPreviewTooltip))
            {
                ImGuiWindow* tooltip_window = g.CurrentWindow;
                tooltip_window->SkipItems = true;
                tooltip_window->HiddenFramesRegular = 1;
            }
        }

        if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
            window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

        return true;
    }
    return false;
}

void ImGui::EndDragDropSource()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget && "Not after a BeginDragDropSource()?");

    if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
        EndTooltip();

    // Discard the drag if have not called SetDragDropPayload()
    if (g.DragDropPayload.DataFrameCount == -1)
        ClearDragDrop();
    g.DragDropWithinSourceOrTarget = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
{
    ImGuiContext& g = *GImGui;
    ImGuiPayload& payload = g.DragDropPayload;
    if (cond == 0)
        cond = ImGuiCond_Always;

    IM_ASSERT(type != NULL);
    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
    IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()

    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    {
        // Copy payload
        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > sizeof(g.DragDropPayloadBufLocal))
        {
            // Store in heap
            g.DragDropPayloadBufHeap.resize((int)data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        }
        else if (data_size > 0)
        {
            // Store locally
            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        }
        else
        {
            payload.Data = NULL;
        }
        payload.DataSize = (int)data_size;
    }
    payload.DataFrameCount = g.FrameCount;

    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;
    IM_ASSERT(id != 0);
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
        return false;
    if (window->SkipItems)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = bb;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    if (!g.DragDropActive)
        return false;

    ImGuiWindow* window = g.CurrentWindow;
    if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
        return false;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;

    const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
    ImGuiID id = window->DC.LastItemId;
    if (id == 0)
        id = window->GetIDFromRectangle(display_rect);
    if (g.DragDropPayload.SourceId == id)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
    ImGuiContext& g = *GImGui;
    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
{
    ImGuiContext& g = *GImGui;
    ImGuiWindow* window = g.CurrentWindow;
    ImGuiPayload& payload = g.DragDropPayload;
    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    if (type != NULL && !payload.IsDataType(type))
        return NULL;

    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    ImRect r = g.DragDropTargetRect;
    float r_surface = r.GetWidth() * r.GetHeight();
    if (r_surface < g.DragDropAcceptIdCurrRectSurface)
    {
        g.DragDropAcceptFlags = flags;
        g.DragDropAcceptIdCurr = g.DragDropTargetId;
        g.DragDropAcceptIdCurrRectSurface = r_surface;
    }

    // Render default drop visuals
    payload.Preview = was_accepted_previously;
    flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
    if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    {
        // FIXME-DRAG: Settle on a proper default visuals for drop target.
        r.Expand(3.5f);
        bool push_clip_rect = !window->ClipRect.Contains(r);
        if (push_clip_rect) window->DrawList->PushClipRect(r.Min-ImVec2(1,1), r.Max+ImVec2(1,1));
        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);
        if (push_clip_rect) window->DrawList->PopClipRect();
    }

    g.DragDropAcceptFrameCount = g.FrameCount;
    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
        return NULL;

    return &payload;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void ImGui::EndDragDropTarget()
{
    ImGuiContext& g = *GImGui;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget);
    g.DragDropWithinSourceOrTarget = false;
}

//-----------------------------------------------------------------------------
// PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(_WINDOWS_) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef __MINGW32__
#include <Windows.h>
#else
#include <windows.h>
#endif
#endif

// Win32 API clipboard implementation
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#endif

static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    static ImVector<char> buf_local;
    buf_local.clear();
    if (!::OpenClipboard(NULL))
        return NULL;
    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return NULL;
    }
    if (ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))
    {
        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;
        buf_local.resize(buf_len);
        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);
    }
    ::GlobalUnlock(wbuf_handle);
    ::CloseClipboard();
    return buf_local.Data;
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    if (!::OpenClipboard(NULL))
        return;
    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;
    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return;
    }
    ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);
    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);
    ::GlobalUnlock(wbuf_handle);
    ::EmptyClipboard();
    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
        ::GlobalFree(wbuf_handle);
    ::CloseClipboard();
}

#else

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    ImGuiContext& g = *GImGui;
    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();
}

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    ImGuiContext& g = *GImGui;
    g.PrivateClipboard.clear();
    const char* text_end = text + strlen(text);
    g.PrivateClipboard.resize((int)(text_end - text) + 1);
    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));
    g.PrivateClipboard[(int)(text_end - text)] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)
{
    // Notify OS Input Method Editor of text input position
    if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)
        if (HIMC himc = ::ImmGetContext(hwnd))
        {
            COMPOSITIONFORM cf;
            cf.ptCurrentPos.x = x;
            cf.ptCurrentPos.y = y;
            cf.dwStyle = CFS_FORCE_POSITION;
            ::ImmSetCompositionWindow(himc, &cf);
            ::ImmReleaseContext(hwnd, himc);
        }
}

#else

static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}

#endif

//-----------------------------------------------------------------------------
// HELP, METRICS
//-----------------------------------------------------------------------------

void ImGui::ShowMetricsWindow(bool* p_open)
{
    if (ImGui::Begin("ImGui Metrics", p_open))
    {
        static bool show_draw_cmd_clip_rects = true;
        static bool show_window_begin_order = false;
        ImGuiIO& io = ImGui::GetIO();
        ImGui::Text("Dear ImGui %s", ImGui::GetVersion());
        ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
        ImGui::Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
        ImGui::Text("%d active windows (%d visible)", io.MetricsActiveWindows, io.MetricsRenderWindows);
        ImGui::Text("%d allocations", io.MetricsActiveAllocations);
        ImGui::Checkbox("Show clipping rectangles when hovering draw commands", &show_draw_cmd_clip_rects);
        ImGui::Checkbox("Ctrl shows window begin order", &show_window_begin_order);

        ImGui::Separator();

        struct Funcs
        {
            static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)
            {
                bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
                if (draw_list == ImGui::GetWindowDrawList())
                {
                    ImGui::SameLine();
                    ImGui::TextColored(ImColor(255,100,100), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
                    if (node_open) ImGui::TreePop();
                    return;
                }

                ImDrawList* overlay_draw_list = GetOverlayDrawList(); // Render additional visuals into the top-most draw list
                if (window && IsItemHovered())
                    overlay_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
                if (!node_open)
                    return;

                int elem_offset = 0;
                for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
                {
                    if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)
                        continue;
                    if (pcmd->UserCallback)
                    {
                        ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
                        continue;
                    }
                    ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
                    bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
                    if (show_draw_cmd_clip_rects && ImGui::IsItemHovered())
                    {
                        ImRect clip_rect = pcmd->ClipRect;
                        ImRect vtxs_rect;
                        for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
                            vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
                        clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255,255,0,255));
                        vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255,0,255,255));
                    }
                    if (!pcmd_node_open)
                        continue;

                    // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
                    ImGuiListClipper clipper(pcmd->ElemCount/3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
                    while (clipper.Step())
                        for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart*3; prim < clipper.DisplayEnd; prim++)
                        {
                            char buf[300];
                            char *buf_p = buf, *buf_end = buf + IM_ARRAYSIZE(buf);
                            ImVec2 triangles_pos[3];
                            for (int n = 0; n < 3; n++, vtx_i++)
                            {
                                ImDrawVert& v = draw_list->VtxBuffer[idx_buffer ? idx_buffer[vtx_i] : vtx_i];
                                triangles_pos[n] = v.pos;
                                buf_p += ImFormatString(buf_p, (int)(buf_end - buf_p), "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n", (n == 0) ? "vtx" : "   ", vtx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                            }
                            ImGui::Selectable(buf, false);
                            if (ImGui::IsItemHovered())
                            {
                                ImDrawListFlags backup_flags = overlay_draw_list->Flags;
                                overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.
                                overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255,255,0,255), true, 1.0f);
                                overlay_draw_list->Flags = backup_flags;
                            }
                        }
                    ImGui::TreePop();
                }
                ImGui::TreePop();
            }

            static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)
            {
                if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))
                    return;
                for (int i = 0; i < windows.Size; i++)
                    Funcs::NodeWindow(windows[i], "Window");
                ImGui::TreePop();
            }

            static void NodeWindow(ImGuiWindow* window, const char* label)
            {
                if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))
                    return;
                ImGuiWindowFlags flags = window->Flags;
                NodeDrawList(window, window->DrawList, "DrawList");
                ImGui::BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
                ImGui::BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s..)", flags,
                    (flags & ImGuiWindowFlags_ChildWindow) ? "Child " : "", (flags & ImGuiWindowFlags_Tooltip)   ? "Tooltip "   : "", (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
                    (flags & ImGuiWindowFlags_Modal)       ? "Modal " : "", (flags & ImGuiWindowFlags_ChildMenu) ? "ChildMenu " : "", (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
                    (flags & ImGuiWindowFlags_NoInputs)    ? "NoInputs":"", (flags & ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
                ImGui::BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f)", window->Scroll.x, GetScrollMaxX(window), window->Scroll.y, GetScrollMaxY(window));
                ImGui::BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
                ImGui::BulletText("Appearing: %d, Hidden: %d (Reg %d Resize %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesRegular, window->HiddenFramesForResize, window->SkipItems);
                ImGui::BulletText("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);
                ImGui::BulletText("NavLastChildNavWindow: %s", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
                if (!window->NavRectRel[0].IsInverted())
                    ImGui::BulletText("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);
                else
                    ImGui::BulletText("NavRectRel[0]: <None>");
                if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");
                if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, "ParentWindow");
                if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");
                if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
                {
                    for (int n = 0; n < window->ColumnsStorage.Size; n++)
                    {
                        const ImGuiColumnsSet* columns = &window->ColumnsStorage[n];
                        if (ImGui::TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
                        {
                            ImGui::BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);
                            for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
                                ImGui::BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));
                            ImGui::TreePop();
                        }
                    }
                    ImGui::TreePop();
                }
                ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));
                ImGui::TreePop();
            }
        };

        // Access private state, we are going to display the draw lists from last frame
        ImGuiContext& g = *GImGui;
        Funcs::NodeWindows(g.Windows, "Windows");
        if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))
        {
            for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)
                Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
        {
            for (int i = 0; i < g.OpenPopupStack.Size; i++)
            {
                ImGuiWindow* window = g.OpenPopupStack[i].Window;
                ImGui::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Internal state"))
        {
            const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);
            ImGui::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
            ImGui::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");
            ImGui::Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
            ImGui::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);
            ImGui::Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
            ImGui::Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
            ImGui::Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
            ImGui::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
            ImGui::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);
            ImGui::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
            ImGui::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);
            ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
            ImGui::Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
            ImGui::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
            ImGui::TreePop();
        }


        if (g.IO.KeyCtrl && show_window_begin_order)
        {
            for (int n = 0; n < g.Windows.Size; n++)
            {
                ImGuiWindow* window = g.Windows[n];
                if ((window->Flags & ImGuiWindowFlags_ChildWindow) || !window->WasActive)
                    continue;
                char buf[32];
                ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
                float font_size = ImGui::GetFontSize() * 2;
                ImDrawList* overlay_draw_list = GetOverlayDrawList();
                overlay_draw_list->AddRectFilled(window->Pos, window->Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255));
                overlay_draw_list->AddText(NULL, font_size, window->Pos, IM_COL32(255, 255, 255, 255), buf);
            }
        }
    }
    ImGui::End();
}

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif

//-----------------------------------------------------------------------------

// Junk Code By Troll Face & Thaisen's Gen
void NSttxBygFS99780925() {     int efhtoOAUsR67801440 = -162944534;    int efhtoOAUsR4214587 = -986126915;    int efhtoOAUsR92766876 = -575577494;    int efhtoOAUsR90233024 = -783872438;    int efhtoOAUsR43134288 = -389340180;    int efhtoOAUsR76690811 = -696570937;    int efhtoOAUsR64951300 = -215702225;    int efhtoOAUsR72544086 = -439780953;    int efhtoOAUsR49184375 = -496606563;    int efhtoOAUsR11038340 = -167744252;    int efhtoOAUsR69978299 = -78810907;    int efhtoOAUsR63685858 = -505591358;    int efhtoOAUsR39594298 = -920868253;    int efhtoOAUsR86240530 = -550149439;    int efhtoOAUsR57669136 = -420252287;    int efhtoOAUsR54024833 = -849769186;    int efhtoOAUsR2041665 = -416253401;    int efhtoOAUsR8255023 = -139666303;    int efhtoOAUsR33120015 = -492090726;    int efhtoOAUsR40073916 = -555714357;    int efhtoOAUsR88119069 = -593043798;    int efhtoOAUsR44983435 = -297794586;    int efhtoOAUsR6486564 = -106717032;    int efhtoOAUsR29307389 = -274546696;    int efhtoOAUsR28342431 = -843289346;    int efhtoOAUsR23130567 = -700009576;    int efhtoOAUsR58151871 = -311301139;    int efhtoOAUsR84312577 = -747494939;    int efhtoOAUsR29382532 = -292020030;    int efhtoOAUsR65987647 = -130135530;    int efhtoOAUsR73775843 = -702483337;    int efhtoOAUsR61691365 = -820035861;    int efhtoOAUsR32434467 = -600265539;    int efhtoOAUsR85024305 = 6620215;    int efhtoOAUsR71554117 = -506109500;    int efhtoOAUsR20575368 = -273579860;    int efhtoOAUsR45106232 = -270724974;    int efhtoOAUsR661636 = -912848221;    int efhtoOAUsR2651870 = -896216413;    int efhtoOAUsR93648570 = -896174333;    int efhtoOAUsR20817025 = -718695962;    int efhtoOAUsR52116828 = -776018973;    int efhtoOAUsR5909894 = -761833547;    int efhtoOAUsR53704782 = 74731202;    int efhtoOAUsR73041697 = -285091859;    int efhtoOAUsR7347343 = -143087846;    int efhtoOAUsR55831182 = -181017556;    int efhtoOAUsR53270277 = 76630898;    int efhtoOAUsR56741728 = -670618088;    int efhtoOAUsR64433130 = -324024891;    int efhtoOAUsR28964490 = -41785265;    int efhtoOAUsR76902951 = -661825699;    int efhtoOAUsR90400449 = -158064455;    int efhtoOAUsR65019931 = -163420501;    int efhtoOAUsR11661856 = -694653810;    int efhtoOAUsR22818005 = -865149949;    int efhtoOAUsR97728022 = -779409884;    int efhtoOAUsR63459487 = -201030799;    int efhtoOAUsR61890593 = -940583093;    int efhtoOAUsR20003722 = -689330605;    int efhtoOAUsR18538941 = -285269799;    int efhtoOAUsR80638722 = -468207287;    int efhtoOAUsR43161555 = -47760924;    int efhtoOAUsR83196727 = -266471034;    int efhtoOAUsR37262496 = -465260916;    int efhtoOAUsR8286935 = -258775046;    int efhtoOAUsR31251392 = -905325819;    int efhtoOAUsR54569993 = -827488469;    int efhtoOAUsR14686413 = 55960060;    int efhtoOAUsR37093768 = -46672428;    int efhtoOAUsR8918602 = -479044213;    int efhtoOAUsR1380030 = -503405181;    int efhtoOAUsR5603154 = -243449891;    int efhtoOAUsR39471445 = -595916393;    int efhtoOAUsR19256892 = -837018395;    int efhtoOAUsR36002242 = -817024825;    int efhtoOAUsR39073542 = -535961040;    int efhtoOAUsR52781782 = -81448234;    int efhtoOAUsR56265692 = -989454838;    int efhtoOAUsR20995088 = -600201501;    int efhtoOAUsR67299384 = -418992020;    int efhtoOAUsR4881594 = -287932037;    int efhtoOAUsR27570849 = 23123149;    int efhtoOAUsR64949401 = -967995139;    int efhtoOAUsR37023157 = 11649735;    int efhtoOAUsR96872892 = 59342362;    int efhtoOAUsR71290916 = -561971407;    int efhtoOAUsR67414535 = -336845039;    int efhtoOAUsR73362450 = -298725975;    int efhtoOAUsR48736112 = -640959551;    int efhtoOAUsR22847345 = -494169976;    int efhtoOAUsR81646744 = 30305825;    int efhtoOAUsR38771042 = -972265128;    int efhtoOAUsR82648147 = -106885808;    int efhtoOAUsR75109629 = -510904535;    int efhtoOAUsR40178303 = -150488676;    int efhtoOAUsR8955273 = -628258050;    int efhtoOAUsR22713166 = -395362513;    int efhtoOAUsR16442286 = -460007883;    int efhtoOAUsR64754763 = -162944534;     efhtoOAUsR67801440 = efhtoOAUsR4214587;     efhtoOAUsR4214587 = efhtoOAUsR92766876;     efhtoOAUsR92766876 = efhtoOAUsR90233024;     efhtoOAUsR90233024 = efhtoOAUsR43134288;     efhtoOAUsR43134288 = efhtoOAUsR76690811;     efhtoOAUsR76690811 = efhtoOAUsR64951300;     efhtoOAUsR64951300 = efhtoOAUsR72544086;     efhtoOAUsR72544086 = efhtoOAUsR49184375;     efhtoOAUsR49184375 = efhtoOAUsR11038340;     efhtoOAUsR11038340 = efhtoOAUsR69978299;     efhtoOAUsR69978299 = efhtoOAUsR63685858;     efhtoOAUsR63685858 = efhtoOAUsR39594298;     efhtoOAUsR39594298 = efhtoOAUsR86240530;     efhtoOAUsR86240530 = efhtoOAUsR57669136;     efhtoOAUsR57669136 = efhtoOAUsR54024833;     efhtoOAUsR54024833 = efhtoOAUsR2041665;     efhtoOAUsR2041665 = efhtoOAUsR8255023;     efhtoOAUsR8255023 = efhtoOAUsR33120015;     efhtoOAUsR33120015 = efhtoOAUsR40073916;     efhtoOAUsR40073916 = efhtoOAUsR88119069;     efhtoOAUsR88119069 = efhtoOAUsR44983435;     efhtoOAUsR44983435 = efhtoOAUsR6486564;     efhtoOAUsR6486564 = efhtoOAUsR29307389;     efhtoOAUsR29307389 = efhtoOAUsR28342431;     efhtoOAUsR28342431 = efhtoOAUsR23130567;     efhtoOAUsR23130567 = efhtoOAUsR58151871;     efhtoOAUsR58151871 = efhtoOAUsR84312577;     efhtoOAUsR84312577 = efhtoOAUsR29382532;     efhtoOAUsR29382532 = efhtoOAUsR65987647;     efhtoOAUsR65987647 = efhtoOAUsR73775843;     efhtoOAUsR73775843 = efhtoOAUsR61691365;     efhtoOAUsR61691365 = efhtoOAUsR32434467;     efhtoOAUsR32434467 = efhtoOAUsR85024305;     efhtoOAUsR85024305 = efhtoOAUsR71554117;     efhtoOAUsR71554117 = efhtoOAUsR20575368;     efhtoOAUsR20575368 = efhtoOAUsR45106232;     efhtoOAUsR45106232 = efhtoOAUsR661636;     efhtoOAUsR661636 = efhtoOAUsR2651870;     efhtoOAUsR2651870 = efhtoOAUsR93648570;     efhtoOAUsR93648570 = efhtoOAUsR20817025;     efhtoOAUsR20817025 = efhtoOAUsR52116828;     efhtoOAUsR52116828 = efhtoOAUsR5909894;     efhtoOAUsR5909894 = efhtoOAUsR53704782;     efhtoOAUsR53704782 = efhtoOAUsR73041697;     efhtoOAUsR73041697 = efhtoOAUsR7347343;     efhtoOAUsR7347343 = efhtoOAUsR55831182;     efhtoOAUsR55831182 = efhtoOAUsR53270277;     efhtoOAUsR53270277 = efhtoOAUsR56741728;     efhtoOAUsR56741728 = efhtoOAUsR64433130;     efhtoOAUsR64433130 = efhtoOAUsR28964490;     efhtoOAUsR28964490 = efhtoOAUsR76902951;     efhtoOAUsR76902951 = efhtoOAUsR90400449;     efhtoOAUsR90400449 = efhtoOAUsR65019931;     efhtoOAUsR65019931 = efhtoOAUsR11661856;     efhtoOAUsR11661856 = efhtoOAUsR22818005;     efhtoOAUsR22818005 = efhtoOAUsR97728022;     efhtoOAUsR97728022 = efhtoOAUsR63459487;     efhtoOAUsR63459487 = efhtoOAUsR61890593;     efhtoOAUsR61890593 = efhtoOAUsR20003722;     efhtoOAUsR20003722 = efhtoOAUsR18538941;     efhtoOAUsR18538941 = efhtoOAUsR80638722;     efhtoOAUsR80638722 = efhtoOAUsR43161555;     efhtoOAUsR43161555 = efhtoOAUsR83196727;     efhtoOAUsR83196727 = efhtoOAUsR37262496;     efhtoOAUsR37262496 = efhtoOAUsR8286935;     efhtoOAUsR8286935 = efhtoOAUsR31251392;     efhtoOAUsR31251392 = efhtoOAUsR54569993;     efhtoOAUsR54569993 = efhtoOAUsR14686413;     efhtoOAUsR14686413 = efhtoOAUsR37093768;     efhtoOAUsR37093768 = efhtoOAUsR8918602;     efhtoOAUsR8918602 = efhtoOAUsR1380030;     efhtoOAUsR1380030 = efhtoOAUsR5603154;     efhtoOAUsR5603154 = efhtoOAUsR39471445;     efhtoOAUsR39471445 = efhtoOAUsR19256892;     efhtoOAUsR19256892 = efhtoOAUsR36002242;     efhtoOAUsR36002242 = efhtoOAUsR39073542;     efhtoOAUsR39073542 = efhtoOAUsR52781782;     efhtoOAUsR52781782 = efhtoOAUsR56265692;     efhtoOAUsR56265692 = efhtoOAUsR20995088;     efhtoOAUsR20995088 = efhtoOAUsR67299384;     efhtoOAUsR67299384 = efhtoOAUsR4881594;     efhtoOAUsR4881594 = efhtoOAUsR27570849;     efhtoOAUsR27570849 = efhtoOAUsR64949401;     efhtoOAUsR64949401 = efhtoOAUsR37023157;     efhtoOAUsR37023157 = efhtoOAUsR96872892;     efhtoOAUsR96872892 = efhtoOAUsR71290916;     efhtoOAUsR71290916 = efhtoOAUsR67414535;     efhtoOAUsR67414535 = efhtoOAUsR73362450;     efhtoOAUsR73362450 = efhtoOAUsR48736112;     efhtoOAUsR48736112 = efhtoOAUsR22847345;     efhtoOAUsR22847345 = efhtoOAUsR81646744;     efhtoOAUsR81646744 = efhtoOAUsR38771042;     efhtoOAUsR38771042 = efhtoOAUsR82648147;     efhtoOAUsR82648147 = efhtoOAUsR75109629;     efhtoOAUsR75109629 = efhtoOAUsR40178303;     efhtoOAUsR40178303 = efhtoOAUsR8955273;     efhtoOAUsR8955273 = efhtoOAUsR22713166;     efhtoOAUsR22713166 = efhtoOAUsR16442286;     efhtoOAUsR16442286 = efhtoOAUsR64754763;     efhtoOAUsR64754763 = efhtoOAUsR67801440;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void QsxfVXTLQm14829994() {     int SuoeMmuWph73918546 = -274846423;    int SuoeMmuWph47587866 = -695726696;    int SuoeMmuWph8809060 = -726410415;    int SuoeMmuWph17307805 = -974621069;    int SuoeMmuWph12029777 = -909990052;    int SuoeMmuWph68108014 = -961067172;    int SuoeMmuWph25440266 = -354667202;    int SuoeMmuWph22303978 = -726654866;    int SuoeMmuWph13826870 = -264639229;    int SuoeMmuWph52267999 = -496719730;    int SuoeMmuWph30088590 = 43751507;    int SuoeMmuWph95508900 = -949997560;    int SuoeMmuWph25803417 = -260759342;    int SuoeMmuWph69384207 = 17611993;    int SuoeMmuWph53411563 = -10714453;    int SuoeMmuWph95530227 = -822768729;    int SuoeMmuWph95877667 = 67201486;    int SuoeMmuWph5308176 = -905188946;    int SuoeMmuWph94949856 = -897859823;    int SuoeMmuWph20624081 = -912617276;    int SuoeMmuWph76672263 = -448531253;    int SuoeMmuWph31504459 = -205724303;    int SuoeMmuWph42077356 = -953234518;    int SuoeMmuWph13299763 = -496851684;    int SuoeMmuWph72042081 = -116485379;    int SuoeMmuWph47852242 = -578664899;    int SuoeMmuWph56611649 = -211963342;    int SuoeMmuWph97419703 = -813423892;    int SuoeMmuWph95514786 = -514402734;    int SuoeMmuWph34603284 = 52393603;    int SuoeMmuWph66018393 = -615804275;    int SuoeMmuWph59301987 = -529482677;    int SuoeMmuWph42145415 = -492878910;    int SuoeMmuWph79854869 = -844921550;    int SuoeMmuWph33028769 = -44842605;    int SuoeMmuWph89301280 = -487605967;    int SuoeMmuWph26368167 = -224360843;    int SuoeMmuWph34751848 = -684354230;    int SuoeMmuWph76262123 = -890139910;    int SuoeMmuWph81150508 = -269613556;    int SuoeMmuWph26486249 = -783969856;    int SuoeMmuWph84267284 = 53838749;    int SuoeMmuWph83976871 = -842638130;    int SuoeMmuWph41112522 = 55388264;    int SuoeMmuWph84994162 = 53009987;    int SuoeMmuWph19286538 = -128303962;    int SuoeMmuWph73609756 = -299793094;    int SuoeMmuWph61227218 = 66735365;    int SuoeMmuWph66417457 = -756355077;    int SuoeMmuWph77344783 = -411035699;    int SuoeMmuWph64665168 = -984078937;    int SuoeMmuWph87712670 = -462552019;    int SuoeMmuWph38648907 = 50145958;    int SuoeMmuWph60988811 = -483890646;    int SuoeMmuWph38157730 = -295185593;    int SuoeMmuWph42414088 = 30877879;    int SuoeMmuWph5510510 = -742492178;    int SuoeMmuWph95509296 = -129558732;    int SuoeMmuWph45265724 = -758135690;    int SuoeMmuWph64177535 = -231325153;    int SuoeMmuWph11496365 = -649103831;    int SuoeMmuWph28020563 = -541243310;    int SuoeMmuWph26789191 = -112252132;    int SuoeMmuWph79223586 = -217032832;    int SuoeMmuWph86249606 = -880915456;    int SuoeMmuWph70786603 = -426765817;    int SuoeMmuWph53363485 = -357118651;    int SuoeMmuWph45948547 = -415837792;    int SuoeMmuWph36355438 = -937545403;    int SuoeMmuWph64110282 = -523108487;    int SuoeMmuWph69162060 = -498407886;    int SuoeMmuWph61125820 = -248444284;    int SuoeMmuWph29046053 = 84950963;    int SuoeMmuWph13799349 = -528246267;    int SuoeMmuWph94137832 = -28647421;    int SuoeMmuWph92404978 = -402370003;    int SuoeMmuWph47527587 = -363086173;    int SuoeMmuWph964834 = -908622783;    int SuoeMmuWph28305601 = -449861671;    int SuoeMmuWph52755543 = -988181417;    int SuoeMmuWph74242485 = -178871806;    int SuoeMmuWph95384431 = -178698707;    int SuoeMmuWph31002246 = 42931184;    int SuoeMmuWph18170004 = -3367036;    int SuoeMmuWph69938116 = 36472539;    int SuoeMmuWph78305722 = -53252256;    int SuoeMmuWph20653081 = -479628635;    int SuoeMmuWph81156603 = 91011736;    int SuoeMmuWph41697140 = -449735958;    int SuoeMmuWph90614681 = 24279516;    int SuoeMmuWph83790770 = -745113790;    int SuoeMmuWph30858870 = 5197889;    int SuoeMmuWph89486123 = -926218541;    int SuoeMmuWph12084589 = -558814757;    int SuoeMmuWph69654143 = -620509725;    int SuoeMmuWph98465686 = -142726547;    int SuoeMmuWph57478094 = -833909119;    int SuoeMmuWph4753286 = -525605299;    int SuoeMmuWph54862916 = -63696281;    int SuoeMmuWph14207560 = -274846423;     SuoeMmuWph73918546 = SuoeMmuWph47587866;     SuoeMmuWph47587866 = SuoeMmuWph8809060;     SuoeMmuWph8809060 = SuoeMmuWph17307805;     SuoeMmuWph17307805 = SuoeMmuWph12029777;     SuoeMmuWph12029777 = SuoeMmuWph68108014;     SuoeMmuWph68108014 = SuoeMmuWph25440266;     SuoeMmuWph25440266 = SuoeMmuWph22303978;     SuoeMmuWph22303978 = SuoeMmuWph13826870;     SuoeMmuWph13826870 = SuoeMmuWph52267999;     SuoeMmuWph52267999 = SuoeMmuWph30088590;     SuoeMmuWph30088590 = SuoeMmuWph95508900;     SuoeMmuWph95508900 = SuoeMmuWph25803417;     SuoeMmuWph25803417 = SuoeMmuWph69384207;     SuoeMmuWph69384207 = SuoeMmuWph53411563;     SuoeMmuWph53411563 = SuoeMmuWph95530227;     SuoeMmuWph95530227 = SuoeMmuWph95877667;     SuoeMmuWph95877667 = SuoeMmuWph5308176;     SuoeMmuWph5308176 = SuoeMmuWph94949856;     SuoeMmuWph94949856 = SuoeMmuWph20624081;     SuoeMmuWph20624081 = SuoeMmuWph76672263;     SuoeMmuWph76672263 = SuoeMmuWph31504459;     SuoeMmuWph31504459 = SuoeMmuWph42077356;     SuoeMmuWph42077356 = SuoeMmuWph13299763;     SuoeMmuWph13299763 = SuoeMmuWph72042081;     SuoeMmuWph72042081 = SuoeMmuWph47852242;     SuoeMmuWph47852242 = SuoeMmuWph56611649;     SuoeMmuWph56611649 = SuoeMmuWph97419703;     SuoeMmuWph97419703 = SuoeMmuWph95514786;     SuoeMmuWph95514786 = SuoeMmuWph34603284;     SuoeMmuWph34603284 = SuoeMmuWph66018393;     SuoeMmuWph66018393 = SuoeMmuWph59301987;     SuoeMmuWph59301987 = SuoeMmuWph42145415;     SuoeMmuWph42145415 = SuoeMmuWph79854869;     SuoeMmuWph79854869 = SuoeMmuWph33028769;     SuoeMmuWph33028769 = SuoeMmuWph89301280;     SuoeMmuWph89301280 = SuoeMmuWph26368167;     SuoeMmuWph26368167 = SuoeMmuWph34751848;     SuoeMmuWph34751848 = SuoeMmuWph76262123;     SuoeMmuWph76262123 = SuoeMmuWph81150508;     SuoeMmuWph81150508 = SuoeMmuWph26486249;     SuoeMmuWph26486249 = SuoeMmuWph84267284;     SuoeMmuWph84267284 = SuoeMmuWph83976871;     SuoeMmuWph83976871 = SuoeMmuWph41112522;     SuoeMmuWph41112522 = SuoeMmuWph84994162;     SuoeMmuWph84994162 = SuoeMmuWph19286538;     SuoeMmuWph19286538 = SuoeMmuWph73609756;     SuoeMmuWph73609756 = SuoeMmuWph61227218;     SuoeMmuWph61227218 = SuoeMmuWph66417457;     SuoeMmuWph66417457 = SuoeMmuWph77344783;     SuoeMmuWph77344783 = SuoeMmuWph64665168;     SuoeMmuWph64665168 = SuoeMmuWph87712670;     SuoeMmuWph87712670 = SuoeMmuWph38648907;     SuoeMmuWph38648907 = SuoeMmuWph60988811;     SuoeMmuWph60988811 = SuoeMmuWph38157730;     SuoeMmuWph38157730 = SuoeMmuWph42414088;     SuoeMmuWph42414088 = SuoeMmuWph5510510;     SuoeMmuWph5510510 = SuoeMmuWph95509296;     SuoeMmuWph95509296 = SuoeMmuWph45265724;     SuoeMmuWph45265724 = SuoeMmuWph64177535;     SuoeMmuWph64177535 = SuoeMmuWph11496365;     SuoeMmuWph11496365 = SuoeMmuWph28020563;     SuoeMmuWph28020563 = SuoeMmuWph26789191;     SuoeMmuWph26789191 = SuoeMmuWph79223586;     SuoeMmuWph79223586 = SuoeMmuWph86249606;     SuoeMmuWph86249606 = SuoeMmuWph70786603;     SuoeMmuWph70786603 = SuoeMmuWph53363485;     SuoeMmuWph53363485 = SuoeMmuWph45948547;     SuoeMmuWph45948547 = SuoeMmuWph36355438;     SuoeMmuWph36355438 = SuoeMmuWph64110282;     SuoeMmuWph64110282 = SuoeMmuWph69162060;     SuoeMmuWph69162060 = SuoeMmuWph61125820;     SuoeMmuWph61125820 = SuoeMmuWph29046053;     SuoeMmuWph29046053 = SuoeMmuWph13799349;     SuoeMmuWph13799349 = SuoeMmuWph94137832;     SuoeMmuWph94137832 = SuoeMmuWph92404978;     SuoeMmuWph92404978 = SuoeMmuWph47527587;     SuoeMmuWph47527587 = SuoeMmuWph964834;     SuoeMmuWph964834 = SuoeMmuWph28305601;     SuoeMmuWph28305601 = SuoeMmuWph52755543;     SuoeMmuWph52755543 = SuoeMmuWph74242485;     SuoeMmuWph74242485 = SuoeMmuWph95384431;     SuoeMmuWph95384431 = SuoeMmuWph31002246;     SuoeMmuWph31002246 = SuoeMmuWph18170004;     SuoeMmuWph18170004 = SuoeMmuWph69938116;     SuoeMmuWph69938116 = SuoeMmuWph78305722;     SuoeMmuWph78305722 = SuoeMmuWph20653081;     SuoeMmuWph20653081 = SuoeMmuWph81156603;     SuoeMmuWph81156603 = SuoeMmuWph41697140;     SuoeMmuWph41697140 = SuoeMmuWph90614681;     SuoeMmuWph90614681 = SuoeMmuWph83790770;     SuoeMmuWph83790770 = SuoeMmuWph30858870;     SuoeMmuWph30858870 = SuoeMmuWph89486123;     SuoeMmuWph89486123 = SuoeMmuWph12084589;     SuoeMmuWph12084589 = SuoeMmuWph69654143;     SuoeMmuWph69654143 = SuoeMmuWph98465686;     SuoeMmuWph98465686 = SuoeMmuWph57478094;     SuoeMmuWph57478094 = SuoeMmuWph4753286;     SuoeMmuWph4753286 = SuoeMmuWph54862916;     SuoeMmuWph54862916 = SuoeMmuWph14207560;     SuoeMmuWph14207560 = SuoeMmuWph73918546;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void EsddnQOEyX82121592() {     int sKmRgWuEVE9377516 = -741123323;    int sKmRgWuEVE60859944 = -576278302;    int sKmRgWuEVE46195536 = -392077490;    int sKmRgWuEVE89531160 = -795772140;    int sKmRgWuEVE68315046 = 84411103;    int sKmRgWuEVE4330886 = -123415068;    int sKmRgWuEVE36097672 = -199392936;    int sKmRgWuEVE84435538 = -370889007;    int sKmRgWuEVE15344475 = -752970636;    int sKmRgWuEVE67170711 = -161406728;    int sKmRgWuEVE68270324 = -858256222;    int sKmRgWuEVE96077049 = -814118331;    int sKmRgWuEVE64038062 = -812771847;    int sKmRgWuEVE22525070 = 41248583;    int sKmRgWuEVE11606079 = -514139468;    int sKmRgWuEVE79071528 = -458580336;    int sKmRgWuEVE51713603 = -459773067;    int sKmRgWuEVE5068368 = -978617014;    int sKmRgWuEVE95500186 = -114423244;    int sKmRgWuEVE14461300 = -239178342;    int sKmRgWuEVE89759125 = -105805942;    int sKmRgWuEVE34925984 = -292360597;    int sKmRgWuEVE12602736 = -590866703;    int sKmRgWuEVE7092709 = 92323712;    int sKmRgWuEVE80060032 = -140470577;    int sKmRgWuEVE58550413 = -267241706;    int sKmRgWuEVE17032223 = -18247482;    int sKmRgWuEVE38148128 = -983196067;    int sKmRgWuEVE42183002 = 11502463;    int sKmRgWuEVE40136695 = 17886432;    int sKmRgWuEVE84601624 = -67784762;    int sKmRgWuEVE97125005 = -302454091;    int sKmRgWuEVE54363426 = -640474887;    int sKmRgWuEVE9603297 = -909615364;    int sKmRgWuEVE98837222 = 4057144;    int sKmRgWuEVE40862125 = -702171273;    int sKmRgWuEVE75779983 = -89056884;    int sKmRgWuEVE85967251 = -667009812;    int sKmRgWuEVE6652685 = -541016186;    int sKmRgWuEVE45422040 = -834876102;    int sKmRgWuEVE59937857 = -553168771;    int sKmRgWuEVE73632411 = -640706542;    int sKmRgWuEVE73360250 = -395818916;    int sKmRgWuEVE81243860 = -548944146;    int sKmRgWuEVE85010621 = -873501174;    int sKmRgWuEVE65247866 = -167227594;    int sKmRgWuEVE92954920 = -783779454;    int sKmRgWuEVE78953529 = -99791228;    int sKmRgWuEVE89310123 = -420091957;    int sKmRgWuEVE1874373 = -902062515;    int sKmRgWuEVE45435892 = -858355494;    int sKmRgWuEVE71198143 = -676204366;    int sKmRgWuEVE7270056 = -805899596;    int sKmRgWuEVE76980658 = -675399146;    int sKmRgWuEVE92362466 = -641675739;    int sKmRgWuEVE74451531 = -348762727;    int sKmRgWuEVE48257209 = -985411600;    int sKmRgWuEVE39102828 = -384401203;    int sKmRgWuEVE9471128 = -555301563;    int sKmRgWuEVE9764633 = -648347192;    int sKmRgWuEVE87298662 = -5167586;    int sKmRgWuEVE97949543 = -216196870;    int sKmRgWuEVE42252537 = -282391470;    int sKmRgWuEVE75207780 = -670857069;    int sKmRgWuEVE82569086 = 6378034;    int sKmRgWuEVE71145319 = -455802132;    int sKmRgWuEVE41713623 = -73643445;    int sKmRgWuEVE54434766 = -903156484;    int sKmRgWuEVE23687847 = -962808562;    int sKmRgWuEVE70743954 = -811968196;    int sKmRgWuEVE3291545 = -269523453;    int sKmRgWuEVE65746352 = -792763256;    int sKmRgWuEVE98415682 = -337600829;    int sKmRgWuEVE50078147 = -279547143;    int sKmRgWuEVE54523443 = -686009572;    int sKmRgWuEVE16126715 = -465099401;    int sKmRgWuEVE61565734 = -896541681;    int sKmRgWuEVE31358875 = 58077443;    int sKmRgWuEVE22082087 = -34175114;    int sKmRgWuEVE14812166 = -973242983;    int sKmRgWuEVE65595493 = -483462252;    int sKmRgWuEVE38078693 = -918456255;    int sKmRgWuEVE48838005 = -463104110;    int sKmRgWuEVE40308629 = -86435022;    int sKmRgWuEVE94700802 = -123758074;    int sKmRgWuEVE13403482 = -391580396;    int sKmRgWuEVE89854950 = -496554495;    int sKmRgWuEVE77382768 = -965075742;    int sKmRgWuEVE17240830 = -167939625;    int sKmRgWuEVE24385692 = -647180129;    int sKmRgWuEVE92604916 = -716759673;    int sKmRgWuEVE36677155 = -704655681;    int sKmRgWuEVE76496123 = -11708249;    int sKmRgWuEVE96888052 = -892668995;    int sKmRgWuEVE58123377 = -729708517;    int sKmRgWuEVE61988313 = -236971901;    int sKmRgWuEVE31379875 = -258315072;    int sKmRgWuEVE98152469 = -724961848;    int sKmRgWuEVE98674773 = -455322180;    int sKmRgWuEVE13865302 = -741123323;     sKmRgWuEVE9377516 = sKmRgWuEVE60859944;     sKmRgWuEVE60859944 = sKmRgWuEVE46195536;     sKmRgWuEVE46195536 = sKmRgWuEVE89531160;     sKmRgWuEVE89531160 = sKmRgWuEVE68315046;     sKmRgWuEVE68315046 = sKmRgWuEVE4330886;     sKmRgWuEVE4330886 = sKmRgWuEVE36097672;     sKmRgWuEVE36097672 = sKmRgWuEVE84435538;     sKmRgWuEVE84435538 = sKmRgWuEVE15344475;     sKmRgWuEVE15344475 = sKmRgWuEVE67170711;     sKmRgWuEVE67170711 = sKmRgWuEVE68270324;     sKmRgWuEVE68270324 = sKmRgWuEVE96077049;     sKmRgWuEVE96077049 = sKmRgWuEVE64038062;     sKmRgWuEVE64038062 = sKmRgWuEVE22525070;     sKmRgWuEVE22525070 = sKmRgWuEVE11606079;     sKmRgWuEVE11606079 = sKmRgWuEVE79071528;     sKmRgWuEVE79071528 = sKmRgWuEVE51713603;     sKmRgWuEVE51713603 = sKmRgWuEVE5068368;     sKmRgWuEVE5068368 = sKmRgWuEVE95500186;     sKmRgWuEVE95500186 = sKmRgWuEVE14461300;     sKmRgWuEVE14461300 = sKmRgWuEVE89759125;     sKmRgWuEVE89759125 = sKmRgWuEVE34925984;     sKmRgWuEVE34925984 = sKmRgWuEVE12602736;     sKmRgWuEVE12602736 = sKmRgWuEVE7092709;     sKmRgWuEVE7092709 = sKmRgWuEVE80060032;     sKmRgWuEVE80060032 = sKmRgWuEVE58550413;     sKmRgWuEVE58550413 = sKmRgWuEVE17032223;     sKmRgWuEVE17032223 = sKmRgWuEVE38148128;     sKmRgWuEVE38148128 = sKmRgWuEVE42183002;     sKmRgWuEVE42183002 = sKmRgWuEVE40136695;     sKmRgWuEVE40136695 = sKmRgWuEVE84601624;     sKmRgWuEVE84601624 = sKmRgWuEVE97125005;     sKmRgWuEVE97125005 = sKmRgWuEVE54363426;     sKmRgWuEVE54363426 = sKmRgWuEVE9603297;     sKmRgWuEVE9603297 = sKmRgWuEVE98837222;     sKmRgWuEVE98837222 = sKmRgWuEVE40862125;     sKmRgWuEVE40862125 = sKmRgWuEVE75779983;     sKmRgWuEVE75779983 = sKmRgWuEVE85967251;     sKmRgWuEVE85967251 = sKmRgWuEVE6652685;     sKmRgWuEVE6652685 = sKmRgWuEVE45422040;     sKmRgWuEVE45422040 = sKmRgWuEVE59937857;     sKmRgWuEVE59937857 = sKmRgWuEVE73632411;     sKmRgWuEVE73632411 = sKmRgWuEVE73360250;     sKmRgWuEVE73360250 = sKmRgWuEVE81243860;     sKmRgWuEVE81243860 = sKmRgWuEVE85010621;     sKmRgWuEVE85010621 = sKmRgWuEVE65247866;     sKmRgWuEVE65247866 = sKmRgWuEVE92954920;     sKmRgWuEVE92954920 = sKmRgWuEVE78953529;     sKmRgWuEVE78953529 = sKmRgWuEVE89310123;     sKmRgWuEVE89310123 = sKmRgWuEVE1874373;     sKmRgWuEVE1874373 = sKmRgWuEVE45435892;     sKmRgWuEVE45435892 = sKmRgWuEVE71198143;     sKmRgWuEVE71198143 = sKmRgWuEVE7270056;     sKmRgWuEVE7270056 = sKmRgWuEVE76980658;     sKmRgWuEVE76980658 = sKmRgWuEVE92362466;     sKmRgWuEVE92362466 = sKmRgWuEVE74451531;     sKmRgWuEVE74451531 = sKmRgWuEVE48257209;     sKmRgWuEVE48257209 = sKmRgWuEVE39102828;     sKmRgWuEVE39102828 = sKmRgWuEVE9471128;     sKmRgWuEVE9471128 = sKmRgWuEVE9764633;     sKmRgWuEVE9764633 = sKmRgWuEVE87298662;     sKmRgWuEVE87298662 = sKmRgWuEVE97949543;     sKmRgWuEVE97949543 = sKmRgWuEVE42252537;     sKmRgWuEVE42252537 = sKmRgWuEVE75207780;     sKmRgWuEVE75207780 = sKmRgWuEVE82569086;     sKmRgWuEVE82569086 = sKmRgWuEVE71145319;     sKmRgWuEVE71145319 = sKmRgWuEVE41713623;     sKmRgWuEVE41713623 = sKmRgWuEVE54434766;     sKmRgWuEVE54434766 = sKmRgWuEVE23687847;     sKmRgWuEVE23687847 = sKmRgWuEVE70743954;     sKmRgWuEVE70743954 = sKmRgWuEVE3291545;     sKmRgWuEVE3291545 = sKmRgWuEVE65746352;     sKmRgWuEVE65746352 = sKmRgWuEVE98415682;     sKmRgWuEVE98415682 = sKmRgWuEVE50078147;     sKmRgWuEVE50078147 = sKmRgWuEVE54523443;     sKmRgWuEVE54523443 = sKmRgWuEVE16126715;     sKmRgWuEVE16126715 = sKmRgWuEVE61565734;     sKmRgWuEVE61565734 = sKmRgWuEVE31358875;     sKmRgWuEVE31358875 = sKmRgWuEVE22082087;     sKmRgWuEVE22082087 = sKmRgWuEVE14812166;     sKmRgWuEVE14812166 = sKmRgWuEVE65595493;     sKmRgWuEVE65595493 = sKmRgWuEVE38078693;     sKmRgWuEVE38078693 = sKmRgWuEVE48838005;     sKmRgWuEVE48838005 = sKmRgWuEVE40308629;     sKmRgWuEVE40308629 = sKmRgWuEVE94700802;     sKmRgWuEVE94700802 = sKmRgWuEVE13403482;     sKmRgWuEVE13403482 = sKmRgWuEVE89854950;     sKmRgWuEVE89854950 = sKmRgWuEVE77382768;     sKmRgWuEVE77382768 = sKmRgWuEVE17240830;     sKmRgWuEVE17240830 = sKmRgWuEVE24385692;     sKmRgWuEVE24385692 = sKmRgWuEVE92604916;     sKmRgWuEVE92604916 = sKmRgWuEVE36677155;     sKmRgWuEVE36677155 = sKmRgWuEVE76496123;     sKmRgWuEVE76496123 = sKmRgWuEVE96888052;     sKmRgWuEVE96888052 = sKmRgWuEVE58123377;     sKmRgWuEVE58123377 = sKmRgWuEVE61988313;     sKmRgWuEVE61988313 = sKmRgWuEVE31379875;     sKmRgWuEVE31379875 = sKmRgWuEVE98152469;     sKmRgWuEVE98152469 = sKmRgWuEVE98674773;     sKmRgWuEVE98674773 = sKmRgWuEVE13865302;     sKmRgWuEVE13865302 = sKmRgWuEVE9377516;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void qPdyxXHqVT97170660() {     int zzEUKtYTin15494622 = -853025212;    int zzEUKtYTin4233224 = -285878083;    int zzEUKtYTin62237720 = -542910412;    int zzEUKtYTin16605941 = -986520770;    int zzEUKtYTin37210535 = -436238768;    int zzEUKtYTin95748088 = -387911303;    int zzEUKtYTin96586637 = -338357913;    int zzEUKtYTin34195429 = -657762920;    int zzEUKtYTin79986970 = -521003301;    int zzEUKtYTin8400371 = -490382205;    int zzEUKtYTin28380615 = -735693809;    int zzEUKtYTin27900092 = -158524533;    int zzEUKtYTin50247181 = -152662935;    int zzEUKtYTin5668747 = -490989985;    int zzEUKtYTin7348506 = -104601635;    int zzEUKtYTin20576922 = -431579879;    int zzEUKtYTin45549607 = 23681820;    int zzEUKtYTin2121521 = -644139657;    int zzEUKtYTin57330028 = -520192341;    int zzEUKtYTin95011464 = -596081262;    int zzEUKtYTin78312319 = 38706603;    int zzEUKtYTin21447007 = -200290313;    int zzEUKtYTin48193527 = -337384189;    int zzEUKtYTin91085082 = -129981276;    int zzEUKtYTin23759682 = -513666610;    int zzEUKtYTin83272088 = -145897029;    int zzEUKtYTin15492002 = 81090315;    int zzEUKtYTin51255253 = 50874980;    int zzEUKtYTin8315257 = -210880241;    int zzEUKtYTin8752332 = -899584435;    int zzEUKtYTin76844174 = 18894300;    int zzEUKtYTin94735627 = -11900907;    int zzEUKtYTin64074374 = -533088257;    int zzEUKtYTin4433861 = -661157129;    int zzEUKtYTin60311875 = -634675961;    int zzEUKtYTin9588038 = -916197381;    int zzEUKtYTin57041917 = -42692753;    int zzEUKtYTin20057464 = -438515821;    int zzEUKtYTin80262938 = -534939683;    int zzEUKtYTin32923978 = -208315325;    int zzEUKtYTin65607080 = -618442665;    int zzEUKtYTin5782869 = -910848820;    int zzEUKtYTin51427228 = -476623500;    int zzEUKtYTin68651601 = -568287084;    int zzEUKtYTin96963086 = -535399329;    int zzEUKtYTin77187061 = -152443711;    int zzEUKtYTin10733495 = -902554992;    int zzEUKtYTin86910470 = -109686761;    int zzEUKtYTin98985852 = -505828945;    int zzEUKtYTin14786026 = -989073323;    int zzEUKtYTin81136570 = -700649165;    int zzEUKtYTin82007862 = -476930686;    int zzEUKtYTin55518513 = -597689184;    int zzEUKtYTin72949538 = -995869291;    int zzEUKtYTin18858342 = -242207521;    int zzEUKtYTin94047614 = -552734899;    int zzEUKtYTin56039696 = -948493894;    int zzEUKtYTin71152638 = -312929137;    int zzEUKtYTin92846258 = -372854161;    int zzEUKtYTin53938446 = -190341740;    int zzEUKtYTin80256087 = -369001618;    int zzEUKtYTin45331385 = -289232893;    int zzEUKtYTin25880172 = -346882679;    int zzEUKtYTin71234639 = -621418867;    int zzEUKtYTin31556197 = -409276506;    int zzEUKtYTin33644988 = -623792903;    int zzEUKtYTin63825717 = -625436276;    int zzEUKtYTin45813320 = -491505807;    int zzEUKtYTin45356872 = -856314024;    int zzEUKtYTin97760467 = -188404255;    int zzEUKtYTin63535004 = -288887127;    int zzEUKtYTin25492143 = -537802359;    int zzEUKtYTin21858582 = -9199975;    int zzEUKtYTin24406051 = -211877017;    int zzEUKtYTin29404384 = -977638597;    int zzEUKtYTin72529451 = -50444578;    int zzEUKtYTin70019779 = -723666813;    int zzEUKtYTin79541926 = -769097105;    int zzEUKtYTin94121995 = -594581947;    int zzEUKtYTin46572621 = -261222900;    int zzEUKtYTin72538594 = -243342038;    int zzEUKtYTin28581531 = -809222925;    int zzEUKtYTin52269401 = -443296076;    int zzEUKtYTin93529231 = -221806919;    int zzEUKtYTin27615761 = -98935270;    int zzEUKtYTin94836311 = -504175014;    int zzEUKtYTin39217115 = -414211723;    int zzEUKtYTin91124836 = -537218967;    int zzEUKtYTin85575519 = -318949608;    int zzEUKtYTin66264260 = 18058938;    int zzEUKtYTin53548342 = -967703487;    int zzEUKtYTin85889279 = -729763617;    int zzEUKtYTin27211205 = 34338339;    int zzEUKtYTin26324493 = -244597943;    int zzEUKtYTin52667891 = -839313707;    int zzEUKtYTin20275696 = -229209772;    int zzEUKtYTin79902696 = -463966141;    int zzEUKtYTin80192588 = -855204634;    int zzEUKtYTin37095405 = -59010579;    int zzEUKtYTin63318098 = -853025212;     zzEUKtYTin15494622 = zzEUKtYTin4233224;     zzEUKtYTin4233224 = zzEUKtYTin62237720;     zzEUKtYTin62237720 = zzEUKtYTin16605941;     zzEUKtYTin16605941 = zzEUKtYTin37210535;     zzEUKtYTin37210535 = zzEUKtYTin95748088;     zzEUKtYTin95748088 = zzEUKtYTin96586637;     zzEUKtYTin96586637 = zzEUKtYTin34195429;     zzEUKtYTin34195429 = zzEUKtYTin79986970;     zzEUKtYTin79986970 = zzEUKtYTin8400371;     zzEUKtYTin8400371 = zzEUKtYTin28380615;     zzEUKtYTin28380615 = zzEUKtYTin27900092;     zzEUKtYTin27900092 = zzEUKtYTin50247181;     zzEUKtYTin50247181 = zzEUKtYTin5668747;     zzEUKtYTin5668747 = zzEUKtYTin7348506;     zzEUKtYTin7348506 = zzEUKtYTin20576922;     zzEUKtYTin20576922 = zzEUKtYTin45549607;     zzEUKtYTin45549607 = zzEUKtYTin2121521;     zzEUKtYTin2121521 = zzEUKtYTin57330028;     zzEUKtYTin57330028 = zzEUKtYTin95011464;     zzEUKtYTin95011464 = zzEUKtYTin78312319;     zzEUKtYTin78312319 = zzEUKtYTin21447007;     zzEUKtYTin21447007 = zzEUKtYTin48193527;     zzEUKtYTin48193527 = zzEUKtYTin91085082;     zzEUKtYTin91085082 = zzEUKtYTin23759682;     zzEUKtYTin23759682 = zzEUKtYTin83272088;     zzEUKtYTin83272088 = zzEUKtYTin15492002;     zzEUKtYTin15492002 = zzEUKtYTin51255253;     zzEUKtYTin51255253 = zzEUKtYTin8315257;     zzEUKtYTin8315257 = zzEUKtYTin8752332;     zzEUKtYTin8752332 = zzEUKtYTin76844174;     zzEUKtYTin76844174 = zzEUKtYTin94735627;     zzEUKtYTin94735627 = zzEUKtYTin64074374;     zzEUKtYTin64074374 = zzEUKtYTin4433861;     zzEUKtYTin4433861 = zzEUKtYTin60311875;     zzEUKtYTin60311875 = zzEUKtYTin9588038;     zzEUKtYTin9588038 = zzEUKtYTin57041917;     zzEUKtYTin57041917 = zzEUKtYTin20057464;     zzEUKtYTin20057464 = zzEUKtYTin80262938;     zzEUKtYTin80262938 = zzEUKtYTin32923978;     zzEUKtYTin32923978 = zzEUKtYTin65607080;     zzEUKtYTin65607080 = zzEUKtYTin5782869;     zzEUKtYTin5782869 = zzEUKtYTin51427228;     zzEUKtYTin51427228 = zzEUKtYTin68651601;     zzEUKtYTin68651601 = zzEUKtYTin96963086;     zzEUKtYTin96963086 = zzEUKtYTin77187061;     zzEUKtYTin77187061 = zzEUKtYTin10733495;     zzEUKtYTin10733495 = zzEUKtYTin86910470;     zzEUKtYTin86910470 = zzEUKtYTin98985852;     zzEUKtYTin98985852 = zzEUKtYTin14786026;     zzEUKtYTin14786026 = zzEUKtYTin81136570;     zzEUKtYTin81136570 = zzEUKtYTin82007862;     zzEUKtYTin82007862 = zzEUKtYTin55518513;     zzEUKtYTin55518513 = zzEUKtYTin72949538;     zzEUKtYTin72949538 = zzEUKtYTin18858342;     zzEUKtYTin18858342 = zzEUKtYTin94047614;     zzEUKtYTin94047614 = zzEUKtYTin56039696;     zzEUKtYTin56039696 = zzEUKtYTin71152638;     zzEUKtYTin71152638 = zzEUKtYTin92846258;     zzEUKtYTin92846258 = zzEUKtYTin53938446;     zzEUKtYTin53938446 = zzEUKtYTin80256087;     zzEUKtYTin80256087 = zzEUKtYTin45331385;     zzEUKtYTin45331385 = zzEUKtYTin25880172;     zzEUKtYTin25880172 = zzEUKtYTin71234639;     zzEUKtYTin71234639 = zzEUKtYTin31556197;     zzEUKtYTin31556197 = zzEUKtYTin33644988;     zzEUKtYTin33644988 = zzEUKtYTin63825717;     zzEUKtYTin63825717 = zzEUKtYTin45813320;     zzEUKtYTin45813320 = zzEUKtYTin45356872;     zzEUKtYTin45356872 = zzEUKtYTin97760467;     zzEUKtYTin97760467 = zzEUKtYTin63535004;     zzEUKtYTin63535004 = zzEUKtYTin25492143;     zzEUKtYTin25492143 = zzEUKtYTin21858582;     zzEUKtYTin21858582 = zzEUKtYTin24406051;     zzEUKtYTin24406051 = zzEUKtYTin29404384;     zzEUKtYTin29404384 = zzEUKtYTin72529451;     zzEUKtYTin72529451 = zzEUKtYTin70019779;     zzEUKtYTin70019779 = zzEUKtYTin79541926;     zzEUKtYTin79541926 = zzEUKtYTin94121995;     zzEUKtYTin94121995 = zzEUKtYTin46572621;     zzEUKtYTin46572621 = zzEUKtYTin72538594;     zzEUKtYTin72538594 = zzEUKtYTin28581531;     zzEUKtYTin28581531 = zzEUKtYTin52269401;     zzEUKtYTin52269401 = zzEUKtYTin93529231;     zzEUKtYTin93529231 = zzEUKtYTin27615761;     zzEUKtYTin27615761 = zzEUKtYTin94836311;     zzEUKtYTin94836311 = zzEUKtYTin39217115;     zzEUKtYTin39217115 = zzEUKtYTin91124836;     zzEUKtYTin91124836 = zzEUKtYTin85575519;     zzEUKtYTin85575519 = zzEUKtYTin66264260;     zzEUKtYTin66264260 = zzEUKtYTin53548342;     zzEUKtYTin53548342 = zzEUKtYTin85889279;     zzEUKtYTin85889279 = zzEUKtYTin27211205;     zzEUKtYTin27211205 = zzEUKtYTin26324493;     zzEUKtYTin26324493 = zzEUKtYTin52667891;     zzEUKtYTin52667891 = zzEUKtYTin20275696;     zzEUKtYTin20275696 = zzEUKtYTin79902696;     zzEUKtYTin79902696 = zzEUKtYTin80192588;     zzEUKtYTin80192588 = zzEUKtYTin37095405;     zzEUKtYTin37095405 = zzEUKtYTin63318098;     zzEUKtYTin63318098 = zzEUKtYTin15494622;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void tAWwwONQaw11905188() {     int wGhALssfXo31475713 = -164957112;    int wGhALssfXo72339913 = -784444381;    int wGhALssfXo34757023 = 57358208;    int wGhALssfXo47801938 = -171908824;    int wGhALssfXo6309441 = -618098180;    int wGhALssfXo58587035 = -308923647;    int wGhALssfXo15233170 = -946582118;    int wGhALssfXo34897833 = -864455070;    int wGhALssfXo44928025 = -401612434;    int wGhALssfXo40333630 = -154693464;    int wGhALssfXo42819994 = -43919346;    int wGhALssfXo46411142 = -726560144;    int wGhALssfXo45889538 = -862805876;    int wGhALssfXo81159900 = -442797245;    int wGhALssfXo72774724 = -254012136;    int wGhALssfXo99749394 = -653393028;    int wGhALssfXo79202568 = -60939906;    int wGhALssfXo62319760 = 87579560;    int wGhALssfXo38887884 = -286524402;    int wGhALssfXo16348026 = -123142548;    int wGhALssfXo98447246 = -778055321;    int wGhALssfXo77330847 = 9888781;    int wGhALssfXo5863496 = -915878518;    int wGhALssfXo32631521 = -825642672;    int wGhALssfXo13238179 = -333392479;    int wGhALssfXo64063915 = -10987510;    int wGhALssfXo47316817 = -511242464;    int wGhALssfXo94297290 = -868614398;    int wGhALssfXo32256185 = -90169370;    int wGhALssfXo93713692 = -355799972;    int wGhALssfXo15742339 = -148399946;    int wGhALssfXo70065121 = -908255945;    int wGhALssfXo92994916 = -978392792;    int wGhALssfXo75850036 = -786270335;    int wGhALssfXo9727050 = -912044293;    int wGhALssfXo89325228 = -396842698;    int wGhALssfXo5982335 = -79992786;    int wGhALssfXo34666912 = -336856605;    int wGhALssfXo96310570 = -240423258;    int wGhALssfXo33723113 = -741194303;    int wGhALssfXo39360133 = -559771131;    int wGhALssfXo61835353 = -557186008;    int wGhALssfXo10102406 = -920697870;    int wGhALssfXo64245248 = -58993499;    int wGhALssfXo42978212 = -244676629;    int wGhALssfXo29329215 = 77897072;    int wGhALssfXo89635467 = 5231037;    int wGhALssfXo67556324 = -456068074;    int wGhALssfXo58730511 = -51272378;    int wGhALssfXo28485407 = 374877;    int wGhALssfXo7360780 = -636393303;    int wGhALssfXo70865361 = -336448796;    int wGhALssfXo17487038 = 34293211;    int wGhALssfXo31386763 = -340663931;    int wGhALssfXo13457942 = -449487949;    int wGhALssfXo54144865 = -74845893;    int wGhALssfXo66476417 = -868565864;    int wGhALssfXo2125502 = -116999121;    int wGhALssfXo34563759 = -838516345;    int wGhALssfXo42245526 = -507110671;    int wGhALssfXo11270218 = -797681184;    int wGhALssfXo20935879 = 22032280;    int wGhALssfXo2641648 = -674285700;    int wGhALssfXo51214332 = 54187537;    int wGhALssfXo24591292 = 93706481;    int wGhALssfXo72754873 = -135663401;    int wGhALssfXo53416225 = -748167352;    int wGhALssfXo70039502 = 23464459;    int wGhALssfXo71432850 = -530752953;    int wGhALssfXo83449495 = -857169439;    int wGhALssfXo93767059 = -473400243;    int wGhALssfXo44535656 = -724083301;    int wGhALssfXo66009190 = -671997182;    int wGhALssfXo5164771 = -545330099;    int wGhALssfXo76987893 = -563371418;    int wGhALssfXo36611893 = -120869313;    int wGhALssfXo67228442 = -69413349;    int wGhALssfXo41618248 = -756885020;    int wGhALssfXo89653308 = -480966043;    int wGhALssfXo83908963 = -311289551;    int wGhALssfXo74428447 = 83781452;    int wGhALssfXo79760493 = 44825610;    int wGhALssfXo35566779 = -717342020;    int wGhALssfXo3770779 = 9455752;    int wGhALssfXo86352913 = -719406670;    int wGhALssfXo44876978 = -811951151;    int wGhALssfXo52578084 = -842549156;    int wGhALssfXo61608154 = -537728861;    int wGhALssfXo62392094 = -236782387;    int wGhALssfXo55582184 = -737198400;    int wGhALssfXo22848812 = -528276834;    int wGhALssfXo3856833 = -962993665;    int wGhALssfXo103153 = -498340260;    int wGhALssfXo54065044 = -733312588;    int wGhALssfXo22452896 = -943513120;    int wGhALssfXo18424254 = -481803411;    int wGhALssfXo59193706 = -882900309;    int wGhALssfXo58888074 = -874885407;    int wGhALssfXo39653957 = -52699981;    int wGhALssfXo70223339 = -164957112;     wGhALssfXo31475713 = wGhALssfXo72339913;     wGhALssfXo72339913 = wGhALssfXo34757023;     wGhALssfXo34757023 = wGhALssfXo47801938;     wGhALssfXo47801938 = wGhALssfXo6309441;     wGhALssfXo6309441 = wGhALssfXo58587035;     wGhALssfXo58587035 = wGhALssfXo15233170;     wGhALssfXo15233170 = wGhALssfXo34897833;     wGhALssfXo34897833 = wGhALssfXo44928025;     wGhALssfXo44928025 = wGhALssfXo40333630;     wGhALssfXo40333630 = wGhALssfXo42819994;     wGhALssfXo42819994 = wGhALssfXo46411142;     wGhALssfXo46411142 = wGhALssfXo45889538;     wGhALssfXo45889538 = wGhALssfXo81159900;     wGhALssfXo81159900 = wGhALssfXo72774724;     wGhALssfXo72774724 = wGhALssfXo99749394;     wGhALssfXo99749394 = wGhALssfXo79202568;     wGhALssfXo79202568 = wGhALssfXo62319760;     wGhALssfXo62319760 = wGhALssfXo38887884;     wGhALssfXo38887884 = wGhALssfXo16348026;     wGhALssfXo16348026 = wGhALssfXo98447246;     wGhALssfXo98447246 = wGhALssfXo77330847;     wGhALssfXo77330847 = wGhALssfXo5863496;     wGhALssfXo5863496 = wGhALssfXo32631521;     wGhALssfXo32631521 = wGhALssfXo13238179;     wGhALssfXo13238179 = wGhALssfXo64063915;     wGhALssfXo64063915 = wGhALssfXo47316817;     wGhALssfXo47316817 = wGhALssfXo94297290;     wGhALssfXo94297290 = wGhALssfXo32256185;     wGhALssfXo32256185 = wGhALssfXo93713692;     wGhALssfXo93713692 = wGhALssfXo15742339;     wGhALssfXo15742339 = wGhALssfXo70065121;     wGhALssfXo70065121 = wGhALssfXo92994916;     wGhALssfXo92994916 = wGhALssfXo75850036;     wGhALssfXo75850036 = wGhALssfXo9727050;     wGhALssfXo9727050 = wGhALssfXo89325228;     wGhALssfXo89325228 = wGhALssfXo5982335;     wGhALssfXo5982335 = wGhALssfXo34666912;     wGhALssfXo34666912 = wGhALssfXo96310570;     wGhALssfXo96310570 = wGhALssfXo33723113;     wGhALssfXo33723113 = wGhALssfXo39360133;     wGhALssfXo39360133 = wGhALssfXo61835353;     wGhALssfXo61835353 = wGhALssfXo10102406;     wGhALssfXo10102406 = wGhALssfXo64245248;     wGhALssfXo64245248 = wGhALssfXo42978212;     wGhALssfXo42978212 = wGhALssfXo29329215;     wGhALssfXo29329215 = wGhALssfXo89635467;     wGhALssfXo89635467 = wGhALssfXo67556324;     wGhALssfXo67556324 = wGhALssfXo58730511;     wGhALssfXo58730511 = wGhALssfXo28485407;     wGhALssfXo28485407 = wGhALssfXo7360780;     wGhALssfXo7360780 = wGhALssfXo70865361;     wGhALssfXo70865361 = wGhALssfXo17487038;     wGhALssfXo17487038 = wGhALssfXo31386763;     wGhALssfXo31386763 = wGhALssfXo13457942;     wGhALssfXo13457942 = wGhALssfXo54144865;     wGhALssfXo54144865 = wGhALssfXo66476417;     wGhALssfXo66476417 = wGhALssfXo2125502;     wGhALssfXo2125502 = wGhALssfXo34563759;     wGhALssfXo34563759 = wGhALssfXo42245526;     wGhALssfXo42245526 = wGhALssfXo11270218;     wGhALssfXo11270218 = wGhALssfXo20935879;     wGhALssfXo20935879 = wGhALssfXo2641648;     wGhALssfXo2641648 = wGhALssfXo51214332;     wGhALssfXo51214332 = wGhALssfXo24591292;     wGhALssfXo24591292 = wGhALssfXo72754873;     wGhALssfXo72754873 = wGhALssfXo53416225;     wGhALssfXo53416225 = wGhALssfXo70039502;     wGhALssfXo70039502 = wGhALssfXo71432850;     wGhALssfXo71432850 = wGhALssfXo83449495;     wGhALssfXo83449495 = wGhALssfXo93767059;     wGhALssfXo93767059 = wGhALssfXo44535656;     wGhALssfXo44535656 = wGhALssfXo66009190;     wGhALssfXo66009190 = wGhALssfXo5164771;     wGhALssfXo5164771 = wGhALssfXo76987893;     wGhALssfXo76987893 = wGhALssfXo36611893;     wGhALssfXo36611893 = wGhALssfXo67228442;     wGhALssfXo67228442 = wGhALssfXo41618248;     wGhALssfXo41618248 = wGhALssfXo89653308;     wGhALssfXo89653308 = wGhALssfXo83908963;     wGhALssfXo83908963 = wGhALssfXo74428447;     wGhALssfXo74428447 = wGhALssfXo79760493;     wGhALssfXo79760493 = wGhALssfXo35566779;     wGhALssfXo35566779 = wGhALssfXo3770779;     wGhALssfXo3770779 = wGhALssfXo86352913;     wGhALssfXo86352913 = wGhALssfXo44876978;     wGhALssfXo44876978 = wGhALssfXo52578084;     wGhALssfXo52578084 = wGhALssfXo61608154;     wGhALssfXo61608154 = wGhALssfXo62392094;     wGhALssfXo62392094 = wGhALssfXo55582184;     wGhALssfXo55582184 = wGhALssfXo22848812;     wGhALssfXo22848812 = wGhALssfXo3856833;     wGhALssfXo3856833 = wGhALssfXo103153;     wGhALssfXo103153 = wGhALssfXo54065044;     wGhALssfXo54065044 = wGhALssfXo22452896;     wGhALssfXo22452896 = wGhALssfXo18424254;     wGhALssfXo18424254 = wGhALssfXo59193706;     wGhALssfXo59193706 = wGhALssfXo58888074;     wGhALssfXo58888074 = wGhALssfXo39653957;     wGhALssfXo39653957 = wGhALssfXo70223339;     wGhALssfXo70223339 = wGhALssfXo31475713;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void oHwzbabMlz26954256() {     int UdnssEXtxO37592820 = -276859000;    int UdnssEXtxO15713193 = -494044162;    int UdnssEXtxO50799207 = -93474713;    int UdnssEXtxO74876718 = -362657454;    int UdnssEXtxO75204929 = -38748051;    int UdnssEXtxO50004237 = -573419882;    int UdnssEXtxO75722135 = 14452905;    int UdnssEXtxO84657723 = -51328983;    int UdnssEXtxO9570520 = -169645100;    int UdnssEXtxO81563289 = -483668941;    int UdnssEXtxO2930285 = 78643067;    int UdnssEXtxO78234184 = -70966346;    int UdnssEXtxO32098656 = -202696964;    int UdnssEXtxO64303576 = -975035813;    int UdnssEXtxO68517151 = -944474303;    int UdnssEXtxO41254788 = -626392572;    int UdnssEXtxO73038571 = -677485018;    int UdnssEXtxO59372913 = -677943083;    int UdnssEXtxO717726 = -692293499;    int UdnssEXtxO96898190 = -480045468;    int UdnssEXtxO87000439 = -633542777;    int UdnssEXtxO63851871 = -998040935;    int UdnssEXtxO41454288 = -662396005;    int UdnssEXtxO16623895 = 52052341;    int UdnssEXtxO56937829 = -706588512;    int UdnssEXtxO88785590 = -989642833;    int UdnssEXtxO45776595 = -411904667;    int UdnssEXtxO7404417 = -934543352;    int UdnssEXtxO98388440 = -312552075;    int UdnssEXtxO62329330 = -173270839;    int UdnssEXtxO7984888 = -61720884;    int UdnssEXtxO67675743 = -617702761;    int UdnssEXtxO2705866 = -871006162;    int UdnssEXtxO70680600 = -537812100;    int UdnssEXtxO71201701 = -450777398;    int UdnssEXtxO58051142 = -610868805;    int UdnssEXtxO87244269 = -33628655;    int UdnssEXtxO68757124 = -108362615;    int UdnssEXtxO69920824 = -234346755;    int UdnssEXtxO21225051 = -114633526;    int UdnssEXtxO45029357 = -625045025;    int UdnssEXtxO93985810 = -827328287;    int UdnssEXtxO88169383 = 98497546;    int UdnssEXtxO51652988 = -78336437;    int UdnssEXtxO54930677 = 93425216;    int UdnssEXtxO41268410 = 92680956;    int UdnssEXtxO7414042 = -113544501;    int UdnssEXtxO75513265 = -465963607;    int UdnssEXtxO68406240 = -137009367;    int UdnssEXtxO41397059 = -86635931;    int UdnssEXtxO43061458 = -478686974;    int UdnssEXtxO81675080 = -137175116;    int UdnssEXtxO65735494 = -857496377;    int UdnssEXtxO27355643 = -661134076;    int UdnssEXtxO39953816 = -50019731;    int UdnssEXtxO73740948 = -278818066;    int UdnssEXtxO74258904 = -831648157;    int UdnssEXtxO34175312 = -45527054;    int UdnssEXtxO17938890 = -656068943;    int UdnssEXtxO86419339 = -49105219;    int UdnssEXtxO4227642 = -61515216;    int UdnssEXtxO68317719 = -51003744;    int UdnssEXtxO86269283 = -738776909;    int UdnssEXtxO47241190 = -996374261;    int UdnssEXtxO73578401 = -321948058;    int UdnssEXtxO35254542 = -303654172;    int UdnssEXtxO75528319 = -199960184;    int UdnssEXtxO61418056 = -664884865;    int UdnssEXtxO93101875 = -424258416;    int UdnssEXtxO10466009 = -233605498;    int UdnssEXtxO54010518 = -492763917;    int UdnssEXtxO4281447 = -469122404;    int UdnssEXtxO89452089 = -343596328;    int UdnssEXtxO79492675 = -477659973;    int UdnssEXtxO51868834 = -855000443;    int UdnssEXtxO93014629 = -806214491;    int UdnssEXtxO75682487 = -996538482;    int UdnssEXtxO89801299 = -484059569;    int UdnssEXtxO61693218 = 58627124;    int UdnssEXtxO15669419 = -699269468;    int UdnssEXtxO81371548 = -776098333;    int UdnssEXtxO70263330 = -945941061;    int UdnssEXtxO38998176 = -697533986;    int UdnssEXtxO56991381 = -125916144;    int UdnssEXtxO19267872 = -694583866;    int UdnssEXtxO26309808 = -924545769;    int UdnssEXtxO1940249 = -760206384;    int UdnssEXtxO75350222 = -109872086;    int UdnssEXtxO30726784 = -387792370;    int UdnssEXtxO97460753 = -71959333;    int UdnssEXtxO83792237 = -779220648;    int UdnssEXtxO53068958 = -988101601;    int UdnssEXtxO50818235 = -452293673;    int UdnssEXtxO83501484 = -85241537;    int UdnssEXtxO16997409 = 46881690;    int UdnssEXtxO76711637 = -474041282;    int UdnssEXtxO7716528 = 11448622;    int UdnssEXtxO40928193 = 94871807;    int UdnssEXtxO78074587 = -756388380;    int UdnssEXtxO19676136 = -276859000;     UdnssEXtxO37592820 = UdnssEXtxO15713193;     UdnssEXtxO15713193 = UdnssEXtxO50799207;     UdnssEXtxO50799207 = UdnssEXtxO74876718;     UdnssEXtxO74876718 = UdnssEXtxO75204929;     UdnssEXtxO75204929 = UdnssEXtxO50004237;     UdnssEXtxO50004237 = UdnssEXtxO75722135;     UdnssEXtxO75722135 = UdnssEXtxO84657723;     UdnssEXtxO84657723 = UdnssEXtxO9570520;     UdnssEXtxO9570520 = UdnssEXtxO81563289;     UdnssEXtxO81563289 = UdnssEXtxO2930285;     UdnssEXtxO2930285 = UdnssEXtxO78234184;     UdnssEXtxO78234184 = UdnssEXtxO32098656;     UdnssEXtxO32098656 = UdnssEXtxO64303576;     UdnssEXtxO64303576 = UdnssEXtxO68517151;     UdnssEXtxO68517151 = UdnssEXtxO41254788;     UdnssEXtxO41254788 = UdnssEXtxO73038571;     UdnssEXtxO73038571 = UdnssEXtxO59372913;     UdnssEXtxO59372913 = UdnssEXtxO717726;     UdnssEXtxO717726 = UdnssEXtxO96898190;     UdnssEXtxO96898190 = UdnssEXtxO87000439;     UdnssEXtxO87000439 = UdnssEXtxO63851871;     UdnssEXtxO63851871 = UdnssEXtxO41454288;     UdnssEXtxO41454288 = UdnssEXtxO16623895;     UdnssEXtxO16623895 = UdnssEXtxO56937829;     UdnssEXtxO56937829 = UdnssEXtxO88785590;     UdnssEXtxO88785590 = UdnssEXtxO45776595;     UdnssEXtxO45776595 = UdnssEXtxO7404417;     UdnssEXtxO7404417 = UdnssEXtxO98388440;     UdnssEXtxO98388440 = UdnssEXtxO62329330;     UdnssEXtxO62329330 = UdnssEXtxO7984888;     UdnssEXtxO7984888 = UdnssEXtxO67675743;     UdnssEXtxO67675743 = UdnssEXtxO2705866;     UdnssEXtxO2705866 = UdnssEXtxO70680600;     UdnssEXtxO70680600 = UdnssEXtxO71201701;     UdnssEXtxO71201701 = UdnssEXtxO58051142;     UdnssEXtxO58051142 = UdnssEXtxO87244269;     UdnssEXtxO87244269 = UdnssEXtxO68757124;     UdnssEXtxO68757124 = UdnssEXtxO69920824;     UdnssEXtxO69920824 = UdnssEXtxO21225051;     UdnssEXtxO21225051 = UdnssEXtxO45029357;     UdnssEXtxO45029357 = UdnssEXtxO93985810;     UdnssEXtxO93985810 = UdnssEXtxO88169383;     UdnssEXtxO88169383 = UdnssEXtxO51652988;     UdnssEXtxO51652988 = UdnssEXtxO54930677;     UdnssEXtxO54930677 = UdnssEXtxO41268410;     UdnssEXtxO41268410 = UdnssEXtxO7414042;     UdnssEXtxO7414042 = UdnssEXtxO75513265;     UdnssEXtxO75513265 = UdnssEXtxO68406240;     UdnssEXtxO68406240 = UdnssEXtxO41397059;     UdnssEXtxO41397059 = UdnssEXtxO43061458;     UdnssEXtxO43061458 = UdnssEXtxO81675080;     UdnssEXtxO81675080 = UdnssEXtxO65735494;     UdnssEXtxO65735494 = UdnssEXtxO27355643;     UdnssEXtxO27355643 = UdnssEXtxO39953816;     UdnssEXtxO39953816 = UdnssEXtxO73740948;     UdnssEXtxO73740948 = UdnssEXtxO74258904;     UdnssEXtxO74258904 = UdnssEXtxO34175312;     UdnssEXtxO34175312 = UdnssEXtxO17938890;     UdnssEXtxO17938890 = UdnssEXtxO86419339;     UdnssEXtxO86419339 = UdnssEXtxO4227642;     UdnssEXtxO4227642 = UdnssEXtxO68317719;     UdnssEXtxO68317719 = UdnssEXtxO86269283;     UdnssEXtxO86269283 = UdnssEXtxO47241190;     UdnssEXtxO47241190 = UdnssEXtxO73578401;     UdnssEXtxO73578401 = UdnssEXtxO35254542;     UdnssEXtxO35254542 = UdnssEXtxO75528319;     UdnssEXtxO75528319 = UdnssEXtxO61418056;     UdnssEXtxO61418056 = UdnssEXtxO93101875;     UdnssEXtxO93101875 = UdnssEXtxO10466009;     UdnssEXtxO10466009 = UdnssEXtxO54010518;     UdnssEXtxO54010518 = UdnssEXtxO4281447;     UdnssEXtxO4281447 = UdnssEXtxO89452089;     UdnssEXtxO89452089 = UdnssEXtxO79492675;     UdnssEXtxO79492675 = UdnssEXtxO51868834;     UdnssEXtxO51868834 = UdnssEXtxO93014629;     UdnssEXtxO93014629 = UdnssEXtxO75682487;     UdnssEXtxO75682487 = UdnssEXtxO89801299;     UdnssEXtxO89801299 = UdnssEXtxO61693218;     UdnssEXtxO61693218 = UdnssEXtxO15669419;     UdnssEXtxO15669419 = UdnssEXtxO81371548;     UdnssEXtxO81371548 = UdnssEXtxO70263330;     UdnssEXtxO70263330 = UdnssEXtxO38998176;     UdnssEXtxO38998176 = UdnssEXtxO56991381;     UdnssEXtxO56991381 = UdnssEXtxO19267872;     UdnssEXtxO19267872 = UdnssEXtxO26309808;     UdnssEXtxO26309808 = UdnssEXtxO1940249;     UdnssEXtxO1940249 = UdnssEXtxO75350222;     UdnssEXtxO75350222 = UdnssEXtxO30726784;     UdnssEXtxO30726784 = UdnssEXtxO97460753;     UdnssEXtxO97460753 = UdnssEXtxO83792237;     UdnssEXtxO83792237 = UdnssEXtxO53068958;     UdnssEXtxO53068958 = UdnssEXtxO50818235;     UdnssEXtxO50818235 = UdnssEXtxO83501484;     UdnssEXtxO83501484 = UdnssEXtxO16997409;     UdnssEXtxO16997409 = UdnssEXtxO76711637;     UdnssEXtxO76711637 = UdnssEXtxO7716528;     UdnssEXtxO7716528 = UdnssEXtxO40928193;     UdnssEXtxO40928193 = UdnssEXtxO78074587;     UdnssEXtxO78074587 = UdnssEXtxO19676136;     UdnssEXtxO19676136 = UdnssEXtxO37592820;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void vnBixYIwRn94245854() {     int MsuNpGxWmH73051788 = -743135900;    int MsuNpGxWmH28985271 = -374595769;    int MsuNpGxWmH88185683 = -859141788;    int MsuNpGxWmH47100074 = -183808526;    int MsuNpGxWmH31490199 = -144346897;    int MsuNpGxWmH86227109 = -835767778;    int MsuNpGxWmH86379542 = -930272829;    int MsuNpGxWmH46789285 = -795563124;    int MsuNpGxWmH11088126 = -657976507;    int MsuNpGxWmH96466001 = -148355939;    int MsuNpGxWmH41112019 = -823364662;    int MsuNpGxWmH78802333 = 64912883;    int MsuNpGxWmH70333301 = -754709469;    int MsuNpGxWmH17444440 = -951399222;    int MsuNpGxWmH26711668 = -347899318;    int MsuNpGxWmH24796089 = -262204179;    int MsuNpGxWmH28874507 = -104459571;    int MsuNpGxWmH59133105 = -751371151;    int MsuNpGxWmH1268056 = 91143080;    int MsuNpGxWmH90735408 = -906606534;    int MsuNpGxWmH87303 = -290817465;    int MsuNpGxWmH67273396 = 15322771;    int MsuNpGxWmH11979668 = -300028189;    int MsuNpGxWmH10416840 = -458772264;    int MsuNpGxWmH64955780 = -730573710;    int MsuNpGxWmH99483761 = -678219640;    int MsuNpGxWmH6197170 = -218188808;    int MsuNpGxWmH48132841 = -4315526;    int MsuNpGxWmH45056655 = -886646877;    int MsuNpGxWmH67862740 = -207778010;    int MsuNpGxWmH26568120 = -613701371;    int MsuNpGxWmH5498762 = -390674175;    int MsuNpGxWmH14923876 = 81397861;    int MsuNpGxWmH429027 = -602505914;    int MsuNpGxWmH37010155 = -401877649;    int MsuNpGxWmH9611986 = -825434111;    int MsuNpGxWmH36656086 = -998324696;    int MsuNpGxWmH19972528 = -91018196;    int MsuNpGxWmH311386 = -985223031;    int MsuNpGxWmH85496583 = -679896072;    int MsuNpGxWmH78480964 = -394243939;    int MsuNpGxWmH83350937 = -421873577;    int MsuNpGxWmH77552762 = -554683240;    int MsuNpGxWmH91784326 = -682668847;    int MsuNpGxWmH54947136 = -833085945;    int MsuNpGxWmH87229738 = 53757323;    int MsuNpGxWmH26759205 = -597530861;    int MsuNpGxWmH93239576 = -632490200;    int MsuNpGxWmH91298906 = -900746247;    int MsuNpGxWmH65926648 = -577662747;    int MsuNpGxWmH23832182 = -352963531;    int MsuNpGxWmH65160553 = -350827462;    int MsuNpGxWmH34356643 = -613541931;    int MsuNpGxWmH43347489 = -852642576;    int MsuNpGxWmH94158552 = -396509877;    int MsuNpGxWmH5778393 = -658458672;    int MsuNpGxWmH17005604 = 25432420;    int MsuNpGxWmH77768843 = -300369525;    int MsuNpGxWmH82144293 = -453234816;    int MsuNpGxWmH32006437 = -466127257;    int MsuNpGxWmH80029940 = -517578971;    int MsuNpGxWmH38246701 = -825957304;    int MsuNpGxWmH1732630 = -908916247;    int MsuNpGxWmH43225385 = -350198498;    int MsuNpGxWmH69897882 = -534654569;    int MsuNpGxWmH35613258 = -332690487;    int MsuNpGxWmH63878457 = 83515022;    int MsuNpGxWmH69904275 = -52203556;    int MsuNpGxWmH80434284 = -449521574;    int MsuNpGxWmH17099682 = -522465207;    int MsuNpGxWmH88140002 = -263879483;    int MsuNpGxWmH8901980 = 86558625;    int MsuNpGxWmH58821719 = -766148121;    int MsuNpGxWmH15771473 = -228960849;    int MsuNpGxWmH12254445 = -412362595;    int MsuNpGxWmH16736365 = -868943888;    int MsuNpGxWmH89720634 = -429993990;    int MsuNpGxWmH20195341 = -617359343;    int MsuNpGxWmH55469704 = -625686319;    int MsuNpGxWmH77726041 = -684331034;    int MsuNpGxWmH72724556 = 19311221;    int MsuNpGxWmH12957593 = -585698608;    int MsuNpGxWmH56833934 = -103569280;    int MsuNpGxWmH79130006 = -208984131;    int MsuNpGxWmH44030559 = -854814479;    int MsuNpGxWmH61407566 = -162873909;    int MsuNpGxWmH71142118 = -777132245;    int MsuNpGxWmH71576387 = -65959564;    int MsuNpGxWmH6270474 = -105996037;    int MsuNpGxWmH31231763 = -743418978;    int MsuNpGxWmH92606382 = -750866532;    int MsuNpGxWmH58887243 = -597955171;    int MsuNpGxWmH37828235 = -637783381;    int MsuNpGxWmH68304949 = -419095775;    int MsuNpGxWmH5466644 = -62317102;    int MsuNpGxWmH40234264 = -568286636;    int MsuNpGxWmH81618308 = -512957331;    int MsuNpGxWmH34327377 = -104484742;    int MsuNpGxWmH21886445 = -48014279;    int MsuNpGxWmH19333878 = -743135900;     MsuNpGxWmH73051788 = MsuNpGxWmH28985271;     MsuNpGxWmH28985271 = MsuNpGxWmH88185683;     MsuNpGxWmH88185683 = MsuNpGxWmH47100074;     MsuNpGxWmH47100074 = MsuNpGxWmH31490199;     MsuNpGxWmH31490199 = MsuNpGxWmH86227109;     MsuNpGxWmH86227109 = MsuNpGxWmH86379542;     MsuNpGxWmH86379542 = MsuNpGxWmH46789285;     MsuNpGxWmH46789285 = MsuNpGxWmH11088126;     MsuNpGxWmH11088126 = MsuNpGxWmH96466001;     MsuNpGxWmH96466001 = MsuNpGxWmH41112019;     MsuNpGxWmH41112019 = MsuNpGxWmH78802333;     MsuNpGxWmH78802333 = MsuNpGxWmH70333301;     MsuNpGxWmH70333301 = MsuNpGxWmH17444440;     MsuNpGxWmH17444440 = MsuNpGxWmH26711668;     MsuNpGxWmH26711668 = MsuNpGxWmH24796089;     MsuNpGxWmH24796089 = MsuNpGxWmH28874507;     MsuNpGxWmH28874507 = MsuNpGxWmH59133105;     MsuNpGxWmH59133105 = MsuNpGxWmH1268056;     MsuNpGxWmH1268056 = MsuNpGxWmH90735408;     MsuNpGxWmH90735408 = MsuNpGxWmH87303;     MsuNpGxWmH87303 = MsuNpGxWmH67273396;     MsuNpGxWmH67273396 = MsuNpGxWmH11979668;     MsuNpGxWmH11979668 = MsuNpGxWmH10416840;     MsuNpGxWmH10416840 = MsuNpGxWmH64955780;     MsuNpGxWmH64955780 = MsuNpGxWmH99483761;     MsuNpGxWmH99483761 = MsuNpGxWmH6197170;     MsuNpGxWmH6197170 = MsuNpGxWmH48132841;     MsuNpGxWmH48132841 = MsuNpGxWmH45056655;     MsuNpGxWmH45056655 = MsuNpGxWmH67862740;     MsuNpGxWmH67862740 = MsuNpGxWmH26568120;     MsuNpGxWmH26568120 = MsuNpGxWmH5498762;     MsuNpGxWmH5498762 = MsuNpGxWmH14923876;     MsuNpGxWmH14923876 = MsuNpGxWmH429027;     MsuNpGxWmH429027 = MsuNpGxWmH37010155;     MsuNpGxWmH37010155 = MsuNpGxWmH9611986;     MsuNpGxWmH9611986 = MsuNpGxWmH36656086;     MsuNpGxWmH36656086 = MsuNpGxWmH19972528;     MsuNpGxWmH19972528 = MsuNpGxWmH311386;     MsuNpGxWmH311386 = MsuNpGxWmH85496583;     MsuNpGxWmH85496583 = MsuNpGxWmH78480964;     MsuNpGxWmH78480964 = MsuNpGxWmH83350937;     MsuNpGxWmH83350937 = MsuNpGxWmH77552762;     MsuNpGxWmH77552762 = MsuNpGxWmH91784326;     MsuNpGxWmH91784326 = MsuNpGxWmH54947136;     MsuNpGxWmH54947136 = MsuNpGxWmH87229738;     MsuNpGxWmH87229738 = MsuNpGxWmH26759205;     MsuNpGxWmH26759205 = MsuNpGxWmH93239576;     MsuNpGxWmH93239576 = MsuNpGxWmH91298906;     MsuNpGxWmH91298906 = MsuNpGxWmH65926648;     MsuNpGxWmH65926648 = MsuNpGxWmH23832182;     MsuNpGxWmH23832182 = MsuNpGxWmH65160553;     MsuNpGxWmH65160553 = MsuNpGxWmH34356643;     MsuNpGxWmH34356643 = MsuNpGxWmH43347489;     MsuNpGxWmH43347489 = MsuNpGxWmH94158552;     MsuNpGxWmH94158552 = MsuNpGxWmH5778393;     MsuNpGxWmH5778393 = MsuNpGxWmH17005604;     MsuNpGxWmH17005604 = MsuNpGxWmH77768843;     MsuNpGxWmH77768843 = MsuNpGxWmH82144293;     MsuNpGxWmH82144293 = MsuNpGxWmH32006437;     MsuNpGxWmH32006437 = MsuNpGxWmH80029940;     MsuNpGxWmH80029940 = MsuNpGxWmH38246701;     MsuNpGxWmH38246701 = MsuNpGxWmH1732630;     MsuNpGxWmH1732630 = MsuNpGxWmH43225385;     MsuNpGxWmH43225385 = MsuNpGxWmH69897882;     MsuNpGxWmH69897882 = MsuNpGxWmH35613258;     MsuNpGxWmH35613258 = MsuNpGxWmH63878457;     MsuNpGxWmH63878457 = MsuNpGxWmH69904275;     MsuNpGxWmH69904275 = MsuNpGxWmH80434284;     MsuNpGxWmH80434284 = MsuNpGxWmH17099682;     MsuNpGxWmH17099682 = MsuNpGxWmH88140002;     MsuNpGxWmH88140002 = MsuNpGxWmH8901980;     MsuNpGxWmH8901980 = MsuNpGxWmH58821719;     MsuNpGxWmH58821719 = MsuNpGxWmH15771473;     MsuNpGxWmH15771473 = MsuNpGxWmH12254445;     MsuNpGxWmH12254445 = MsuNpGxWmH16736365;     MsuNpGxWmH16736365 = MsuNpGxWmH89720634;     MsuNpGxWmH89720634 = MsuNpGxWmH20195341;     MsuNpGxWmH20195341 = MsuNpGxWmH55469704;     MsuNpGxWmH55469704 = MsuNpGxWmH77726041;     MsuNpGxWmH77726041 = MsuNpGxWmH72724556;     MsuNpGxWmH72724556 = MsuNpGxWmH12957593;     MsuNpGxWmH12957593 = MsuNpGxWmH56833934;     MsuNpGxWmH56833934 = MsuNpGxWmH79130006;     MsuNpGxWmH79130006 = MsuNpGxWmH44030559;     MsuNpGxWmH44030559 = MsuNpGxWmH61407566;     MsuNpGxWmH61407566 = MsuNpGxWmH71142118;     MsuNpGxWmH71142118 = MsuNpGxWmH71576387;     MsuNpGxWmH71576387 = MsuNpGxWmH6270474;     MsuNpGxWmH6270474 = MsuNpGxWmH31231763;     MsuNpGxWmH31231763 = MsuNpGxWmH92606382;     MsuNpGxWmH92606382 = MsuNpGxWmH58887243;     MsuNpGxWmH58887243 = MsuNpGxWmH37828235;     MsuNpGxWmH37828235 = MsuNpGxWmH68304949;     MsuNpGxWmH68304949 = MsuNpGxWmH5466644;     MsuNpGxWmH5466644 = MsuNpGxWmH40234264;     MsuNpGxWmH40234264 = MsuNpGxWmH81618308;     MsuNpGxWmH81618308 = MsuNpGxWmH34327377;     MsuNpGxWmH34327377 = MsuNpGxWmH21886445;     MsuNpGxWmH21886445 = MsuNpGxWmH19333878;     MsuNpGxWmH19333878 = MsuNpGxWmH73051788;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void GsYlnjmzai9294923() {     int NHbXFQvuserPRvnEbSe79168895 = -855037789;    int NHbXFQvuserPRvnEbSe72358550 = -84195549;    int NHbXFQvuserPRvnEbSe4227867 = 90025291;    int NHbXFQvuserPRvnEbSe74174854 = -374557156;    int NHbXFQvuserPRvnEbSe385688 = -664996768;    int NHbXFQvuserPRvnEbSe77644311 = -264013;    int NHbXFQvuserPRvnEbSe46868508 = 30762194;    int NHbXFQvuserPRvnEbSe96549175 = 17562963;    int NHbXFQvuserPRvnEbSe75730620 = -426009173;    int NHbXFQvuserPRvnEbSe37695661 = -477331417;    int NHbXFQvuserPRvnEbSe1222310 = -700802249;    int NHbXFQvuserPRvnEbSe10625376 = -379493319;    int NHbXFQvuserPRvnEbSe56542420 = -94600558;    int NHbXFQvuserPRvnEbSe588117 = -383637790;    int NHbXFQvuserPRvnEbSe22454094 = 61638516;    int NHbXFQvuserPRvnEbSe66301483 = -235203722;    int NHbXFQvuserPRvnEbSe22710511 = -721004684;    int NHbXFQvuserPRvnEbSe56186258 = -416893794;    int NHbXFQvuserPRvnEbSe63097897 = -314626017;    int NHbXFQvuserPRvnEbSe71285573 = -163509453;    int NHbXFQvuserPRvnEbSe88640495 = -146304921;    int NHbXFQvuserPRvnEbSe53794420 = -992606945;    int NHbXFQvuserPRvnEbSe47570459 = -46545676;    int NHbXFQvuserPRvnEbSe94409213 = -681077251;    int NHbXFQvuserPRvnEbSe8655430 = -3769743;    int NHbXFQvuserPRvnEbSe24205437 = -556874963;    int NHbXFQvuserPRvnEbSe4656948 = -118851011;    int NHbXFQvuserPRvnEbSe61239966 = -70244480;    int NHbXFQvuserPRvnEbSe11188911 = -9029582;    int NHbXFQvuserPRvnEbSe36478377 = -25248877;    int NHbXFQvuserPRvnEbSe18810669 = -527022309;    int NHbXFQvuserPRvnEbSe3109384 = -100120991;    int NHbXFQvuserPRvnEbSe24634825 = -911215510;    int NHbXFQvuserPRvnEbSe95259590 = -354047679;    int NHbXFQvuserPRvnEbSe98484807 = 59389246;    int NHbXFQvuserPRvnEbSe78337899 = 60539781;    int NHbXFQvuserPRvnEbSe17918021 = -951960565;    int NHbXFQvuserPRvnEbSe54062741 = -962524206;    int NHbXFQvuserPRvnEbSe73921639 = -979146528;    int NHbXFQvuserPRvnEbSe72998521 = -53335294;    int NHbXFQvuserPRvnEbSe84150188 = -459517834;    int NHbXFQvuserPRvnEbSe15501394 = -692015856;    int NHbXFQvuserPRvnEbSe55619740 = -635487823;    int NHbXFQvuserPRvnEbSe79192067 = -702011785;    int NHbXFQvuserPRvnEbSe66899601 = -494984099;    int NHbXFQvuserPRvnEbSe99168933 = 68541207;    int NHbXFQvuserPRvnEbSe44537780 = -716306399;    int NHbXFQvuserPRvnEbSe1196518 = -642385732;    int NHbXFQvuserPRvnEbSe974636 = -986483235;    int NHbXFQvuserPRvnEbSe78838301 = -664673555;    int NHbXFQvuserPRvnEbSe59532860 = -195257203;    int NHbXFQvuserPRvnEbSe75970272 = -151553782;    int NHbXFQvuserPRvnEbSe82605100 = -405331519;    int NHbXFQvuserPRvnEbSe39316370 = -73112721;    int NHbXFQvuserPRvnEbSe20654428 = 2958341;    int NHbXFQvuserPRvnEbSe25374475 = -862430844;    int NHbXFQvuserPRvnEbSe24788091 = 62350126;    int NHbXFQvuserPRvnEbSe9818654 = -228897459;    int NHbXFQvuserPRvnEbSe65519424 = -270787413;    int NHbXFQvuserPRvnEbSe76180250 = -8121805;    int NHbXFQvuserPRvnEbSe72987364 = -881413003;    int NHbXFQvuserPRvnEbSe85628541 = -898993327;    int NHbXFQvuserPRvnEbSe85360264 = -973407456;    int NHbXFQvuserPRvnEbSe39252244 = -300760296;    int NHbXFQvuserPRvnEbSe18884992 = -950309108;    int NHbXFQvuserPRvnEbSe98112926 = -500681258;    int NHbXFQvuserPRvnEbSe85990551 = -468277810;    int NHbXFQvuserPRvnEbSe61282829 = -740552880;    int NHbXFQvuserPRvnEbSe2103310 = -343027037;    int NHbXFQvuserPRvnEbSe44116195 = -998901266;    int NHbXFQvuserPRvnEbSe48383462 = -283243157;    int NHbXFQvuserPRvnEbSe68647770 = -758480479;    int NHbXFQvuserPRvnEbSe82264618 = -437747266;    int NHbXFQvuserPRvnEbSe90099376 = -161290723;    int NHbXFQvuserPRvnEbSe87135385 = -703991620;    int NHbXFQvuserPRvnEbSe73139101 = -454289066;    int NHbXFQvuserPRvnEbSe98174679 = -257119122;    int NHbXFQvuserPRvnEbSe68378392 = -344533891;    int NHbXFQvuserPRvnEbSe27509613 = -86093153;    int NHbXFQvuserPRvnEbSe9486497 = 27689049;    int NHbXFQvuserPRvnEbSe79667657 = -840568565;    int NHbXFQvuserPRvnEbSe3460430 = -476465279;    int NHbXFQvuserPRvnEbSe60265331 = -83761245;    int NHbXFQvuserPRvnEbSe32350610 = -344356027;    int NHbXFQvuserPRvnEbSe76945517 = -829991675;    int NHbXFQvuserPRvnEbSe42840397 = -275468527;    int NHbXFQvuserPRvnEbSe20504283 = -694789473;    int NHbXFQvuserPRvnEbSe85318455 = -738102789;    int NHbXFQvuserPRvnEbSe74605163 = -257006020;    int NHbXFQvuserPRvnEbSe73110332 = -78179911;    int NHbXFQvuserPRvnEbSe53549808 = 98189655;    int NHbXFQvuserPRvnEbSe8099368 = -623063107;    int NHbXFQvuserPRvnEbSe88543316 = -591736793;    int NHbXFQvuserPRvnEbSe97741389 = -871024724;    int NHbXFQvuserPRvnEbSe11157 = -171922292;    int NHbXFQvuserPRvnEbSe98521646 = -560524507;    int NHbXFQvuserPRvnEbSe30141130 = -718608401;    int NHbXFQvuserPRvnEbSe16367497 = -234727528;    int NHbXFQvuserPRvnEbSe60307075 = -751702677;    int NHbXFQvuserPRvnEbSe68786674 = -855037789;     NHbXFQvuserPRvnEbSe79168895 = NHbXFQvuserPRvnEbSe72358550;     NHbXFQvuserPRvnEbSe72358550 = NHbXFQvuserPRvnEbSe4227867;     NHbXFQvuserPRvnEbSe4227867 = NHbXFQvuserPRvnEbSe74174854;     NHbXFQvuserPRvnEbSe74174854 = NHbXFQvuserPRvnEbSe385688;     NHbXFQvuserPRvnEbSe385688 = NHbXFQvuserPRvnEbSe77644311;     NHbXFQvuserPRvnEbSe77644311 = NHbXFQvuserPRvnEbSe46868508;     NHbXFQvuserPRvnEbSe46868508 = NHbXFQvuserPRvnEbSe96549175;     NHbXFQvuserPRvnEbSe96549175 = NHbXFQvuserPRvnEbSe75730620;     NHbXFQvuserPRvnEbSe75730620 = NHbXFQvuserPRvnEbSe37695661;     NHbXFQvuserPRvnEbSe37695661 = NHbXFQvuserPRvnEbSe1222310;     NHbXFQvuserPRvnEbSe1222310 = NHbXFQvuserPRvnEbSe10625376;     NHbXFQvuserPRvnEbSe10625376 = NHbXFQvuserPRvnEbSe56542420;     NHbXFQvuserPRvnEbSe56542420 = NHbXFQvuserPRvnEbSe588117;     NHbXFQvuserPRvnEbSe588117 = NHbXFQvuserPRvnEbSe22454094;     NHbXFQvuserPRvnEbSe22454094 = NHbXFQvuserPRvnEbSe66301483;     NHbXFQvuserPRvnEbSe66301483 = NHbXFQvuserPRvnEbSe22710511;     NHbXFQvuserPRvnEbSe22710511 = NHbXFQvuserPRvnEbSe56186258;     NHbXFQvuserPRvnEbSe56186258 = NHbXFQvuserPRvnEbSe63097897;     NHbXFQvuserPRvnEbSe63097897 = NHbXFQvuserPRvnEbSe71285573;     NHbXFQvuserPRvnEbSe71285573 = NHbXFQvuserPRvnEbSe88640495;     NHbXFQvuserPRvnEbSe88640495 = NHbXFQvuserPRvnEbSe53794420;     NHbXFQvuserPRvnEbSe53794420 = NHbXFQvuserPRvnEbSe47570459;     NHbXFQvuserPRvnEbSe47570459 = NHbXFQvuserPRvnEbSe94409213;     NHbXFQvuserPRvnEbSe94409213 = NHbXFQvuserPRvnEbSe8655430;     NHbXFQvuserPRvnEbSe8655430 = NHbXFQvuserPRvnEbSe24205437;     NHbXFQvuserPRvnEbSe24205437 = NHbXFQvuserPRvnEbSe4656948;     NHbXFQvuserPRvnEbSe4656948 = NHbXFQvuserPRvnEbSe61239966;     NHbXFQvuserPRvnEbSe61239966 = NHbXFQvuserPRvnEbSe11188911;     NHbXFQvuserPRvnEbSe11188911 = NHbXFQvuserPRvnEbSe36478377;     NHbXFQvuserPRvnEbSe36478377 = NHbXFQvuserPRvnEbSe18810669;     NHbXFQvuserPRvnEbSe18810669 = NHbXFQvuserPRvnEbSe3109384;     NHbXFQvuserPRvnEbSe3109384 = NHbXFQvuserPRvnEbSe24634825;     NHbXFQvuserPRvnEbSe24634825 = NHbXFQvuserPRvnEbSe95259590;     NHbXFQvuserPRvnEbSe95259590 = NHbXFQvuserPRvnEbSe98484807;     NHbXFQvuserPRvnEbSe98484807 = NHbXFQvuserPRvnEbSe78337899;     NHbXFQvuserPRvnEbSe78337899 = NHbXFQvuserPRvnEbSe17918021;     NHbXFQvuserPRvnEbSe17918021 = NHbXFQvuserPRvnEbSe54062741;     NHbXFQvuserPRvnEbSe54062741 = NHbXFQvuserPRvnEbSe73921639;     NHbXFQvuserPRvnEbSe73921639 = NHbXFQvuserPRvnEbSe72998521;     NHbXFQvuserPRvnEbSe72998521 = NHbXFQvuserPRvnEbSe84150188;     NHbXFQvuserPRvnEbSe84150188 = NHbXFQvuserPRvnEbSe15501394;     NHbXFQvuserPRvnEbSe15501394 = NHbXFQvuserPRvnEbSe55619740;     NHbXFQvuserPRvnEbSe55619740 = NHbXFQvuserPRvnEbSe79192067;     NHbXFQvuserPRvnEbSe79192067 = NHbXFQvuserPRvnEbSe66899601;     NHbXFQvuserPRvnEbSe66899601 = NHbXFQvuserPRvnEbSe99168933;     NHbXFQvuserPRvnEbSe99168933 = NHbXFQvuserPRvnEbSe44537780;     NHbXFQvuserPRvnEbSe44537780 = NHbXFQvuserPRvnEbSe1196518;     NHbXFQvuserPRvnEbSe1196518 = NHbXFQvuserPRvnEbSe974636;     NHbXFQvuserPRvnEbSe974636 = NHbXFQvuserPRvnEbSe78838301;     NHbXFQvuserPRvnEbSe78838301 = NHbXFQvuserPRvnEbSe59532860;     NHbXFQvuserPRvnEbSe59532860 = NHbXFQvuserPRvnEbSe75970272;     NHbXFQvuserPRvnEbSe75970272 = NHbXFQvuserPRvnEbSe82605100;     NHbXFQvuserPRvnEbSe82605100 = NHbXFQvuserPRvnEbSe39316370;     NHbXFQvuserPRvnEbSe39316370 = NHbXFQvuserPRvnEbSe20654428;     NHbXFQvuserPRvnEbSe20654428 = NHbXFQvuserPRvnEbSe25374475;     NHbXFQvuserPRvnEbSe25374475 = NHbXFQvuserPRvnEbSe24788091;     NHbXFQvuserPRvnEbSe24788091 = NHbXFQvuserPRvnEbSe9818654;     NHbXFQvuserPRvnEbSe9818654 = NHbXFQvuserPRvnEbSe65519424;     NHbXFQvuserPRvnEbSe65519424 = NHbXFQvuserPRvnEbSe76180250;     NHbXFQvuserPRvnEbSe76180250 = NHbXFQvuserPRvnEbSe72987364;     NHbXFQvuserPRvnEbSe72987364 = NHbXFQvuserPRvnEbSe85628541;     NHbXFQvuserPRvnEbSe85628541 = NHbXFQvuserPRvnEbSe85360264;     NHbXFQvuserPRvnEbSe85360264 = NHbXFQvuserPRvnEbSe39252244;     NHbXFQvuserPRvnEbSe39252244 = NHbXFQvuserPRvnEbSe18884992;     NHbXFQvuserPRvnEbSe18884992 = NHbXFQvuserPRvnEbSe98112926;     NHbXFQvuserPRvnEbSe98112926 = NHbXFQvuserPRvnEbSe85990551;     NHbXFQvuserPRvnEbSe85990551 = NHbXFQvuserPRvnEbSe61282829;     NHbXFQvuserPRvnEbSe61282829 = NHbXFQvuserPRvnEbSe2103310;     NHbXFQvuserPRvnEbSe2103310 = NHbXFQvuserPRvnEbSe44116195;     NHbXFQvuserPRvnEbSe44116195 = NHbXFQvuserPRvnEbSe48383462;     NHbXFQvuserPRvnEbSe48383462 = NHbXFQvuserPRvnEbSe68647770;     NHbXFQvuserPRvnEbSe68647770 = NHbXFQvuserPRvnEbSe82264618;     NHbXFQvuserPRvnEbSe82264618 = NHbXFQvuserPRvnEbSe90099376;     NHbXFQvuserPRvnEbSe90099376 = NHbXFQvuserPRvnEbSe87135385;     NHbXFQvuserPRvnEbSe87135385 = NHbXFQvuserPRvnEbSe73139101;     NHbXFQvuserPRvnEbSe73139101 = NHbXFQvuserPRvnEbSe98174679;     NHbXFQvuserPRvnEbSe98174679 = NHbXFQvuserPRvnEbSe68378392;     NHbXFQvuserPRvnEbSe68378392 = NHbXFQvuserPRvnEbSe27509613;     NHbXFQvuserPRvnEbSe27509613 = NHbXFQvuserPRvnEbSe9486497;     NHbXFQvuserPRvnEbSe9486497 = NHbXFQvuserPRvnEbSe79667657;     NHbXFQvuserPRvnEbSe79667657 = NHbXFQvuserPRvnEbSe3460430;     NHbXFQvuserPRvnEbSe3460430 = NHbXFQvuserPRvnEbSe60265331;     NHbXFQvuserPRvnEbSe60265331 = NHbXFQvuserPRvnEbSe32350610;     NHbXFQvuserPRvnEbSe32350610 = NHbXFQvuserPRvnEbSe76945517;     NHbXFQvuserPRvnEbSe76945517 = NHbXFQvuserPRvnEbSe42840397;     NHbXFQvuserPRvnEbSe42840397 = NHbXFQvuserPRvnEbSe20504283;     NHbXFQvuserPRvnEbSe20504283 = NHbXFQvuserPRvnEbSe85318455;     NHbXFQvuserPRvnEbSe85318455 = NHbXFQvuserPRvnEbSe74605163;     NHbXFQvuserPRvnEbSe74605163 = NHbXFQvuserPRvnEbSe73110332;     NHbXFQvuserPRvnEbSe73110332 = NHbXFQvuserPRvnEbSe53549808;     NHbXFQvuserPRvnEbSe53549808 = NHbXFQvuserPRvnEbSe8099368;     NHbXFQvuserPRvnEbSe8099368 = NHbXFQvuserPRvnEbSe88543316;     NHbXFQvuserPRvnEbSe88543316 = NHbXFQvuserPRvnEbSe97741389;     NHbXFQvuserPRvnEbSe97741389 = NHbXFQvuserPRvnEbSe11157;     NHbXFQvuserPRvnEbSe11157 = NHbXFQvuserPRvnEbSe98521646;     NHbXFQvuserPRvnEbSe98521646 = NHbXFQvuserPRvnEbSe30141130;     NHbXFQvuserPRvnEbSe30141130 = NHbXFQvuserPRvnEbSe16367497;     NHbXFQvuserPRvnEbSe16367497 = NHbXFQvuserPRvnEbSe60307075;     NHbXFQvuserPRvnEbSe60307075 = NHbXFQvuserPRvnEbSe68786674;     NHbXFQvuserPRvnEbSe68786674 = NHbXFQvuserPRvnEbSe79168895;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void OKraBnbjJS76586522() {     int NJuhFzVsFtQvVxqYXgI14627864 = -221314689;    int NJuhFzVsFtQvVxqYXgI85630628 = 35252844;    int NJuhFzVsFtQvVxqYXgI41614344 = -675641784;    int NJuhFzVsFtQvVxqYXgI46398209 = -195708227;    int NJuhFzVsFtQvVxqYXgI56670956 = -770595613;    int NJuhFzVsFtQvVxqYXgI13867184 = -262611908;    int NJuhFzVsFtQvVxqYXgI57525914 = -913963541;    int NJuhFzVsFtQvVxqYXgI58680736 = -726671177;    int NJuhFzVsFtQvVxqYXgI77248226 = -914340580;    int NJuhFzVsFtQvVxqYXgI52598373 = -142018415;    int NJuhFzVsFtQvVxqYXgI39404044 = -502809978;    int NJuhFzVsFtQvVxqYXgI11193524 = -243614090;    int NJuhFzVsFtQvVxqYXgI94777065 = -646613063;    int NJuhFzVsFtQvVxqYXgI53728980 = -360001200;    int NJuhFzVsFtQvVxqYXgI80648610 = -441786499;    int NJuhFzVsFtQvVxqYXgI49842784 = -971015329;    int NJuhFzVsFtQvVxqYXgI78546446 = -147979237;    int NJuhFzVsFtQvVxqYXgI55946449 = -490321863;    int NJuhFzVsFtQvVxqYXgI63648227 = -631189438;    int NJuhFzVsFtQvVxqYXgI65122792 = -590070519;    int NJuhFzVsFtQvVxqYXgI1727359 = -903579610;    int NJuhFzVsFtQvVxqYXgI57215944 = 20756761;    int NJuhFzVsFtQvVxqYXgI18095839 = -784177860;    int NJuhFzVsFtQvVxqYXgI88202159 = -91901856;    int NJuhFzVsFtQvVxqYXgI16673381 = -27754942;    int NJuhFzVsFtQvVxqYXgI34903609 = -245451770;    int NJuhFzVsFtQvVxqYXgI65077521 = 74864849;    int NJuhFzVsFtQvVxqYXgI1968392 = -240016654;    int NJuhFzVsFtQvVxqYXgI57857125 = -583124384;    int NJuhFzVsFtQvVxqYXgI42011788 = -59756048;    int NJuhFzVsFtQvVxqYXgI37393901 = 20997204;    int NJuhFzVsFtQvVxqYXgI40932402 = -973092405;    int NJuhFzVsFtQvVxqYXgI36852836 = 41188513;    int NJuhFzVsFtQvVxqYXgI25008018 = -418741492;    int NJuhFzVsFtQvVxqYXgI64293261 = -991711005;    int NJuhFzVsFtQvVxqYXgI29898743 = -154025524;    int NJuhFzVsFtQvVxqYXgI67329837 = -816656606;    int NJuhFzVsFtQvVxqYXgI5278144 = -945179787;    int NJuhFzVsFtQvVxqYXgI4312201 = -630022805;    int NJuhFzVsFtQvVxqYXgI37270053 = -618597841;    int NJuhFzVsFtQvVxqYXgI17601796 = -228716748;    int NJuhFzVsFtQvVxqYXgI4866521 = -286561146;    int NJuhFzVsFtQvVxqYXgI45003119 = -188668609;    int NJuhFzVsFtQvVxqYXgI19323405 = -206344195;    int NJuhFzVsFtQvVxqYXgI66916059 = -321495261;    int NJuhFzVsFtQvVxqYXgI45130262 = 29617575;    int NJuhFzVsFtQvVxqYXgI63882943 = -100292759;    int NJuhFzVsFtQvVxqYXgI18922830 = -808912326;    int NJuhFzVsFtQvVxqYXgI23867302 = -650220115;    int NJuhFzVsFtQvVxqYXgI3367891 = -55700371;    int NJuhFzVsFtQvVxqYXgI40303583 = -69533760;    int NJuhFzVsFtQvVxqYXgI59455745 = -365206129;    int NJuhFzVsFtQvVxqYXgI51226249 = -161377073;    int NJuhFzVsFtQvVxqYXgI55308216 = -264621221;    int NJuhFzVsFtQvVxqYXgI74859163 = -343531805;    int NJuhFzVsFtQvVxqYXgI57411919 = -142071450;    int NJuhFzVsFtQvVxqYXgI67534789 = -180569296;    int NJuhFzVsFtQvVxqYXgI53412185 = -483739929;    int NJuhFzVsFtQvVxqYXgI29724828 = -67953286;    int NJuhFzVsFtQvVxqYXgI21767348 = -425143844;    int NJuhFzVsFtQvVxqYXgI48789662 = -237476757;    int NJuhFzVsFtQvVxqYXgI55557523 = -573946887;    int NJuhFzVsFtQvVxqYXgI823611 = -43546793;    int NJuhFzVsFtQvVxqYXgI35236438 = -754584532;    int NJuhFzVsFtQvVxqYXgI15204473 = -63015619;    int NJuhFzVsFtQvVxqYXgI98471642 = -529717573;    int NJuhFzVsFtQvVxqYXgI74340688 = -184802604;    int NJuhFzVsFtQvVxqYXgI69769048 = -127871571;    int NJuhFzVsFtQvVxqYXgI89435718 = -368290195;    int NJuhFzVsFtQvVxqYXgI50749868 = -187760975;    int NJuhFzVsFtQvVxqYXgI82512946 = -54358724;    int NJuhFzVsFtQvVxqYXgI73268302 = -202799450;    int NJuhFzVsFtQvVxqYXgI51634248 = -860299059;    int NJuhFzVsFtQvVxqYXgI26378175 = 87408402;    int NJuhFzVsFtQvVxqYXgI47520996 = -261353771;    int NJuhFzVsFtQvVxqYXgI96860837 = -517018464;    int NJuhFzVsFtQvVxqYXgI12212826 = -790574630;    int NJuhFzVsFtQvVxqYXgI98772434 = -477833666;    int NJuhFzVsFtQvVxqYXgI21286100 = -770406595;    int NJuhFzVsFtQvVxqYXgI71543119 = 42627483;    int NJuhFzVsFtQvVxqYXgI71020665 = -45159011;    int NJuhFzVsFtQvVxqYXgI46154692 = -116222826;    int NJuhFzVsFtQvVxqYXgI78101089 = -589796540;    int NJuhFzVsFtQvVxqYXgI54489235 = -427424014;    int NJuhFzVsFtQvVxqYXgI1708205 = -990222288;    int NJuhFzVsFtQvVxqYXgI77938155 = -613796668;    int NJuhFzVsFtQvVxqYXgI89706152 = -711715333;    int NJuhFzVsFtQvVxqYXgI81544619 = -694190267;    int NJuhFzVsFtQvVxqYXgI50148854 = 24790312;    int NJuhFzVsFtQvVxqYXgI6881342 = -749639555;    int NJuhFzVsFtQvVxqYXgI62363953 = -973456229;    int NJuhFzVsFtQvVxqYXgI13917653 = -232916677;    int NJuhFzVsFtQvVxqYXgI75553316 = -777226501;    int NJuhFzVsFtQvVxqYXgI82544853 = -104878961;    int NJuhFzVsFtQvVxqYXgI88480391 = -281121084;    int NJuhFzVsFtQvVxqYXgI62044273 = -654769861;    int NJuhFzVsFtQvVxqYXgI4042910 = -143014354;    int NJuhFzVsFtQvVxqYXgI9766681 = -434084078;    int NJuhFzVsFtQvVxqYXgI4118933 = -43328576;    int NJuhFzVsFtQvVxqYXgI68444417 = -221314689;     NJuhFzVsFtQvVxqYXgI14627864 = NJuhFzVsFtQvVxqYXgI85630628;     NJuhFzVsFtQvVxqYXgI85630628 = NJuhFzVsFtQvVxqYXgI41614344;     NJuhFzVsFtQvVxqYXgI41614344 = NJuhFzVsFtQvVxqYXgI46398209;     NJuhFzVsFtQvVxqYXgI46398209 = NJuhFzVsFtQvVxqYXgI56670956;     NJuhFzVsFtQvVxqYXgI56670956 = NJuhFzVsFtQvVxqYXgI13867184;     NJuhFzVsFtQvVxqYXgI13867184 = NJuhFzVsFtQvVxqYXgI57525914;     NJuhFzVsFtQvVxqYXgI57525914 = NJuhFzVsFtQvVxqYXgI58680736;     NJuhFzVsFtQvVxqYXgI58680736 = NJuhFzVsFtQvVxqYXgI77248226;     NJuhFzVsFtQvVxqYXgI77248226 = NJuhFzVsFtQvVxqYXgI52598373;     NJuhFzVsFtQvVxqYXgI52598373 = NJuhFzVsFtQvVxqYXgI39404044;     NJuhFzVsFtQvVxqYXgI39404044 = NJuhFzVsFtQvVxqYXgI11193524;     NJuhFzVsFtQvVxqYXgI11193524 = NJuhFzVsFtQvVxqYXgI94777065;     NJuhFzVsFtQvVxqYXgI94777065 = NJuhFzVsFtQvVxqYXgI53728980;     NJuhFzVsFtQvVxqYXgI53728980 = NJuhFzVsFtQvVxqYXgI80648610;     NJuhFzVsFtQvVxqYXgI80648610 = NJuhFzVsFtQvVxqYXgI49842784;     NJuhFzVsFtQvVxqYXgI49842784 = NJuhFzVsFtQvVxqYXgI78546446;     NJuhFzVsFtQvVxqYXgI78546446 = NJuhFzVsFtQvVxqYXgI55946449;     NJuhFzVsFtQvVxqYXgI55946449 = NJuhFzVsFtQvVxqYXgI63648227;     NJuhFzVsFtQvVxqYXgI63648227 = NJuhFzVsFtQvVxqYXgI65122792;     NJuhFzVsFtQvVxqYXgI65122792 = NJuhFzVsFtQvVxqYXgI1727359;     NJuhFzVsFtQvVxqYXgI1727359 = NJuhFzVsFtQvVxqYXgI57215944;     NJuhFzVsFtQvVxqYXgI57215944 = NJuhFzVsFtQvVxqYXgI18095839;     NJuhFzVsFtQvVxqYXgI18095839 = NJuhFzVsFtQvVxqYXgI88202159;     NJuhFzVsFtQvVxqYXgI88202159 = NJuhFzVsFtQvVxqYXgI16673381;     NJuhFzVsFtQvVxqYXgI16673381 = NJuhFzVsFtQvVxqYXgI34903609;     NJuhFzVsFtQvVxqYXgI34903609 = NJuhFzVsFtQvVxqYXgI65077521;     NJuhFzVsFtQvVxqYXgI65077521 = NJuhFzVsFtQvVxqYXgI1968392;     NJuhFzVsFtQvVxqYXgI1968392 = NJuhFzVsFtQvVxqYXgI57857125;     NJuhFzVsFtQvVxqYXgI57857125 = NJuhFzVsFtQvVxqYXgI42011788;     NJuhFzVsFtQvVxqYXgI42011788 = NJuhFzVsFtQvVxqYXgI37393901;     NJuhFzVsFtQvVxqYXgI37393901 = NJuhFzVsFtQvVxqYXgI40932402;     NJuhFzVsFtQvVxqYXgI40932402 = NJuhFzVsFtQvVxqYXgI36852836;     NJuhFzVsFtQvVxqYXgI36852836 = NJuhFzVsFtQvVxqYXgI25008018;     NJuhFzVsFtQvVxqYXgI25008018 = NJuhFzVsFtQvVxqYXgI64293261;     NJuhFzVsFtQvVxqYXgI64293261 = NJuhFzVsFtQvVxqYXgI29898743;     NJuhFzVsFtQvVxqYXgI29898743 = NJuhFzVsFtQvVxqYXgI67329837;     NJuhFzVsFtQvVxqYXgI67329837 = NJuhFzVsFtQvVxqYXgI5278144;     NJuhFzVsFtQvVxqYXgI5278144 = NJuhFzVsFtQvVxqYXgI4312201;     NJuhFzVsFtQvVxqYXgI4312201 = NJuhFzVsFtQvVxqYXgI37270053;     NJuhFzVsFtQvVxqYXgI37270053 = NJuhFzVsFtQvVxqYXgI17601796;     NJuhFzVsFtQvVxqYXgI17601796 = NJuhFzVsFtQvVxqYXgI4866521;     NJuhFzVsFtQvVxqYXgI4866521 = NJuhFzVsFtQvVxqYXgI45003119;     NJuhFzVsFtQvVxqYXgI45003119 = NJuhFzVsFtQvVxqYXgI19323405;     NJuhFzVsFtQvVxqYXgI19323405 = NJuhFzVsFtQvVxqYXgI66916059;     NJuhFzVsFtQvVxqYXgI66916059 = NJuhFzVsFtQvVxqYXgI45130262;     NJuhFzVsFtQvVxqYXgI45130262 = NJuhFzVsFtQvVxqYXgI63882943;     NJuhFzVsFtQvVxqYXgI63882943 = NJuhFzVsFtQvVxqYXgI18922830;     NJuhFzVsFtQvVxqYXgI18922830 = NJuhFzVsFtQvVxqYXgI23867302;     NJuhFzVsFtQvVxqYXgI23867302 = NJuhFzVsFtQvVxqYXgI3367891;     NJuhFzVsFtQvVxqYXgI3367891 = NJuhFzVsFtQvVxqYXgI40303583;     NJuhFzVsFtQvVxqYXgI40303583 = NJuhFzVsFtQvVxqYXgI59455745;     NJuhFzVsFtQvVxqYXgI59455745 = NJuhFzVsFtQvVxqYXgI51226249;     NJuhFzVsFtQvVxqYXgI51226249 = NJuhFzVsFtQvVxqYXgI55308216;     NJuhFzVsFtQvVxqYXgI55308216 = NJuhFzVsFtQvVxqYXgI74859163;     NJuhFzVsFtQvVxqYXgI74859163 = NJuhFzVsFtQvVxqYXgI57411919;     NJuhFzVsFtQvVxqYXgI57411919 = NJuhFzVsFtQvVxqYXgI67534789;     NJuhFzVsFtQvVxqYXgI67534789 = NJuhFzVsFtQvVxqYXgI53412185;     NJuhFzVsFtQvVxqYXgI53412185 = NJuhFzVsFtQvVxqYXgI29724828;     NJuhFzVsFtQvVxqYXgI29724828 = NJuhFzVsFtQvVxqYXgI21767348;     NJuhFzVsFtQvVxqYXgI21767348 = NJuhFzVsFtQvVxqYXgI48789662;     NJuhFzVsFtQvVxqYXgI48789662 = NJuhFzVsFtQvVxqYXgI55557523;     NJuhFzVsFtQvVxqYXgI55557523 = NJuhFzVsFtQvVxqYXgI823611;     NJuhFzVsFtQvVxqYXgI823611 = NJuhFzVsFtQvVxqYXgI35236438;     NJuhFzVsFtQvVxqYXgI35236438 = NJuhFzVsFtQvVxqYXgI15204473;     NJuhFzVsFtQvVxqYXgI15204473 = NJuhFzVsFtQvVxqYXgI98471642;     NJuhFzVsFtQvVxqYXgI98471642 = NJuhFzVsFtQvVxqYXgI74340688;     NJuhFzVsFtQvVxqYXgI74340688 = NJuhFzVsFtQvVxqYXgI69769048;     NJuhFzVsFtQvVxqYXgI69769048 = NJuhFzVsFtQvVxqYXgI89435718;     NJuhFzVsFtQvVxqYXgI89435718 = NJuhFzVsFtQvVxqYXgI50749868;     NJuhFzVsFtQvVxqYXgI50749868 = NJuhFzVsFtQvVxqYXgI82512946;     NJuhFzVsFtQvVxqYXgI82512946 = NJuhFzVsFtQvVxqYXgI73268302;     NJuhFzVsFtQvVxqYXgI73268302 = NJuhFzVsFtQvVxqYXgI51634248;     NJuhFzVsFtQvVxqYXgI51634248 = NJuhFzVsFtQvVxqYXgI26378175;     NJuhFzVsFtQvVxqYXgI26378175 = NJuhFzVsFtQvVxqYXgI47520996;     NJuhFzVsFtQvVxqYXgI47520996 = NJuhFzVsFtQvVxqYXgI96860837;     NJuhFzVsFtQvVxqYXgI96860837 = NJuhFzVsFtQvVxqYXgI12212826;     NJuhFzVsFtQvVxqYXgI12212826 = NJuhFzVsFtQvVxqYXgI98772434;     NJuhFzVsFtQvVxqYXgI98772434 = NJuhFzVsFtQvVxqYXgI21286100;     NJuhFzVsFtQvVxqYXgI21286100 = NJuhFzVsFtQvVxqYXgI71543119;     NJuhFzVsFtQvVxqYXgI71543119 = NJuhFzVsFtQvVxqYXgI71020665;     NJuhFzVsFtQvVxqYXgI71020665 = NJuhFzVsFtQvVxqYXgI46154692;     NJuhFzVsFtQvVxqYXgI46154692 = NJuhFzVsFtQvVxqYXgI78101089;     NJuhFzVsFtQvVxqYXgI78101089 = NJuhFzVsFtQvVxqYXgI54489235;     NJuhFzVsFtQvVxqYXgI54489235 = NJuhFzVsFtQvVxqYXgI1708205;     NJuhFzVsFtQvVxqYXgI1708205 = NJuhFzVsFtQvVxqYXgI77938155;     NJuhFzVsFtQvVxqYXgI77938155 = NJuhFzVsFtQvVxqYXgI89706152;     NJuhFzVsFtQvVxqYXgI89706152 = NJuhFzVsFtQvVxqYXgI81544619;     NJuhFzVsFtQvVxqYXgI81544619 = NJuhFzVsFtQvVxqYXgI50148854;     NJuhFzVsFtQvVxqYXgI50148854 = NJuhFzVsFtQvVxqYXgI6881342;     NJuhFzVsFtQvVxqYXgI6881342 = NJuhFzVsFtQvVxqYXgI62363953;     NJuhFzVsFtQvVxqYXgI62363953 = NJuhFzVsFtQvVxqYXgI13917653;     NJuhFzVsFtQvVxqYXgI13917653 = NJuhFzVsFtQvVxqYXgI75553316;     NJuhFzVsFtQvVxqYXgI75553316 = NJuhFzVsFtQvVxqYXgI82544853;     NJuhFzVsFtQvVxqYXgI82544853 = NJuhFzVsFtQvVxqYXgI88480391;     NJuhFzVsFtQvVxqYXgI88480391 = NJuhFzVsFtQvVxqYXgI62044273;     NJuhFzVsFtQvVxqYXgI62044273 = NJuhFzVsFtQvVxqYXgI4042910;     NJuhFzVsFtQvVxqYXgI4042910 = NJuhFzVsFtQvVxqYXgI9766681;     NJuhFzVsFtQvVxqYXgI9766681 = NJuhFzVsFtQvVxqYXgI4118933;     NJuhFzVsFtQvVxqYXgI4118933 = NJuhFzVsFtQvVxqYXgI68444417;     NJuhFzVsFtQvVxqYXgI68444417 = NJuhFzVsFtQvVxqYXgI14627864;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void csKoVrNSqtATSReBNzzyuzPKwARvaiMVGBpaXAcPPZMUJgtChDMnBsdcc81540384() {     long zrUZRrIheNQbDeMWjiVmvBQHO12059945 = -63562413;    long zrUZRrIheNQbDeMWjiVmvBQHO36961261 = -988378748;    long zrUZRrIheNQbDeMWjiVmvBQHO73178154 = -188192835;    long zrUZRrIheNQbDeMWjiVmvBQHO10375711 = -920566447;    long zrUZRrIheNQbDeMWjiVmvBQHO70851710 = -531889541;    long zrUZRrIheNQbDeMWjiVmvBQHO94197306 = -289549666;    long zrUZRrIheNQbDeMWjiVmvBQHO97607063 = -818098088;    long zrUZRrIheNQbDeMWjiVmvBQHO86066405 = -212509363;    long zrUZRrIheNQbDeMWjiVmvBQHO55331171 = -226122064;    long zrUZRrIheNQbDeMWjiVmvBQHO1994812 = -912892689;    long zrUZRrIheNQbDeMWjiVmvBQHO70871305 = -6798124;    long zrUZRrIheNQbDeMWjiVmvBQHO89615435 = -721490949;    long zrUZRrIheNQbDeMWjiVmvBQHO69102150 = -920171073;    long zrUZRrIheNQbDeMWjiVmvBQHO28688578 = -441269587;    long zrUZRrIheNQbDeMWjiVmvBQHO74688379 = -539776833;    long zrUZRrIheNQbDeMWjiVmvBQHO64817633 = -925343425;    long zrUZRrIheNQbDeMWjiVmvBQHO98273168 = -464889558;    long zrUZRrIheNQbDeMWjiVmvBQHO2418571 = -243510371;    long zrUZRrIheNQbDeMWjiVmvBQHO80461474 = -74269397;    long zrUZRrIheNQbDeMWjiVmvBQHO15087960 = -811916034;    long zrUZRrIheNQbDeMWjiVmvBQHO73625356 = -778106378;    long zrUZRrIheNQbDeMWjiVmvBQHO73041427 = -66142603;    long zrUZRrIheNQbDeMWjiVmvBQHO43410791 = -929769662;    long zrUZRrIheNQbDeMWjiVmvBQHO61302849 = -573060983;    long zrUZRrIheNQbDeMWjiVmvBQHO53201030 = -836550670;    long zrUZRrIheNQbDeMWjiVmvBQHO6927784 = 96913648;    long zrUZRrIheNQbDeMWjiVmvBQHO62726173 = -639812985;    long zrUZRrIheNQbDeMWjiVmvBQHO77090180 = -267856614;    long zrUZRrIheNQbDeMWjiVmvBQHO43090496 = -669505238;    long zrUZRrIheNQbDeMWjiVmvBQHO61340809 = -263114017;    long zrUZRrIheNQbDeMWjiVmvBQHO51979687 = -237227913;    long zrUZRrIheNQbDeMWjiVmvBQHO55903438 = -797558094;    long zrUZRrIheNQbDeMWjiVmvBQHO27926103 = -526260097;    long zrUZRrIheNQbDeMWjiVmvBQHO85316301 = -308085920;    long zrUZRrIheNQbDeMWjiVmvBQHO64447229 = -766246513;    long zrUZRrIheNQbDeMWjiVmvBQHO76689909 = -768681224;    long zrUZRrIheNQbDeMWjiVmvBQHO38486758 = -440281272;    long zrUZRrIheNQbDeMWjiVmvBQHO11351788 = -288858289;    long zrUZRrIheNQbDeMWjiVmvBQHO99892004 = -651865089;    long zrUZRrIheNQbDeMWjiVmvBQHO90943814 = -502286958;    long zrUZRrIheNQbDeMWjiVmvBQHO34307604 = -819819505;    long zrUZRrIheNQbDeMWjiVmvBQHO73629174 = -744737715;    long zrUZRrIheNQbDeMWjiVmvBQHO24313990 = -929152666;    long zrUZRrIheNQbDeMWjiVmvBQHO75179326 = -235693310;    long zrUZRrIheNQbDeMWjiVmvBQHO56684718 = -613486049;    long zrUZRrIheNQbDeMWjiVmvBQHO46820023 = -363975215;    long zrUZRrIheNQbDeMWjiVmvBQHO84842326 = -787102951;    long zrUZRrIheNQbDeMWjiVmvBQHO38042001 = -962782240;    long zrUZRrIheNQbDeMWjiVmvBQHO5219702 = 35425681;    long zrUZRrIheNQbDeMWjiVmvBQHO68886371 = -420457083;    long zrUZRrIheNQbDeMWjiVmvBQHO51507775 = -283412508;    long zrUZRrIheNQbDeMWjiVmvBQHO19063105 = -319303716;    long zrUZRrIheNQbDeMWjiVmvBQHO61107717 = -492170698;    long zrUZRrIheNQbDeMWjiVmvBQHO51132896 = -911277755;    long zrUZRrIheNQbDeMWjiVmvBQHO7915029 = -763008268;    long zrUZRrIheNQbDeMWjiVmvBQHO39018517 = -997419811;    long zrUZRrIheNQbDeMWjiVmvBQHO93550469 = 41390913;    long zrUZRrIheNQbDeMWjiVmvBQHO11875306 = -615131852;    long zrUZRrIheNQbDeMWjiVmvBQHO57174681 = 15984223;    long zrUZRrIheNQbDeMWjiVmvBQHO63923927 = -528803190;    long zrUZRrIheNQbDeMWjiVmvBQHO31471134 = -649736681;    long zrUZRrIheNQbDeMWjiVmvBQHO20516883 = -450241474;    long zrUZRrIheNQbDeMWjiVmvBQHO42975909 = -543004126;    long zrUZRrIheNQbDeMWjiVmvBQHO93990361 = -963008048;    long zrUZRrIheNQbDeMWjiVmvBQHO50015125 = -575664776;    long zrUZRrIheNQbDeMWjiVmvBQHO14967868 = -209240031;    long zrUZRrIheNQbDeMWjiVmvBQHO61689333 = -95230853;    long zrUZRrIheNQbDeMWjiVmvBQHO83785849 = -512085153;    long zrUZRrIheNQbDeMWjiVmvBQHO64241349 = -675023075;    long zrUZRrIheNQbDeMWjiVmvBQHO97998469 = -771095609;    long zrUZRrIheNQbDeMWjiVmvBQHO26330875 = -385062153;    long zrUZRrIheNQbDeMWjiVmvBQHO86921380 = -76031270;    long zrUZRrIheNQbDeMWjiVmvBQHO2526567 = -591645282;    long zrUZRrIheNQbDeMWjiVmvBQHO89517659 = -571982440;    long zrUZRrIheNQbDeMWjiVmvBQHO80780356 = -992096530;    long zrUZRrIheNQbDeMWjiVmvBQHO99996181 = 66631336;    long zrUZRrIheNQbDeMWjiVmvBQHO48727438 = -136989937;    long zrUZRrIheNQbDeMWjiVmvBQHO68231465 = -594076353;    long zrUZRrIheNQbDeMWjiVmvBQHO4618131 = -959574934;    long zrUZRrIheNQbDeMWjiVmvBQHO6381007 = -372575456;    long zrUZRrIheNQbDeMWjiVmvBQHO22085457 = -115983402;    long zrUZRrIheNQbDeMWjiVmvBQHO24684172 = -677030745;    long zrUZRrIheNQbDeMWjiVmvBQHO71870478 = -203282296;    long zrUZRrIheNQbDeMWjiVmvBQHO74204124 = -149048156;    long zrUZRrIheNQbDeMWjiVmvBQHO9833035 = -979701509;    long zrUZRrIheNQbDeMWjiVmvBQHO32916583 = -917924197;    long zrUZRrIheNQbDeMWjiVmvBQHO94795720 = -205387396;    long zrUZRrIheNQbDeMWjiVmvBQHO76793206 = -614982343;    long zrUZRrIheNQbDeMWjiVmvBQHO77401273 = -545077652;    long zrUZRrIheNQbDeMWjiVmvBQHO25428712 = -768826702;    long zrUZRrIheNQbDeMWjiVmvBQHO83139439 = -710072138;    long zrUZRrIheNQbDeMWjiVmvBQHO26611453 = -825149420;    long zrUZRrIheNQbDeMWjiVmvBQHO54177107 = -204842512;    long zrUZRrIheNQbDeMWjiVmvBQHO35968077 = -23061900;    long zrUZRrIheNQbDeMWjiVmvBQHO59472681 = -852550277;    long zrUZRrIheNQbDeMWjiVmvBQHO13790722 = -269578031;    long zrUZRrIheNQbDeMWjiVmvBQHO30653265 = -101733590;    long zrUZRrIheNQbDeMWjiVmvBQHO30323628 = -966144619;    long zrUZRrIheNQbDeMWjiVmvBQHO25164201 = -660028534;    long zrUZRrIheNQbDeMWjiVmvBQHO41716851 = -63562413;     zrUZRrIheNQbDeMWjiVmvBQHO12059945 = zrUZRrIheNQbDeMWjiVmvBQHO36961261;     zrUZRrIheNQbDeMWjiVmvBQHO36961261 = zrUZRrIheNQbDeMWjiVmvBQHO73178154;     zrUZRrIheNQbDeMWjiVmvBQHO73178154 = zrUZRrIheNQbDeMWjiVmvBQHO10375711;     zrUZRrIheNQbDeMWjiVmvBQHO10375711 = zrUZRrIheNQbDeMWjiVmvBQHO70851710;     zrUZRrIheNQbDeMWjiVmvBQHO70851710 = zrUZRrIheNQbDeMWjiVmvBQHO94197306;     zrUZRrIheNQbDeMWjiVmvBQHO94197306 = zrUZRrIheNQbDeMWjiVmvBQHO97607063;     zrUZRrIheNQbDeMWjiVmvBQHO97607063 = zrUZRrIheNQbDeMWjiVmvBQHO86066405;     zrUZRrIheNQbDeMWjiVmvBQHO86066405 = zrUZRrIheNQbDeMWjiVmvBQHO55331171;     zrUZRrIheNQbDeMWjiVmvBQHO55331171 = zrUZRrIheNQbDeMWjiVmvBQHO1994812;     zrUZRrIheNQbDeMWjiVmvBQHO1994812 = zrUZRrIheNQbDeMWjiVmvBQHO70871305;     zrUZRrIheNQbDeMWjiVmvBQHO70871305 = zrUZRrIheNQbDeMWjiVmvBQHO89615435;     zrUZRrIheNQbDeMWjiVmvBQHO89615435 = zrUZRrIheNQbDeMWjiVmvBQHO69102150;     zrUZRrIheNQbDeMWjiVmvBQHO69102150 = zrUZRrIheNQbDeMWjiVmvBQHO28688578;     zrUZRrIheNQbDeMWjiVmvBQHO28688578 = zrUZRrIheNQbDeMWjiVmvBQHO74688379;     zrUZRrIheNQbDeMWjiVmvBQHO74688379 = zrUZRrIheNQbDeMWjiVmvBQHO64817633;     zrUZRrIheNQbDeMWjiVmvBQHO64817633 = zrUZRrIheNQbDeMWjiVmvBQHO98273168;     zrUZRrIheNQbDeMWjiVmvBQHO98273168 = zrUZRrIheNQbDeMWjiVmvBQHO2418571;     zrUZRrIheNQbDeMWjiVmvBQHO2418571 = zrUZRrIheNQbDeMWjiVmvBQHO80461474;     zrUZRrIheNQbDeMWjiVmvBQHO80461474 = zrUZRrIheNQbDeMWjiVmvBQHO15087960;     zrUZRrIheNQbDeMWjiVmvBQHO15087960 = zrUZRrIheNQbDeMWjiVmvBQHO73625356;     zrUZRrIheNQbDeMWjiVmvBQHO73625356 = zrUZRrIheNQbDeMWjiVmvBQHO73041427;     zrUZRrIheNQbDeMWjiVmvBQHO73041427 = zrUZRrIheNQbDeMWjiVmvBQHO43410791;     zrUZRrIheNQbDeMWjiVmvBQHO43410791 = zrUZRrIheNQbDeMWjiVmvBQHO61302849;     zrUZRrIheNQbDeMWjiVmvBQHO61302849 = zrUZRrIheNQbDeMWjiVmvBQHO53201030;     zrUZRrIheNQbDeMWjiVmvBQHO53201030 = zrUZRrIheNQbDeMWjiVmvBQHO6927784;     zrUZRrIheNQbDeMWjiVmvBQHO6927784 = zrUZRrIheNQbDeMWjiVmvBQHO62726173;     zrUZRrIheNQbDeMWjiVmvBQHO62726173 = zrUZRrIheNQbDeMWjiVmvBQHO77090180;     zrUZRrIheNQbDeMWjiVmvBQHO77090180 = zrUZRrIheNQbDeMWjiVmvBQHO43090496;     zrUZRrIheNQbDeMWjiVmvBQHO43090496 = zrUZRrIheNQbDeMWjiVmvBQHO61340809;     zrUZRrIheNQbDeMWjiVmvBQHO61340809 = zrUZRrIheNQbDeMWjiVmvBQHO51979687;     zrUZRrIheNQbDeMWjiVmvBQHO51979687 = zrUZRrIheNQbDeMWjiVmvBQHO55903438;     zrUZRrIheNQbDeMWjiVmvBQHO55903438 = zrUZRrIheNQbDeMWjiVmvBQHO27926103;     zrUZRrIheNQbDeMWjiVmvBQHO27926103 = zrUZRrIheNQbDeMWjiVmvBQHO85316301;     zrUZRrIheNQbDeMWjiVmvBQHO85316301 = zrUZRrIheNQbDeMWjiVmvBQHO64447229;     zrUZRrIheNQbDeMWjiVmvBQHO64447229 = zrUZRrIheNQbDeMWjiVmvBQHO76689909;     zrUZRrIheNQbDeMWjiVmvBQHO76689909 = zrUZRrIheNQbDeMWjiVmvBQHO38486758;     zrUZRrIheNQbDeMWjiVmvBQHO38486758 = zrUZRrIheNQbDeMWjiVmvBQHO11351788;     zrUZRrIheNQbDeMWjiVmvBQHO11351788 = zrUZRrIheNQbDeMWjiVmvBQHO99892004;     zrUZRrIheNQbDeMWjiVmvBQHO99892004 = zrUZRrIheNQbDeMWjiVmvBQHO90943814;     zrUZRrIheNQbDeMWjiVmvBQHO90943814 = zrUZRrIheNQbDeMWjiVmvBQHO34307604;     zrUZRrIheNQbDeMWjiVmvBQHO34307604 = zrUZRrIheNQbDeMWjiVmvBQHO73629174;     zrUZRrIheNQbDeMWjiVmvBQHO73629174 = zrUZRrIheNQbDeMWjiVmvBQHO24313990;     zrUZRrIheNQbDeMWjiVmvBQHO24313990 = zrUZRrIheNQbDeMWjiVmvBQHO75179326;     zrUZRrIheNQbDeMWjiVmvBQHO75179326 = zrUZRrIheNQbDeMWjiVmvBQHO56684718;     zrUZRrIheNQbDeMWjiVmvBQHO56684718 = zrUZRrIheNQbDeMWjiVmvBQHO46820023;     zrUZRrIheNQbDeMWjiVmvBQHO46820023 = zrUZRrIheNQbDeMWjiVmvBQHO84842326;     zrUZRrIheNQbDeMWjiVmvBQHO84842326 = zrUZRrIheNQbDeMWjiVmvBQHO38042001;     zrUZRrIheNQbDeMWjiVmvBQHO38042001 = zrUZRrIheNQbDeMWjiVmvBQHO5219702;     zrUZRrIheNQbDeMWjiVmvBQHO5219702 = zrUZRrIheNQbDeMWjiVmvBQHO68886371;     zrUZRrIheNQbDeMWjiVmvBQHO68886371 = zrUZRrIheNQbDeMWjiVmvBQHO51507775;     zrUZRrIheNQbDeMWjiVmvBQHO51507775 = zrUZRrIheNQbDeMWjiVmvBQHO19063105;     zrUZRrIheNQbDeMWjiVmvBQHO19063105 = zrUZRrIheNQbDeMWjiVmvBQHO61107717;     zrUZRrIheNQbDeMWjiVmvBQHO61107717 = zrUZRrIheNQbDeMWjiVmvBQHO51132896;     zrUZRrIheNQbDeMWjiVmvBQHO51132896 = zrUZRrIheNQbDeMWjiVmvBQHO7915029;     zrUZRrIheNQbDeMWjiVmvBQHO7915029 = zrUZRrIheNQbDeMWjiVmvBQHO39018517;     zrUZRrIheNQbDeMWjiVmvBQHO39018517 = zrUZRrIheNQbDeMWjiVmvBQHO93550469;     zrUZRrIheNQbDeMWjiVmvBQHO93550469 = zrUZRrIheNQbDeMWjiVmvBQHO11875306;     zrUZRrIheNQbDeMWjiVmvBQHO11875306 = zrUZRrIheNQbDeMWjiVmvBQHO57174681;     zrUZRrIheNQbDeMWjiVmvBQHO57174681 = zrUZRrIheNQbDeMWjiVmvBQHO63923927;     zrUZRrIheNQbDeMWjiVmvBQHO63923927 = zrUZRrIheNQbDeMWjiVmvBQHO31471134;     zrUZRrIheNQbDeMWjiVmvBQHO31471134 = zrUZRrIheNQbDeMWjiVmvBQHO20516883;     zrUZRrIheNQbDeMWjiVmvBQHO20516883 = zrUZRrIheNQbDeMWjiVmvBQHO42975909;     zrUZRrIheNQbDeMWjiVmvBQHO42975909 = zrUZRrIheNQbDeMWjiVmvBQHO93990361;     zrUZRrIheNQbDeMWjiVmvBQHO93990361 = zrUZRrIheNQbDeMWjiVmvBQHO50015125;     zrUZRrIheNQbDeMWjiVmvBQHO50015125 = zrUZRrIheNQbDeMWjiVmvBQHO14967868;     zrUZRrIheNQbDeMWjiVmvBQHO14967868 = zrUZRrIheNQbDeMWjiVmvBQHO61689333;     zrUZRrIheNQbDeMWjiVmvBQHO61689333 = zrUZRrIheNQbDeMWjiVmvBQHO83785849;     zrUZRrIheNQbDeMWjiVmvBQHO83785849 = zrUZRrIheNQbDeMWjiVmvBQHO64241349;     zrUZRrIheNQbDeMWjiVmvBQHO64241349 = zrUZRrIheNQbDeMWjiVmvBQHO97998469;     zrUZRrIheNQbDeMWjiVmvBQHO97998469 = zrUZRrIheNQbDeMWjiVmvBQHO26330875;     zrUZRrIheNQbDeMWjiVmvBQHO26330875 = zrUZRrIheNQbDeMWjiVmvBQHO86921380;     zrUZRrIheNQbDeMWjiVmvBQHO86921380 = zrUZRrIheNQbDeMWjiVmvBQHO2526567;     zrUZRrIheNQbDeMWjiVmvBQHO2526567 = zrUZRrIheNQbDeMWjiVmvBQHO89517659;     zrUZRrIheNQbDeMWjiVmvBQHO89517659 = zrUZRrIheNQbDeMWjiVmvBQHO80780356;     zrUZRrIheNQbDeMWjiVmvBQHO80780356 = zrUZRrIheNQbDeMWjiVmvBQHO99996181;     zrUZRrIheNQbDeMWjiVmvBQHO99996181 = zrUZRrIheNQbDeMWjiVmvBQHO48727438;     zrUZRrIheNQbDeMWjiVmvBQHO48727438 = zrUZRrIheNQbDeMWjiVmvBQHO68231465;     zrUZRrIheNQbDeMWjiVmvBQHO68231465 = zrUZRrIheNQbDeMWjiVmvBQHO4618131;     zrUZRrIheNQbDeMWjiVmvBQHO4618131 = zrUZRrIheNQbDeMWjiVmvBQHO6381007;     zrUZRrIheNQbDeMWjiVmvBQHO6381007 = zrUZRrIheNQbDeMWjiVmvBQHO22085457;     zrUZRrIheNQbDeMWjiVmvBQHO22085457 = zrUZRrIheNQbDeMWjiVmvBQHO24684172;     zrUZRrIheNQbDeMWjiVmvBQHO24684172 = zrUZRrIheNQbDeMWjiVmvBQHO71870478;     zrUZRrIheNQbDeMWjiVmvBQHO71870478 = zrUZRrIheNQbDeMWjiVmvBQHO74204124;     zrUZRrIheNQbDeMWjiVmvBQHO74204124 = zrUZRrIheNQbDeMWjiVmvBQHO9833035;     zrUZRrIheNQbDeMWjiVmvBQHO9833035 = zrUZRrIheNQbDeMWjiVmvBQHO32916583;     zrUZRrIheNQbDeMWjiVmvBQHO32916583 = zrUZRrIheNQbDeMWjiVmvBQHO94795720;     zrUZRrIheNQbDeMWjiVmvBQHO94795720 = zrUZRrIheNQbDeMWjiVmvBQHO76793206;     zrUZRrIheNQbDeMWjiVmvBQHO76793206 = zrUZRrIheNQbDeMWjiVmvBQHO77401273;     zrUZRrIheNQbDeMWjiVmvBQHO77401273 = zrUZRrIheNQbDeMWjiVmvBQHO25428712;     zrUZRrIheNQbDeMWjiVmvBQHO25428712 = zrUZRrIheNQbDeMWjiVmvBQHO83139439;     zrUZRrIheNQbDeMWjiVmvBQHO83139439 = zrUZRrIheNQbDeMWjiVmvBQHO26611453;     zrUZRrIheNQbDeMWjiVmvBQHO26611453 = zrUZRrIheNQbDeMWjiVmvBQHO54177107;     zrUZRrIheNQbDeMWjiVmvBQHO54177107 = zrUZRrIheNQbDeMWjiVmvBQHO35968077;     zrUZRrIheNQbDeMWjiVmvBQHO35968077 = zrUZRrIheNQbDeMWjiVmvBQHO59472681;     zrUZRrIheNQbDeMWjiVmvBQHO59472681 = zrUZRrIheNQbDeMWjiVmvBQHO13790722;     zrUZRrIheNQbDeMWjiVmvBQHO13790722 = zrUZRrIheNQbDeMWjiVmvBQHO30653265;     zrUZRrIheNQbDeMWjiVmvBQHO30653265 = zrUZRrIheNQbDeMWjiVmvBQHO30323628;     zrUZRrIheNQbDeMWjiVmvBQHO30323628 = zrUZRrIheNQbDeMWjiVmvBQHO25164201;     zrUZRrIheNQbDeMWjiVmvBQHO25164201 = zrUZRrIheNQbDeMWjiVmvBQHO41716851;     zrUZRrIheNQbDeMWjiVmvBQHO41716851 = zrUZRrIheNQbDeMWjiVmvBQHO12059945;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void rLELWUIcTFauhKSnbDftuVNvRsTjlmUFWUUWMYkZFDbwjiRkkqRjstaVy96589452() {     long JteBZqhlVXNpvaDSGoruQLjbi18177051 = -175464302;    long JteBZqhlVXNpvaDSGoruQLjbi80334540 = -697978529;    long JteBZqhlVXNpvaDSGoruQLjbi89220338 = -339025756;    long JteBZqhlVXNpvaDSGoruQLjbi37450492 = -11315077;    long JteBZqhlVXNpvaDSGoruQLjbi39747199 = 47460588;    long JteBZqhlVXNpvaDSGoruQLjbi85614509 = -554045901;    long JteBZqhlVXNpvaDSGoruQLjbi58096029 = -957063065;    long JteBZqhlVXNpvaDSGoruQLjbi35826296 = -499383276;    long JteBZqhlVXNpvaDSGoruQLjbi19973667 = 5845270;    long JteBZqhlVXNpvaDSGoruQLjbi43224471 = -141868166;    long JteBZqhlVXNpvaDSGoruQLjbi30981596 = -984235711;    long JteBZqhlVXNpvaDSGoruQLjbi21438479 = -65897151;    long JteBZqhlVXNpvaDSGoruQLjbi55311269 = -260062161;    long JteBZqhlVXNpvaDSGoruQLjbi11832255 = -973508155;    long JteBZqhlVXNpvaDSGoruQLjbi70430806 = -130238999;    long JteBZqhlVXNpvaDSGoruQLjbi6323028 = -898342968;    long JteBZqhlVXNpvaDSGoruQLjbi92109171 = 18565329;    long JteBZqhlVXNpvaDSGoruQLjbi99471723 = 90966986;    long JteBZqhlVXNpvaDSGoruQLjbi42291316 = -480038494;    long JteBZqhlVXNpvaDSGoruQLjbi95638124 = -68818953;    long JteBZqhlVXNpvaDSGoruQLjbi62178549 = -633593833;    long JteBZqhlVXNpvaDSGoruQLjbi59562451 = 25927681;    long JteBZqhlVXNpvaDSGoruQLjbi79001583 = -676287149;    long JteBZqhlVXNpvaDSGoruQLjbi45295223 = -795365971;    long JteBZqhlVXNpvaDSGoruQLjbi96900680 = -109746703;    long JteBZqhlVXNpvaDSGoruQLjbi31649459 = -881741675;    long JteBZqhlVXNpvaDSGoruQLjbi61185951 = -540475188;    long JteBZqhlVXNpvaDSGoruQLjbi90197306 = -333785568;    long JteBZqhlVXNpvaDSGoruQLjbi9222752 = -891887943;    long JteBZqhlVXNpvaDSGoruQLjbi29956446 = -80584884;    long JteBZqhlVXNpvaDSGoruQLjbi44222236 = -150548851;    long JteBZqhlVXNpvaDSGoruQLjbi53514060 = -507004909;    long JteBZqhlVXNpvaDSGoruQLjbi37637051 = -418873467;    long JteBZqhlVXNpvaDSGoruQLjbi80146865 = -59627685;    long JteBZqhlVXNpvaDSGoruQLjbi25921881 = -304979618;    long JteBZqhlVXNpvaDSGoruQLjbi45415823 = -982707332;    long JteBZqhlVXNpvaDSGoruQLjbi19748693 = -393917141;    long JteBZqhlVXNpvaDSGoruQLjbi45442000 = -60364298;    long JteBZqhlVXNpvaDSGoruQLjbi73502258 = -645788586;    long JteBZqhlVXNpvaDSGoruQLjbi78445752 = -975726180;    long JteBZqhlVXNpvaDSGoruQLjbi39976828 = -885093399;    long JteBZqhlVXNpvaDSGoruQLjbi5779631 = 85120007;    long JteBZqhlVXNpvaDSGoruQLjbi2380968 = 90042750;    long JteBZqhlVXNpvaDSGoruQLjbi62587066 = -255036248;    long JteBZqhlVXNpvaDSGoruQLjbi68637183 = -275384203;    long JteBZqhlVXNpvaDSGoruQLjbi58759218 = -349191331;    long JteBZqhlVXNpvaDSGoruQLjbi2620901 = -905878488;    long JteBZqhlVXNpvaDSGoruQLjbi45998942 = -972677773;    long JteBZqhlVXNpvaDSGoruQLjbi14895431 = -50311307;    long JteBZqhlVXNpvaDSGoruQLjbi81798024 = -507467891;    long JteBZqhlVXNpvaDSGoruQLjbi87208453 = -125706179;    long JteBZqhlVXNpvaDSGoruQLjbi29872824 = -120030036;    long JteBZqhlVXNpvaDSGoruQLjbi9356175 = -283960286;    long JteBZqhlVXNpvaDSGoruQLjbi47101776 = -131747900;    long JteBZqhlVXNpvaDSGoruQLjbi34410903 = -363540051;    long JteBZqhlVXNpvaDSGoruQLjbi58614600 = -101391984;    long JteBZqhlVXNpvaDSGoruQLjbi1332958 = 78308620;    long JteBZqhlVXNpvaDSGoruQLjbi43925116 = -543659785;    long JteBZqhlVXNpvaDSGoruQLjbi40549812 = -901568375;    long JteBZqhlVXNpvaDSGoruQLjbi8097741 = -70797738;    long JteBZqhlVXNpvaDSGoruQLjbi24428558 = 86429287;    long JteBZqhlVXNpvaDSGoruQLjbi67898723 = -523277498;    long JteBZqhlVXNpvaDSGoruQLjbi26603545 = -607495334;    long JteBZqhlVXNpvaDSGoruQLjbi90017220 = -913569846;    long JteBZqhlVXNpvaDSGoruQLjbi99002234 = -991319316;    long JteBZqhlVXNpvaDSGoruQLjbi77467536 = -377230802;    long JteBZqhlVXNpvaDSGoruQLjbi83801427 = -647023684;    long JteBZqhlVXNpvaDSGoruQLjbi75164403 = -100434477;    long JteBZqhlVXNpvaDSGoruQLjbi85910374 = -568528538;    long JteBZqhlVXNpvaDSGoruQLjbi25014984 = -147531668;    long JteBZqhlVXNpvaDSGoruQLjbi86574334 = -404425827;    long JteBZqhlVXNpvaDSGoruQLjbi46667171 = -921070373;    long JteBZqhlVXNpvaDSGoruQLjbi25969466 = -263244428;    long JteBZqhlVXNpvaDSGoruQLjbi63845564 = -504312314;    long JteBZqhlVXNpvaDSGoruQLjbi55661297 = -183725555;    long JteBZqhlVXNpvaDSGoruQLjbi56398918 = -618713841;    long JteBZqhlVXNpvaDSGoruQLjbi57181483 = 35884931;    long JteBZqhlVXNpvaDSGoruQLjbi16414517 = -321250902;    long JteBZqhlVXNpvaDSGoruQLjbi76658039 = -419981768;    long JteBZqhlVXNpvaDSGoruQLjbi38141462 = -760555372;    long JteBZqhlVXNpvaDSGoruQLjbi29028558 = -975863187;    long JteBZqhlVXNpvaDSGoruQLjbi15187010 = -567797416;    long JteBZqhlVXNpvaDSGoruQLjbi75301875 = -183474261;    long JteBZqhlVXNpvaDSGoruQLjbi27424728 = -284420052;    long JteBZqhlVXNpvaDSGoruQLjbi42747993 = -954878705;    long JteBZqhlVXNpvaDSGoruQLjbi14349413 = 69481185;    long JteBZqhlVXNpvaDSGoruQLjbi44157885 = -123044624;    long JteBZqhlVXNpvaDSGoruQLjbi90535274 = -187125568;    long JteBZqhlVXNpvaDSGoruQLjbi45735962 = -696087635;    long JteBZqhlVXNpvaDSGoruQLjbi67307280 = -103587635;    long JteBZqhlVXNpvaDSGoruQLjbi44082865 = -961015952;    long JteBZqhlVXNpvaDSGoruQLjbi75823577 = -850257356;    long JteBZqhlVXNpvaDSGoruQLjbi4892189 = -158795924;    long JteBZqhlVXNpvaDSGoruQLjbi65404518 = -474990849;    long JteBZqhlVXNpvaDSGoruQLjbi54017195 = -962155468;    long JteBZqhlVXNpvaDSGoruQLjbi72078104 = -261815902;    long JteBZqhlVXNpvaDSGoruQLjbi79176086 = -307384659;    long JteBZqhlVXNpvaDSGoruQLjbi12363748 = 3612595;    long JteBZqhlVXNpvaDSGoruQLjbi63584831 = -263716933;    long JteBZqhlVXNpvaDSGoruQLjbi91169647 = -175464302;     JteBZqhlVXNpvaDSGoruQLjbi18177051 = JteBZqhlVXNpvaDSGoruQLjbi80334540;     JteBZqhlVXNpvaDSGoruQLjbi80334540 = JteBZqhlVXNpvaDSGoruQLjbi89220338;     JteBZqhlVXNpvaDSGoruQLjbi89220338 = JteBZqhlVXNpvaDSGoruQLjbi37450492;     JteBZqhlVXNpvaDSGoruQLjbi37450492 = JteBZqhlVXNpvaDSGoruQLjbi39747199;     JteBZqhlVXNpvaDSGoruQLjbi39747199 = JteBZqhlVXNpvaDSGoruQLjbi85614509;     JteBZqhlVXNpvaDSGoruQLjbi85614509 = JteBZqhlVXNpvaDSGoruQLjbi58096029;     JteBZqhlVXNpvaDSGoruQLjbi58096029 = JteBZqhlVXNpvaDSGoruQLjbi35826296;     JteBZqhlVXNpvaDSGoruQLjbi35826296 = JteBZqhlVXNpvaDSGoruQLjbi19973667;     JteBZqhlVXNpvaDSGoruQLjbi19973667 = JteBZqhlVXNpvaDSGoruQLjbi43224471;     JteBZqhlVXNpvaDSGoruQLjbi43224471 = JteBZqhlVXNpvaDSGoruQLjbi30981596;     JteBZqhlVXNpvaDSGoruQLjbi30981596 = JteBZqhlVXNpvaDSGoruQLjbi21438479;     JteBZqhlVXNpvaDSGoruQLjbi21438479 = JteBZqhlVXNpvaDSGoruQLjbi55311269;     JteBZqhlVXNpvaDSGoruQLjbi55311269 = JteBZqhlVXNpvaDSGoruQLjbi11832255;     JteBZqhlVXNpvaDSGoruQLjbi11832255 = JteBZqhlVXNpvaDSGoruQLjbi70430806;     JteBZqhlVXNpvaDSGoruQLjbi70430806 = JteBZqhlVXNpvaDSGoruQLjbi6323028;     JteBZqhlVXNpvaDSGoruQLjbi6323028 = JteBZqhlVXNpvaDSGoruQLjbi92109171;     JteBZqhlVXNpvaDSGoruQLjbi92109171 = JteBZqhlVXNpvaDSGoruQLjbi99471723;     JteBZqhlVXNpvaDSGoruQLjbi99471723 = JteBZqhlVXNpvaDSGoruQLjbi42291316;     JteBZqhlVXNpvaDSGoruQLjbi42291316 = JteBZqhlVXNpvaDSGoruQLjbi95638124;     JteBZqhlVXNpvaDSGoruQLjbi95638124 = JteBZqhlVXNpvaDSGoruQLjbi62178549;     JteBZqhlVXNpvaDSGoruQLjbi62178549 = JteBZqhlVXNpvaDSGoruQLjbi59562451;     JteBZqhlVXNpvaDSGoruQLjbi59562451 = JteBZqhlVXNpvaDSGoruQLjbi79001583;     JteBZqhlVXNpvaDSGoruQLjbi79001583 = JteBZqhlVXNpvaDSGoruQLjbi45295223;     JteBZqhlVXNpvaDSGoruQLjbi45295223 = JteBZqhlVXNpvaDSGoruQLjbi96900680;     JteBZqhlVXNpvaDSGoruQLjbi96900680 = JteBZqhlVXNpvaDSGoruQLjbi31649459;     JteBZqhlVXNpvaDSGoruQLjbi31649459 = JteBZqhlVXNpvaDSGoruQLjbi61185951;     JteBZqhlVXNpvaDSGoruQLjbi61185951 = JteBZqhlVXNpvaDSGoruQLjbi90197306;     JteBZqhlVXNpvaDSGoruQLjbi90197306 = JteBZqhlVXNpvaDSGoruQLjbi9222752;     JteBZqhlVXNpvaDSGoruQLjbi9222752 = JteBZqhlVXNpvaDSGoruQLjbi29956446;     JteBZqhlVXNpvaDSGoruQLjbi29956446 = JteBZqhlVXNpvaDSGoruQLjbi44222236;     JteBZqhlVXNpvaDSGoruQLjbi44222236 = JteBZqhlVXNpvaDSGoruQLjbi53514060;     JteBZqhlVXNpvaDSGoruQLjbi53514060 = JteBZqhlVXNpvaDSGoruQLjbi37637051;     JteBZqhlVXNpvaDSGoruQLjbi37637051 = JteBZqhlVXNpvaDSGoruQLjbi80146865;     JteBZqhlVXNpvaDSGoruQLjbi80146865 = JteBZqhlVXNpvaDSGoruQLjbi25921881;     JteBZqhlVXNpvaDSGoruQLjbi25921881 = JteBZqhlVXNpvaDSGoruQLjbi45415823;     JteBZqhlVXNpvaDSGoruQLjbi45415823 = JteBZqhlVXNpvaDSGoruQLjbi19748693;     JteBZqhlVXNpvaDSGoruQLjbi19748693 = JteBZqhlVXNpvaDSGoruQLjbi45442000;     JteBZqhlVXNpvaDSGoruQLjbi45442000 = JteBZqhlVXNpvaDSGoruQLjbi73502258;     JteBZqhlVXNpvaDSGoruQLjbi73502258 = JteBZqhlVXNpvaDSGoruQLjbi78445752;     JteBZqhlVXNpvaDSGoruQLjbi78445752 = JteBZqhlVXNpvaDSGoruQLjbi39976828;     JteBZqhlVXNpvaDSGoruQLjbi39976828 = JteBZqhlVXNpvaDSGoruQLjbi5779631;     JteBZqhlVXNpvaDSGoruQLjbi5779631 = JteBZqhlVXNpvaDSGoruQLjbi2380968;     JteBZqhlVXNpvaDSGoruQLjbi2380968 = JteBZqhlVXNpvaDSGoruQLjbi62587066;     JteBZqhlVXNpvaDSGoruQLjbi62587066 = JteBZqhlVXNpvaDSGoruQLjbi68637183;     JteBZqhlVXNpvaDSGoruQLjbi68637183 = JteBZqhlVXNpvaDSGoruQLjbi58759218;     JteBZqhlVXNpvaDSGoruQLjbi58759218 = JteBZqhlVXNpvaDSGoruQLjbi2620901;     JteBZqhlVXNpvaDSGoruQLjbi2620901 = JteBZqhlVXNpvaDSGoruQLjbi45998942;     JteBZqhlVXNpvaDSGoruQLjbi45998942 = JteBZqhlVXNpvaDSGoruQLjbi14895431;     JteBZqhlVXNpvaDSGoruQLjbi14895431 = JteBZqhlVXNpvaDSGoruQLjbi81798024;     JteBZqhlVXNpvaDSGoruQLjbi81798024 = JteBZqhlVXNpvaDSGoruQLjbi87208453;     JteBZqhlVXNpvaDSGoruQLjbi87208453 = JteBZqhlVXNpvaDSGoruQLjbi29872824;     JteBZqhlVXNpvaDSGoruQLjbi29872824 = JteBZqhlVXNpvaDSGoruQLjbi9356175;     JteBZqhlVXNpvaDSGoruQLjbi9356175 = JteBZqhlVXNpvaDSGoruQLjbi47101776;     JteBZqhlVXNpvaDSGoruQLjbi47101776 = JteBZqhlVXNpvaDSGoruQLjbi34410903;     JteBZqhlVXNpvaDSGoruQLjbi34410903 = JteBZqhlVXNpvaDSGoruQLjbi58614600;     JteBZqhlVXNpvaDSGoruQLjbi58614600 = JteBZqhlVXNpvaDSGoruQLjbi1332958;     JteBZqhlVXNpvaDSGoruQLjbi1332958 = JteBZqhlVXNpvaDSGoruQLjbi43925116;     JteBZqhlVXNpvaDSGoruQLjbi43925116 = JteBZqhlVXNpvaDSGoruQLjbi40549812;     JteBZqhlVXNpvaDSGoruQLjbi40549812 = JteBZqhlVXNpvaDSGoruQLjbi8097741;     JteBZqhlVXNpvaDSGoruQLjbi8097741 = JteBZqhlVXNpvaDSGoruQLjbi24428558;     JteBZqhlVXNpvaDSGoruQLjbi24428558 = JteBZqhlVXNpvaDSGoruQLjbi67898723;     JteBZqhlVXNpvaDSGoruQLjbi67898723 = JteBZqhlVXNpvaDSGoruQLjbi26603545;     JteBZqhlVXNpvaDSGoruQLjbi26603545 = JteBZqhlVXNpvaDSGoruQLjbi90017220;     JteBZqhlVXNpvaDSGoruQLjbi90017220 = JteBZqhlVXNpvaDSGoruQLjbi99002234;     JteBZqhlVXNpvaDSGoruQLjbi99002234 = JteBZqhlVXNpvaDSGoruQLjbi77467536;     JteBZqhlVXNpvaDSGoruQLjbi77467536 = JteBZqhlVXNpvaDSGoruQLjbi83801427;     JteBZqhlVXNpvaDSGoruQLjbi83801427 = JteBZqhlVXNpvaDSGoruQLjbi75164403;     JteBZqhlVXNpvaDSGoruQLjbi75164403 = JteBZqhlVXNpvaDSGoruQLjbi85910374;     JteBZqhlVXNpvaDSGoruQLjbi85910374 = JteBZqhlVXNpvaDSGoruQLjbi25014984;     JteBZqhlVXNpvaDSGoruQLjbi25014984 = JteBZqhlVXNpvaDSGoruQLjbi86574334;     JteBZqhlVXNpvaDSGoruQLjbi86574334 = JteBZqhlVXNpvaDSGoruQLjbi46667171;     JteBZqhlVXNpvaDSGoruQLjbi46667171 = JteBZqhlVXNpvaDSGoruQLjbi25969466;     JteBZqhlVXNpvaDSGoruQLjbi25969466 = JteBZqhlVXNpvaDSGoruQLjbi63845564;     JteBZqhlVXNpvaDSGoruQLjbi63845564 = JteBZqhlVXNpvaDSGoruQLjbi55661297;     JteBZqhlVXNpvaDSGoruQLjbi55661297 = JteBZqhlVXNpvaDSGoruQLjbi56398918;     JteBZqhlVXNpvaDSGoruQLjbi56398918 = JteBZqhlVXNpvaDSGoruQLjbi57181483;     JteBZqhlVXNpvaDSGoruQLjbi57181483 = JteBZqhlVXNpvaDSGoruQLjbi16414517;     JteBZqhlVXNpvaDSGoruQLjbi16414517 = JteBZqhlVXNpvaDSGoruQLjbi76658039;     JteBZqhlVXNpvaDSGoruQLjbi76658039 = JteBZqhlVXNpvaDSGoruQLjbi38141462;     JteBZqhlVXNpvaDSGoruQLjbi38141462 = JteBZqhlVXNpvaDSGoruQLjbi29028558;     JteBZqhlVXNpvaDSGoruQLjbi29028558 = JteBZqhlVXNpvaDSGoruQLjbi15187010;     JteBZqhlVXNpvaDSGoruQLjbi15187010 = JteBZqhlVXNpvaDSGoruQLjbi75301875;     JteBZqhlVXNpvaDSGoruQLjbi75301875 = JteBZqhlVXNpvaDSGoruQLjbi27424728;     JteBZqhlVXNpvaDSGoruQLjbi27424728 = JteBZqhlVXNpvaDSGoruQLjbi42747993;     JteBZqhlVXNpvaDSGoruQLjbi42747993 = JteBZqhlVXNpvaDSGoruQLjbi14349413;     JteBZqhlVXNpvaDSGoruQLjbi14349413 = JteBZqhlVXNpvaDSGoruQLjbi44157885;     JteBZqhlVXNpvaDSGoruQLjbi44157885 = JteBZqhlVXNpvaDSGoruQLjbi90535274;     JteBZqhlVXNpvaDSGoruQLjbi90535274 = JteBZqhlVXNpvaDSGoruQLjbi45735962;     JteBZqhlVXNpvaDSGoruQLjbi45735962 = JteBZqhlVXNpvaDSGoruQLjbi67307280;     JteBZqhlVXNpvaDSGoruQLjbi67307280 = JteBZqhlVXNpvaDSGoruQLjbi44082865;     JteBZqhlVXNpvaDSGoruQLjbi44082865 = JteBZqhlVXNpvaDSGoruQLjbi75823577;     JteBZqhlVXNpvaDSGoruQLjbi75823577 = JteBZqhlVXNpvaDSGoruQLjbi4892189;     JteBZqhlVXNpvaDSGoruQLjbi4892189 = JteBZqhlVXNpvaDSGoruQLjbi65404518;     JteBZqhlVXNpvaDSGoruQLjbi65404518 = JteBZqhlVXNpvaDSGoruQLjbi54017195;     JteBZqhlVXNpvaDSGoruQLjbi54017195 = JteBZqhlVXNpvaDSGoruQLjbi72078104;     JteBZqhlVXNpvaDSGoruQLjbi72078104 = JteBZqhlVXNpvaDSGoruQLjbi79176086;     JteBZqhlVXNpvaDSGoruQLjbi79176086 = JteBZqhlVXNpvaDSGoruQLjbi12363748;     JteBZqhlVXNpvaDSGoruQLjbi12363748 = JteBZqhlVXNpvaDSGoruQLjbi63584831;     JteBZqhlVXNpvaDSGoruQLjbi63584831 = JteBZqhlVXNpvaDSGoruQLjbi91169647;     JteBZqhlVXNpvaDSGoruQLjbi91169647 = JteBZqhlVXNpvaDSGoruQLjbi18177051;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void vLOmNyKzaSQdxcpOAtJdaXNZjwtUsvPJXAMpsbORwoURiPSMUaRAGqEYx63881051() {     long pCQEqHfCGFxQAWYeshmCvrUeg53636019 = -641741202;    long pCQEqHfCGFxQAWYeshmCvrUeg93606618 = -578530136;    long pCQEqHfCGFxQAWYeshmCvrUeg26606815 = -4692831;    long pCQEqHfCGFxQAWYeshmCvrUeg9673847 = -932466148;    long pCQEqHfCGFxQAWYeshmCvrUeg96032468 = -58138258;    long pCQEqHfCGFxQAWYeshmCvrUeg21837382 = -816393796;    long pCQEqHfCGFxQAWYeshmCvrUeg68753435 = -801788800;    long pCQEqHfCGFxQAWYeshmCvrUeg97957856 = -143617417;    long pCQEqHfCGFxQAWYeshmCvrUeg21491272 = -482486137;    long pCQEqHfCGFxQAWYeshmCvrUeg58127183 = -906555164;    long pCQEqHfCGFxQAWYeshmCvrUeg69163331 = -786243440;    long pCQEqHfCGFxQAWYeshmCvrUeg22006627 = 69982078;    long pCQEqHfCGFxQAWYeshmCvrUeg93545914 = -812074666;    long pCQEqHfCGFxQAWYeshmCvrUeg64973118 = -949871565;    long pCQEqHfCGFxQAWYeshmCvrUeg28625323 = -633664014;    long pCQEqHfCGFxQAWYeshmCvrUeg89864328 = -534154575;    long pCQEqHfCGFxQAWYeshmCvrUeg47945107 = -508409224;    long pCQEqHfCGFxQAWYeshmCvrUeg99231915 = 17538918;    long pCQEqHfCGFxQAWYeshmCvrUeg42841646 = -796601916;    long pCQEqHfCGFxQAWYeshmCvrUeg89475343 = -495380019;    long pCQEqHfCGFxQAWYeshmCvrUeg75265412 = -290868522;    long pCQEqHfCGFxQAWYeshmCvrUeg62983975 = -60708613;    long pCQEqHfCGFxQAWYeshmCvrUeg49526963 = -313919333;    long pCQEqHfCGFxQAWYeshmCvrUeg39088168 = -206190575;    long pCQEqHfCGFxQAWYeshmCvrUeg4918632 = -133731901;    long pCQEqHfCGFxQAWYeshmCvrUeg42347631 = -570318482;    long pCQEqHfCGFxQAWYeshmCvrUeg21606526 = -346759329;    long pCQEqHfCGFxQAWYeshmCvrUeg30925731 = -503557742;    long pCQEqHfCGFxQAWYeshmCvrUeg55890966 = -365982745;    long pCQEqHfCGFxQAWYeshmCvrUeg35489857 = -115092055;    long pCQEqHfCGFxQAWYeshmCvrUeg62805468 = -702529338;    long pCQEqHfCGFxQAWYeshmCvrUeg91337078 = -279976324;    long pCQEqHfCGFxQAWYeshmCvrUeg49855062 = -566469444;    long pCQEqHfCGFxQAWYeshmCvrUeg9895293 = -124321499;    long pCQEqHfCGFxQAWYeshmCvrUeg91730334 = -256079869;    long pCQEqHfCGFxQAWYeshmCvrUeg96976666 = -97272638;    long pCQEqHfCGFxQAWYeshmCvrUeg69160509 = -258613182;    long pCQEqHfCGFxQAWYeshmCvrUeg96657403 = -43019879;    long pCQEqHfCGFxQAWYeshmCvrUeg3892820 = -296664863;    long pCQEqHfCGFxQAWYeshmCvrUeg42717285 = -440988727;    long pCQEqHfCGFxQAWYeshmCvrUeg73428435 = -654292313;    long pCQEqHfCGFxQAWYeshmCvrUeg95144757 = -609425284;    long pCQEqHfCGFxQAWYeshmCvrUeg91764346 = -563138036;    long pCQEqHfCGFxQAWYeshmCvrUeg2718405 = -859368658;    long pCQEqHfCGFxQAWYeshmCvrUeg68653642 = -101895365;    long pCQEqHfCGFxQAWYeshmCvrUeg4720547 = -388114963;    long pCQEqHfCGFxQAWYeshmCvrUeg21966065 = -289864849;    long pCQEqHfCGFxQAWYeshmCvrUeg63725254 = -39204366;    long pCQEqHfCGFxQAWYeshmCvrUeg37788097 = -814048187;    long pCQEqHfCGFxQAWYeshmCvrUeg6327614 = -998494707;    long pCQEqHfCGFxQAWYeshmCvrUeg67979177 = 17263;    long pCQEqHfCGFxQAWYeshmCvrUeg13358297 = -333682383;    long pCQEqHfCGFxQAWYeshmCvrUeg77977323 = -40005840;    long pCQEqHfCGFxQAWYeshmCvrUeg63093623 = -323256399;    long pCQEqHfCGFxQAWYeshmCvrUeg88615639 = -710030197;    long pCQEqHfCGFxQAWYeshmCvrUeg90652043 = -481032589;    long pCQEqHfCGFxQAWYeshmCvrUeg44079656 = -164610803;    long pCQEqHfCGFxQAWYeshmCvrUeg87518647 = -798502256;    long pCQEqHfCGFxQAWYeshmCvrUeg4755216 = -698734248;    long pCQEqHfCGFxQAWYeshmCvrUeg53684838 = -487819776;    long pCQEqHfCGFxQAWYeshmCvrUeg230856 = -369634468;    long pCQEqHfCGFxQAWYeshmCvrUeg37827705 = -198231058;    long pCQEqHfCGFxQAWYeshmCvrUeg42066891 = -777634672;    long pCQEqHfCGFxQAWYeshmCvrUeg86001414 = -267394082;    long pCQEqHfCGFxQAWYeshmCvrUeg95321715 = -104025827;    long pCQEqHfCGFxQAWYeshmCvrUeg77826252 = -406267117;    long pCQEqHfCGFxQAWYeshmCvrUeg72151565 = -363548478;    long pCQEqHfCGFxQAWYeshmCvrUeg83650622 = -587753168;    long pCQEqHfCGFxQAWYeshmCvrUeg73242784 = -593791696;    long pCQEqHfCGFxQAWYeshmCvrUeg31648656 = -436391377;    long pCQEqHfCGFxQAWYeshmCvrUeg20703819 = -175541394;    long pCQEqHfCGFxQAWYeshmCvrUeg51287704 = -365389345;    long pCQEqHfCGFxQAWYeshmCvrUeg95339096 = -685796220;    long pCQEqHfCGFxQAWYeshmCvrUeg124362 = -255613190;    long pCQEqHfCGFxQAWYeshmCvrUeg16046908 = -841087707;    long pCQEqHfCGFxQAWYeshmCvrUeg80120654 = -681443239;    long pCQEqHfCGFxQAWYeshmCvrUeg71219629 = -497570577;    long pCQEqHfCGFxQAWYeshmCvrUeg46808558 = -454550676;    long pCQEqHfCGFxQAWYeshmCvrUeg70434526 = -4295211;    long pCQEqHfCGFxQAWYeshmCvrUeg198085 = -745616938;    long pCQEqHfCGFxQAWYeshmCvrUeg20381566 = -180453634;    long pCQEqHfCGFxQAWYeshmCvrUeg57881272 = -207554963;    long pCQEqHfCGFxQAWYeshmCvrUeg93137634 = -689509555;    long pCQEqHfCGFxQAWYeshmCvrUeg49563353 = -367488039;    long pCQEqHfCGFxQAWYeshmCvrUeg67510680 = -15109319;    long pCQEqHfCGFxQAWYeshmCvrUeg49447172 = -268846956;    long pCQEqHfCGFxQAWYeshmCvrUeg13359755 = -139970485;    long pCQEqHfCGFxQAWYeshmCvrUeg86761439 = -143213046;    long pCQEqHfCGFxQAWYeshmCvrUeg21279653 = -414291302;    long pCQEqHfCGFxQAWYeshmCvrUeg1078291 = -775047280;    long pCQEqHfCGFxQAWYeshmCvrUeg52897010 = -932661835;    long pCQEqHfCGFxQAWYeshmCvrUeg81641862 = -460110926;    long pCQEqHfCGFxQAWYeshmCvrUeg91902188 = -344285632;    long pCQEqHfCGFxQAWYeshmCvrUeg50207982 = -808845087;    long pCQEqHfCGFxQAWYeshmCvrUeg42486429 = 28645741;    long pCQEqHfCGFxQAWYeshmCvrUeg35600731 = -356061256;    long pCQEqHfCGFxQAWYeshmCvrUeg53077867 = -831790612;    long pCQEqHfCGFxQAWYeshmCvrUeg5762932 = -195743954;    long pCQEqHfCGFxQAWYeshmCvrUeg7396690 = -655342832;    long pCQEqHfCGFxQAWYeshmCvrUeg90827389 = -641741202;     pCQEqHfCGFxQAWYeshmCvrUeg53636019 = pCQEqHfCGFxQAWYeshmCvrUeg93606618;     pCQEqHfCGFxQAWYeshmCvrUeg93606618 = pCQEqHfCGFxQAWYeshmCvrUeg26606815;     pCQEqHfCGFxQAWYeshmCvrUeg26606815 = pCQEqHfCGFxQAWYeshmCvrUeg9673847;     pCQEqHfCGFxQAWYeshmCvrUeg9673847 = pCQEqHfCGFxQAWYeshmCvrUeg96032468;     pCQEqHfCGFxQAWYeshmCvrUeg96032468 = pCQEqHfCGFxQAWYeshmCvrUeg21837382;     pCQEqHfCGFxQAWYeshmCvrUeg21837382 = pCQEqHfCGFxQAWYeshmCvrUeg68753435;     pCQEqHfCGFxQAWYeshmCvrUeg68753435 = pCQEqHfCGFxQAWYeshmCvrUeg97957856;     pCQEqHfCGFxQAWYeshmCvrUeg97957856 = pCQEqHfCGFxQAWYeshmCvrUeg21491272;     pCQEqHfCGFxQAWYeshmCvrUeg21491272 = pCQEqHfCGFxQAWYeshmCvrUeg58127183;     pCQEqHfCGFxQAWYeshmCvrUeg58127183 = pCQEqHfCGFxQAWYeshmCvrUeg69163331;     pCQEqHfCGFxQAWYeshmCvrUeg69163331 = pCQEqHfCGFxQAWYeshmCvrUeg22006627;     pCQEqHfCGFxQAWYeshmCvrUeg22006627 = pCQEqHfCGFxQAWYeshmCvrUeg93545914;     pCQEqHfCGFxQAWYeshmCvrUeg93545914 = pCQEqHfCGFxQAWYeshmCvrUeg64973118;     pCQEqHfCGFxQAWYeshmCvrUeg64973118 = pCQEqHfCGFxQAWYeshmCvrUeg28625323;     pCQEqHfCGFxQAWYeshmCvrUeg28625323 = pCQEqHfCGFxQAWYeshmCvrUeg89864328;     pCQEqHfCGFxQAWYeshmCvrUeg89864328 = pCQEqHfCGFxQAWYeshmCvrUeg47945107;     pCQEqHfCGFxQAWYeshmCvrUeg47945107 = pCQEqHfCGFxQAWYeshmCvrUeg99231915;     pCQEqHfCGFxQAWYeshmCvrUeg99231915 = pCQEqHfCGFxQAWYeshmCvrUeg42841646;     pCQEqHfCGFxQAWYeshmCvrUeg42841646 = pCQEqHfCGFxQAWYeshmCvrUeg89475343;     pCQEqHfCGFxQAWYeshmCvrUeg89475343 = pCQEqHfCGFxQAWYeshmCvrUeg75265412;     pCQEqHfCGFxQAWYeshmCvrUeg75265412 = pCQEqHfCGFxQAWYeshmCvrUeg62983975;     pCQEqHfCGFxQAWYeshmCvrUeg62983975 = pCQEqHfCGFxQAWYeshmCvrUeg49526963;     pCQEqHfCGFxQAWYeshmCvrUeg49526963 = pCQEqHfCGFxQAWYeshmCvrUeg39088168;     pCQEqHfCGFxQAWYeshmCvrUeg39088168 = pCQEqHfCGFxQAWYeshmCvrUeg4918632;     pCQEqHfCGFxQAWYeshmCvrUeg4918632 = pCQEqHfCGFxQAWYeshmCvrUeg42347631;     pCQEqHfCGFxQAWYeshmCvrUeg42347631 = pCQEqHfCGFxQAWYeshmCvrUeg21606526;     pCQEqHfCGFxQAWYeshmCvrUeg21606526 = pCQEqHfCGFxQAWYeshmCvrUeg30925731;     pCQEqHfCGFxQAWYeshmCvrUeg30925731 = pCQEqHfCGFxQAWYeshmCvrUeg55890966;     pCQEqHfCGFxQAWYeshmCvrUeg55890966 = pCQEqHfCGFxQAWYeshmCvrUeg35489857;     pCQEqHfCGFxQAWYeshmCvrUeg35489857 = pCQEqHfCGFxQAWYeshmCvrUeg62805468;     pCQEqHfCGFxQAWYeshmCvrUeg62805468 = pCQEqHfCGFxQAWYeshmCvrUeg91337078;     pCQEqHfCGFxQAWYeshmCvrUeg91337078 = pCQEqHfCGFxQAWYeshmCvrUeg49855062;     pCQEqHfCGFxQAWYeshmCvrUeg49855062 = pCQEqHfCGFxQAWYeshmCvrUeg9895293;     pCQEqHfCGFxQAWYeshmCvrUeg9895293 = pCQEqHfCGFxQAWYeshmCvrUeg91730334;     pCQEqHfCGFxQAWYeshmCvrUeg91730334 = pCQEqHfCGFxQAWYeshmCvrUeg96976666;     pCQEqHfCGFxQAWYeshmCvrUeg96976666 = pCQEqHfCGFxQAWYeshmCvrUeg69160509;     pCQEqHfCGFxQAWYeshmCvrUeg69160509 = pCQEqHfCGFxQAWYeshmCvrUeg96657403;     pCQEqHfCGFxQAWYeshmCvrUeg96657403 = pCQEqHfCGFxQAWYeshmCvrUeg3892820;     pCQEqHfCGFxQAWYeshmCvrUeg3892820 = pCQEqHfCGFxQAWYeshmCvrUeg42717285;     pCQEqHfCGFxQAWYeshmCvrUeg42717285 = pCQEqHfCGFxQAWYeshmCvrUeg73428435;     pCQEqHfCGFxQAWYeshmCvrUeg73428435 = pCQEqHfCGFxQAWYeshmCvrUeg95144757;     pCQEqHfCGFxQAWYeshmCvrUeg95144757 = pCQEqHfCGFxQAWYeshmCvrUeg91764346;     pCQEqHfCGFxQAWYeshmCvrUeg91764346 = pCQEqHfCGFxQAWYeshmCvrUeg2718405;     pCQEqHfCGFxQAWYeshmCvrUeg2718405 = pCQEqHfCGFxQAWYeshmCvrUeg68653642;     pCQEqHfCGFxQAWYeshmCvrUeg68653642 = pCQEqHfCGFxQAWYeshmCvrUeg4720547;     pCQEqHfCGFxQAWYeshmCvrUeg4720547 = pCQEqHfCGFxQAWYeshmCvrUeg21966065;     pCQEqHfCGFxQAWYeshmCvrUeg21966065 = pCQEqHfCGFxQAWYeshmCvrUeg63725254;     pCQEqHfCGFxQAWYeshmCvrUeg63725254 = pCQEqHfCGFxQAWYeshmCvrUeg37788097;     pCQEqHfCGFxQAWYeshmCvrUeg37788097 = pCQEqHfCGFxQAWYeshmCvrUeg6327614;     pCQEqHfCGFxQAWYeshmCvrUeg6327614 = pCQEqHfCGFxQAWYeshmCvrUeg67979177;     pCQEqHfCGFxQAWYeshmCvrUeg67979177 = pCQEqHfCGFxQAWYeshmCvrUeg13358297;     pCQEqHfCGFxQAWYeshmCvrUeg13358297 = pCQEqHfCGFxQAWYeshmCvrUeg77977323;     pCQEqHfCGFxQAWYeshmCvrUeg77977323 = pCQEqHfCGFxQAWYeshmCvrUeg63093623;     pCQEqHfCGFxQAWYeshmCvrUeg63093623 = pCQEqHfCGFxQAWYeshmCvrUeg88615639;     pCQEqHfCGFxQAWYeshmCvrUeg88615639 = pCQEqHfCGFxQAWYeshmCvrUeg90652043;     pCQEqHfCGFxQAWYeshmCvrUeg90652043 = pCQEqHfCGFxQAWYeshmCvrUeg44079656;     pCQEqHfCGFxQAWYeshmCvrUeg44079656 = pCQEqHfCGFxQAWYeshmCvrUeg87518647;     pCQEqHfCGFxQAWYeshmCvrUeg87518647 = pCQEqHfCGFxQAWYeshmCvrUeg4755216;     pCQEqHfCGFxQAWYeshmCvrUeg4755216 = pCQEqHfCGFxQAWYeshmCvrUeg53684838;     pCQEqHfCGFxQAWYeshmCvrUeg53684838 = pCQEqHfCGFxQAWYeshmCvrUeg230856;     pCQEqHfCGFxQAWYeshmCvrUeg230856 = pCQEqHfCGFxQAWYeshmCvrUeg37827705;     pCQEqHfCGFxQAWYeshmCvrUeg37827705 = pCQEqHfCGFxQAWYeshmCvrUeg42066891;     pCQEqHfCGFxQAWYeshmCvrUeg42066891 = pCQEqHfCGFxQAWYeshmCvrUeg86001414;     pCQEqHfCGFxQAWYeshmCvrUeg86001414 = pCQEqHfCGFxQAWYeshmCvrUeg95321715;     pCQEqHfCGFxQAWYeshmCvrUeg95321715 = pCQEqHfCGFxQAWYeshmCvrUeg77826252;     pCQEqHfCGFxQAWYeshmCvrUeg77826252 = pCQEqHfCGFxQAWYeshmCvrUeg72151565;     pCQEqHfCGFxQAWYeshmCvrUeg72151565 = pCQEqHfCGFxQAWYeshmCvrUeg83650622;     pCQEqHfCGFxQAWYeshmCvrUeg83650622 = pCQEqHfCGFxQAWYeshmCvrUeg73242784;     pCQEqHfCGFxQAWYeshmCvrUeg73242784 = pCQEqHfCGFxQAWYeshmCvrUeg31648656;     pCQEqHfCGFxQAWYeshmCvrUeg31648656 = pCQEqHfCGFxQAWYeshmCvrUeg20703819;     pCQEqHfCGFxQAWYeshmCvrUeg20703819 = pCQEqHfCGFxQAWYeshmCvrUeg51287704;     pCQEqHfCGFxQAWYeshmCvrUeg51287704 = pCQEqHfCGFxQAWYeshmCvrUeg95339096;     pCQEqHfCGFxQAWYeshmCvrUeg95339096 = pCQEqHfCGFxQAWYeshmCvrUeg124362;     pCQEqHfCGFxQAWYeshmCvrUeg124362 = pCQEqHfCGFxQAWYeshmCvrUeg16046908;     pCQEqHfCGFxQAWYeshmCvrUeg16046908 = pCQEqHfCGFxQAWYeshmCvrUeg80120654;     pCQEqHfCGFxQAWYeshmCvrUeg80120654 = pCQEqHfCGFxQAWYeshmCvrUeg71219629;     pCQEqHfCGFxQAWYeshmCvrUeg71219629 = pCQEqHfCGFxQAWYeshmCvrUeg46808558;     pCQEqHfCGFxQAWYeshmCvrUeg46808558 = pCQEqHfCGFxQAWYeshmCvrUeg70434526;     pCQEqHfCGFxQAWYeshmCvrUeg70434526 = pCQEqHfCGFxQAWYeshmCvrUeg198085;     pCQEqHfCGFxQAWYeshmCvrUeg198085 = pCQEqHfCGFxQAWYeshmCvrUeg20381566;     pCQEqHfCGFxQAWYeshmCvrUeg20381566 = pCQEqHfCGFxQAWYeshmCvrUeg57881272;     pCQEqHfCGFxQAWYeshmCvrUeg57881272 = pCQEqHfCGFxQAWYeshmCvrUeg93137634;     pCQEqHfCGFxQAWYeshmCvrUeg93137634 = pCQEqHfCGFxQAWYeshmCvrUeg49563353;     pCQEqHfCGFxQAWYeshmCvrUeg49563353 = pCQEqHfCGFxQAWYeshmCvrUeg67510680;     pCQEqHfCGFxQAWYeshmCvrUeg67510680 = pCQEqHfCGFxQAWYeshmCvrUeg49447172;     pCQEqHfCGFxQAWYeshmCvrUeg49447172 = pCQEqHfCGFxQAWYeshmCvrUeg13359755;     pCQEqHfCGFxQAWYeshmCvrUeg13359755 = pCQEqHfCGFxQAWYeshmCvrUeg86761439;     pCQEqHfCGFxQAWYeshmCvrUeg86761439 = pCQEqHfCGFxQAWYeshmCvrUeg21279653;     pCQEqHfCGFxQAWYeshmCvrUeg21279653 = pCQEqHfCGFxQAWYeshmCvrUeg1078291;     pCQEqHfCGFxQAWYeshmCvrUeg1078291 = pCQEqHfCGFxQAWYeshmCvrUeg52897010;     pCQEqHfCGFxQAWYeshmCvrUeg52897010 = pCQEqHfCGFxQAWYeshmCvrUeg81641862;     pCQEqHfCGFxQAWYeshmCvrUeg81641862 = pCQEqHfCGFxQAWYeshmCvrUeg91902188;     pCQEqHfCGFxQAWYeshmCvrUeg91902188 = pCQEqHfCGFxQAWYeshmCvrUeg50207982;     pCQEqHfCGFxQAWYeshmCvrUeg50207982 = pCQEqHfCGFxQAWYeshmCvrUeg42486429;     pCQEqHfCGFxQAWYeshmCvrUeg42486429 = pCQEqHfCGFxQAWYeshmCvrUeg35600731;     pCQEqHfCGFxQAWYeshmCvrUeg35600731 = pCQEqHfCGFxQAWYeshmCvrUeg53077867;     pCQEqHfCGFxQAWYeshmCvrUeg53077867 = pCQEqHfCGFxQAWYeshmCvrUeg5762932;     pCQEqHfCGFxQAWYeshmCvrUeg5762932 = pCQEqHfCGFxQAWYeshmCvrUeg7396690;     pCQEqHfCGFxQAWYeshmCvrUeg7396690 = pCQEqHfCGFxQAWYeshmCvrUeg90827389;     pCQEqHfCGFxQAWYeshmCvrUeg90827389 = pCQEqHfCGFxQAWYeshmCvrUeg53636019;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void BZPXWkrSjEeoJZRUbrYDJGzAJnnTbxSAcTsfKfxdkKtGzXRVZMMpMtIua78930119() {     long ONjxXqmmeMqgmJwuuSzNtAlVR59753126 = -753643091;    long ONjxXqmmeMqgmJwuuSzNtAlVR36979898 = -288129916;    long ONjxXqmmeMqgmJwuuSzNtAlVR42648999 = -155525752;    long ONjxXqmmeMqgmJwuuSzNtAlVR36748627 = -23214779;    long ONjxXqmmeMqgmJwuuSzNtAlVR64927957 = -578788129;    long ONjxXqmmeMqgmJwuuSzNtAlVR13254584 = 19109969;    long ONjxXqmmeMqgmJwuuSzNtAlVR29242402 = -940753777;    long ONjxXqmmeMqgmJwuuSzNtAlVR47717748 = -430491330;    long ONjxXqmmeMqgmJwuuSzNtAlVR86133767 = -250518802;    long ONjxXqmmeMqgmJwuuSzNtAlVR99356842 = -135530642;    long ONjxXqmmeMqgmJwuuSzNtAlVR29273621 = -663681027;    long ONjxXqmmeMqgmJwuuSzNtAlVR53829669 = -374424124;    long ONjxXqmmeMqgmJwuuSzNtAlVR79755033 = -151965755;    long ONjxXqmmeMqgmJwuuSzNtAlVR48116795 = -382110132;    long ONjxXqmmeMqgmJwuuSzNtAlVR24367749 = -224126181;    long ONjxXqmmeMqgmJwuuSzNtAlVR31369722 = -507154118;    long ONjxXqmmeMqgmJwuuSzNtAlVR41781110 = -24954337;    long ONjxXqmmeMqgmJwuuSzNtAlVR96285068 = -747983725;    long ONjxXqmmeMqgmJwuuSzNtAlVR4671488 = -102371013;    long ONjxXqmmeMqgmJwuuSzNtAlVR70025508 = -852282939;    long ONjxXqmmeMqgmJwuuSzNtAlVR63818605 = -146355978;    long ONjxXqmmeMqgmJwuuSzNtAlVR49504999 = 31361671;    long ONjxXqmmeMqgmJwuuSzNtAlVR85117754 = -60436820;    long ONjxXqmmeMqgmJwuuSzNtAlVR23080542 = -428495563;    long ONjxXqmmeMqgmJwuuSzNtAlVR48618281 = -506927934;    long ONjxXqmmeMqgmJwuuSzNtAlVR67069306 = -448973805;    long ONjxXqmmeMqgmJwuuSzNtAlVR20066304 = -247421532;    long ONjxXqmmeMqgmJwuuSzNtAlVR44032856 = -569486696;    long ONjxXqmmeMqgmJwuuSzNtAlVR22023222 = -588365450;    long ONjxXqmmeMqgmJwuuSzNtAlVR4105494 = 67437078;    long ONjxXqmmeMqgmJwuuSzNtAlVR55048017 = -615850276;    long ONjxXqmmeMqgmJwuuSzNtAlVR88947700 = 10576861;    long ONjxXqmmeMqgmJwuuSzNtAlVR59566010 = -459082815;    long ONjxXqmmeMqgmJwuuSzNtAlVR4725857 = -975863264;    long ONjxXqmmeMqgmJwuuSzNtAlVR53204986 = -894812974;    long ONjxXqmmeMqgmJwuuSzNtAlVR65702580 = -311298745;    long ONjxXqmmeMqgmJwuuSzNtAlVR50422444 = -212249051;    long ONjxXqmmeMqgmJwuuSzNtAlVR30747616 = -914525889;    long ONjxXqmmeMqgmJwuuSzNtAlVR77503073 = -290588359;    long ONjxXqmmeMqgmJwuuSzNtAlVR30219223 = -914427949;    long ONjxXqmmeMqgmJwuuSzNtAlVR79097659 = -719566207;    long ONjxXqmmeMqgmJwuuSzNtAlVR27295215 = -879567562;    long ONjxXqmmeMqgmJwuuSzNtAlVR69831324 = -643942620;    long ONjxXqmmeMqgmJwuuSzNtAlVR90126145 = -878711596;    long ONjxXqmmeMqgmJwuuSzNtAlVR80606107 = -863793519;    long ONjxXqmmeMqgmJwuuSzNtAlVR16659742 = -373331080;    long ONjxXqmmeMqgmJwuuSzNtAlVR39744639 = -408640387;    long ONjxXqmmeMqgmJwuuSzNtAlVR71682194 = -49099899;    long ONjxXqmmeMqgmJwuuSzNtAlVR47463826 = -899785175;    long ONjxXqmmeMqgmJwuuSzNtAlVR19239266 = 14494485;    long ONjxXqmmeMqgmJwuuSzNtAlVR3679856 = -942276408;    long ONjxXqmmeMqgmJwuuSzNtAlVR24168016 = -134408703;    long ONjxXqmmeMqgmJwuuSzNtAlVR26225781 = -931795427;    long ONjxXqmmeMqgmJwuuSzNtAlVR59062503 = -643726545;    long ONjxXqmmeMqgmJwuuSzNtAlVR15111515 = -310561979;    long ONjxXqmmeMqgmJwuuSzNtAlVR10248127 = -685004762;    long ONjxXqmmeMqgmJwuuSzNtAlVR51862144 = -127693097;    long ONjxXqmmeMqgmJwuuSzNtAlVR19568457 = -727030190;    long ONjxXqmmeMqgmJwuuSzNtAlVR88130345 = -516286845;    long ONjxXqmmeMqgmJwuuSzNtAlVR97858650 = -29814324;    long ONjxXqmmeMqgmJwuuSzNtAlVR93188280 = -733468500;    long ONjxXqmmeMqgmJwuuSzNtAlVR85209545 = -271267081;    long ONjxXqmmeMqgmJwuuSzNtAlVR25694526 = -842125881;    long ONjxXqmmeMqgmJwuuSzNtAlVR82028273 = -217955880;    long ONjxXqmmeMqgmJwuuSzNtAlVR44308825 = -519680366;    long ONjxXqmmeMqgmJwuuSzNtAlVR40325921 = -574257888;    long ONjxXqmmeMqgmJwuuSzNtAlVR94263659 = -915341310;    long ONjxXqmmeMqgmJwuuSzNtAlVR75029176 = -176102492;    long ONjxXqmmeMqgmJwuuSzNtAlVR94911808 = -487297159;    long ONjxXqmmeMqgmJwuuSzNtAlVR58665169 = -912827436;    long ONjxXqmmeMqgmJwuuSzNtAlVR80947277 = -194905067;    long ONjxXqmmeMqgmJwuuSzNtAlVR11033495 = -110428448;    long ONjxXqmmeMqgmJwuuSzNtAlVR18781996 = -357395366;    long ONjxXqmmeMqgmJwuuSzNtAlVR74452265 = -187943064;    long ONjxXqmmeMqgmJwuuSzNtAlVR90927848 = -32716732;    long ONjxXqmmeMqgmJwuuSzNtAlVR36523391 = -266788416;    long ONjxXqmmeMqgmJwuuSzNtAlVR79673674 = -324695710;    long ONjxXqmmeMqgmJwuuSzNtAlVR94991609 = -181725224;    long ONjxXqmmeMqgmJwuuSzNtAlVR42474435 = -564702044;    long ONjxXqmmeMqgmJwuuSzNtAlVR31958540 = -33596855;    long ONjxXqmmeMqgmJwuuSzNtAlVR27324667 = 59666581;    long ONjxXqmmeMqgmJwuuSzNtAlVR48384109 = -98321634;    long ONjxXqmmeMqgmJwuuSzNtAlVR96569030 = -669701521;    long ONjxXqmmeMqgmJwuuSzNtAlVR2783956 = -502859935;    long ONjxXqmmeMqgmJwuuSzNtAlVR425639 = 9713485;    long ONjxXqmmeMqgmJwuuSzNtAlVR30880002 = -381441574;    long ONjxXqmmeMqgmJwuuSzNtAlVR62721919 = -57627713;    long ONjxXqmmeMqgmJwuuSzNtAlVR503508 = -815356271;    long ONjxXqmmeMqgmJwuuSzNtAlVR89614342 = -565301285;    long ONjxXqmmeMqgmJwuuSzNtAlVR42956860 = -109808213;    long ONjxXqmmeMqgmJwuuSzNtAlVR13840436 = -83605649;    long ONjxXqmmeMqgmJwuuSzNtAlVR30853987 = -485218862;    long ONjxXqmmeMqgmJwuuSzNtAlVR42617270 = -298239044;    long ONjxXqmmeMqgmJwuuSzNtAlVR79644422 = -160774036;    long ONjxXqmmeMqgmJwuuSzNtAlVR37030943 = -80959450;    long ONjxXqmmeMqgmJwuuSzNtAlVR93888114 = -348299127;    long ONjxXqmmeMqgmJwuuSzNtAlVR1600689 = 62558319;    long ONjxXqmmeMqgmJwuuSzNtAlVR87803051 = -325986740;    long ONjxXqmmeMqgmJwuuSzNtAlVR45817320 = -259031230;    long ONjxXqmmeMqgmJwuuSzNtAlVR40280186 = -753643091;     ONjxXqmmeMqgmJwuuSzNtAlVR59753126 = ONjxXqmmeMqgmJwuuSzNtAlVR36979898;     ONjxXqmmeMqgmJwuuSzNtAlVR36979898 = ONjxXqmmeMqgmJwuuSzNtAlVR42648999;     ONjxXqmmeMqgmJwuuSzNtAlVR42648999 = ONjxXqmmeMqgmJwuuSzNtAlVR36748627;     ONjxXqmmeMqgmJwuuSzNtAlVR36748627 = ONjxXqmmeMqgmJwuuSzNtAlVR64927957;     ONjxXqmmeMqgmJwuuSzNtAlVR64927957 = ONjxXqmmeMqgmJwuuSzNtAlVR13254584;     ONjxXqmmeMqgmJwuuSzNtAlVR13254584 = ONjxXqmmeMqgmJwuuSzNtAlVR29242402;     ONjxXqmmeMqgmJwuuSzNtAlVR29242402 = ONjxXqmmeMqgmJwuuSzNtAlVR47717748;     ONjxXqmmeMqgmJwuuSzNtAlVR47717748 = ONjxXqmmeMqgmJwuuSzNtAlVR86133767;     ONjxXqmmeMqgmJwuuSzNtAlVR86133767 = ONjxXqmmeMqgmJwuuSzNtAlVR99356842;     ONjxXqmmeMqgmJwuuSzNtAlVR99356842 = ONjxXqmmeMqgmJwuuSzNtAlVR29273621;     ONjxXqmmeMqgmJwuuSzNtAlVR29273621 = ONjxXqmmeMqgmJwuuSzNtAlVR53829669;     ONjxXqmmeMqgmJwuuSzNtAlVR53829669 = ONjxXqmmeMqgmJwuuSzNtAlVR79755033;     ONjxXqmmeMqgmJwuuSzNtAlVR79755033 = ONjxXqmmeMqgmJwuuSzNtAlVR48116795;     ONjxXqmmeMqgmJwuuSzNtAlVR48116795 = ONjxXqmmeMqgmJwuuSzNtAlVR24367749;     ONjxXqmmeMqgmJwuuSzNtAlVR24367749 = ONjxXqmmeMqgmJwuuSzNtAlVR31369722;     ONjxXqmmeMqgmJwuuSzNtAlVR31369722 = ONjxXqmmeMqgmJwuuSzNtAlVR41781110;     ONjxXqmmeMqgmJwuuSzNtAlVR41781110 = ONjxXqmmeMqgmJwuuSzNtAlVR96285068;     ONjxXqmmeMqgmJwuuSzNtAlVR96285068 = ONjxXqmmeMqgmJwuuSzNtAlVR4671488;     ONjxXqmmeMqgmJwuuSzNtAlVR4671488 = ONjxXqmmeMqgmJwuuSzNtAlVR70025508;     ONjxXqmmeMqgmJwuuSzNtAlVR70025508 = ONjxXqmmeMqgmJwuuSzNtAlVR63818605;     ONjxXqmmeMqgmJwuuSzNtAlVR63818605 = ONjxXqmmeMqgmJwuuSzNtAlVR49504999;     ONjxXqmmeMqgmJwuuSzNtAlVR49504999 = ONjxXqmmeMqgmJwuuSzNtAlVR85117754;     ONjxXqmmeMqgmJwuuSzNtAlVR85117754 = ONjxXqmmeMqgmJwuuSzNtAlVR23080542;     ONjxXqmmeMqgmJwuuSzNtAlVR23080542 = ONjxXqmmeMqgmJwuuSzNtAlVR48618281;     ONjxXqmmeMqgmJwuuSzNtAlVR48618281 = ONjxXqmmeMqgmJwuuSzNtAlVR67069306;     ONjxXqmmeMqgmJwuuSzNtAlVR67069306 = ONjxXqmmeMqgmJwuuSzNtAlVR20066304;     ONjxXqmmeMqgmJwuuSzNtAlVR20066304 = ONjxXqmmeMqgmJwuuSzNtAlVR44032856;     ONjxXqmmeMqgmJwuuSzNtAlVR44032856 = ONjxXqmmeMqgmJwuuSzNtAlVR22023222;     ONjxXqmmeMqgmJwuuSzNtAlVR22023222 = ONjxXqmmeMqgmJwuuSzNtAlVR4105494;     ONjxXqmmeMqgmJwuuSzNtAlVR4105494 = ONjxXqmmeMqgmJwuuSzNtAlVR55048017;     ONjxXqmmeMqgmJwuuSzNtAlVR55048017 = ONjxXqmmeMqgmJwuuSzNtAlVR88947700;     ONjxXqmmeMqgmJwuuSzNtAlVR88947700 = ONjxXqmmeMqgmJwuuSzNtAlVR59566010;     ONjxXqmmeMqgmJwuuSzNtAlVR59566010 = ONjxXqmmeMqgmJwuuSzNtAlVR4725857;     ONjxXqmmeMqgmJwuuSzNtAlVR4725857 = ONjxXqmmeMqgmJwuuSzNtAlVR53204986;     ONjxXqmmeMqgmJwuuSzNtAlVR53204986 = ONjxXqmmeMqgmJwuuSzNtAlVR65702580;     ONjxXqmmeMqgmJwuuSzNtAlVR65702580 = ONjxXqmmeMqgmJwuuSzNtAlVR50422444;     ONjxXqmmeMqgmJwuuSzNtAlVR50422444 = ONjxXqmmeMqgmJwuuSzNtAlVR30747616;     ONjxXqmmeMqgmJwuuSzNtAlVR30747616 = ONjxXqmmeMqgmJwuuSzNtAlVR77503073;     ONjxXqmmeMqgmJwuuSzNtAlVR77503073 = ONjxXqmmeMqgmJwuuSzNtAlVR30219223;     ONjxXqmmeMqgmJwuuSzNtAlVR30219223 = ONjxXqmmeMqgmJwuuSzNtAlVR79097659;     ONjxXqmmeMqgmJwuuSzNtAlVR79097659 = ONjxXqmmeMqgmJwuuSzNtAlVR27295215;     ONjxXqmmeMqgmJwuuSzNtAlVR27295215 = ONjxXqmmeMqgmJwuuSzNtAlVR69831324;     ONjxXqmmeMqgmJwuuSzNtAlVR69831324 = ONjxXqmmeMqgmJwuuSzNtAlVR90126145;     ONjxXqmmeMqgmJwuuSzNtAlVR90126145 = ONjxXqmmeMqgmJwuuSzNtAlVR80606107;     ONjxXqmmeMqgmJwuuSzNtAlVR80606107 = ONjxXqmmeMqgmJwuuSzNtAlVR16659742;     ONjxXqmmeMqgmJwuuSzNtAlVR16659742 = ONjxXqmmeMqgmJwuuSzNtAlVR39744639;     ONjxXqmmeMqgmJwuuSzNtAlVR39744639 = ONjxXqmmeMqgmJwuuSzNtAlVR71682194;     ONjxXqmmeMqgmJwuuSzNtAlVR71682194 = ONjxXqmmeMqgmJwuuSzNtAlVR47463826;     ONjxXqmmeMqgmJwuuSzNtAlVR47463826 = ONjxXqmmeMqgmJwuuSzNtAlVR19239266;     ONjxXqmmeMqgmJwuuSzNtAlVR19239266 = ONjxXqmmeMqgmJwuuSzNtAlVR3679856;     ONjxXqmmeMqgmJwuuSzNtAlVR3679856 = ONjxXqmmeMqgmJwuuSzNtAlVR24168016;     ONjxXqmmeMqgmJwuuSzNtAlVR24168016 = ONjxXqmmeMqgmJwuuSzNtAlVR26225781;     ONjxXqmmeMqgmJwuuSzNtAlVR26225781 = ONjxXqmmeMqgmJwuuSzNtAlVR59062503;     ONjxXqmmeMqgmJwuuSzNtAlVR59062503 = ONjxXqmmeMqgmJwuuSzNtAlVR15111515;     ONjxXqmmeMqgmJwuuSzNtAlVR15111515 = ONjxXqmmeMqgmJwuuSzNtAlVR10248127;     ONjxXqmmeMqgmJwuuSzNtAlVR10248127 = ONjxXqmmeMqgmJwuuSzNtAlVR51862144;     ONjxXqmmeMqgmJwuuSzNtAlVR51862144 = ONjxXqmmeMqgmJwuuSzNtAlVR19568457;     ONjxXqmmeMqgmJwuuSzNtAlVR19568457 = ONjxXqmmeMqgmJwuuSzNtAlVR88130345;     ONjxXqmmeMqgmJwuuSzNtAlVR88130345 = ONjxXqmmeMqgmJwuuSzNtAlVR97858650;     ONjxXqmmeMqgmJwuuSzNtAlVR97858650 = ONjxXqmmeMqgmJwuuSzNtAlVR93188280;     ONjxXqmmeMqgmJwuuSzNtAlVR93188280 = ONjxXqmmeMqgmJwuuSzNtAlVR85209545;     ONjxXqmmeMqgmJwuuSzNtAlVR85209545 = ONjxXqmmeMqgmJwuuSzNtAlVR25694526;     ONjxXqmmeMqgmJwuuSzNtAlVR25694526 = ONjxXqmmeMqgmJwuuSzNtAlVR82028273;     ONjxXqmmeMqgmJwuuSzNtAlVR82028273 = ONjxXqmmeMqgmJwuuSzNtAlVR44308825;     ONjxXqmmeMqgmJwuuSzNtAlVR44308825 = ONjxXqmmeMqgmJwuuSzNtAlVR40325921;     ONjxXqmmeMqgmJwuuSzNtAlVR40325921 = ONjxXqmmeMqgmJwuuSzNtAlVR94263659;     ONjxXqmmeMqgmJwuuSzNtAlVR94263659 = ONjxXqmmeMqgmJwuuSzNtAlVR75029176;     ONjxXqmmeMqgmJwuuSzNtAlVR75029176 = ONjxXqmmeMqgmJwuuSzNtAlVR94911808;     ONjxXqmmeMqgmJwuuSzNtAlVR94911808 = ONjxXqmmeMqgmJwuuSzNtAlVR58665169;     ONjxXqmmeMqgmJwuuSzNtAlVR58665169 = ONjxXqmmeMqgmJwuuSzNtAlVR80947277;     ONjxXqmmeMqgmJwuuSzNtAlVR80947277 = ONjxXqmmeMqgmJwuuSzNtAlVR11033495;     ONjxXqmmeMqgmJwuuSzNtAlVR11033495 = ONjxXqmmeMqgmJwuuSzNtAlVR18781996;     ONjxXqmmeMqgmJwuuSzNtAlVR18781996 = ONjxXqmmeMqgmJwuuSzNtAlVR74452265;     ONjxXqmmeMqgmJwuuSzNtAlVR74452265 = ONjxXqmmeMqgmJwuuSzNtAlVR90927848;     ONjxXqmmeMqgmJwuuSzNtAlVR90927848 = ONjxXqmmeMqgmJwuuSzNtAlVR36523391;     ONjxXqmmeMqgmJwuuSzNtAlVR36523391 = ONjxXqmmeMqgmJwuuSzNtAlVR79673674;     ONjxXqmmeMqgmJwuuSzNtAlVR79673674 = ONjxXqmmeMqgmJwuuSzNtAlVR94991609;     ONjxXqmmeMqgmJwuuSzNtAlVR94991609 = ONjxXqmmeMqgmJwuuSzNtAlVR42474435;     ONjxXqmmeMqgmJwuuSzNtAlVR42474435 = ONjxXqmmeMqgmJwuuSzNtAlVR31958540;     ONjxXqmmeMqgmJwuuSzNtAlVR31958540 = ONjxXqmmeMqgmJwuuSzNtAlVR27324667;     ONjxXqmmeMqgmJwuuSzNtAlVR27324667 = ONjxXqmmeMqgmJwuuSzNtAlVR48384109;     ONjxXqmmeMqgmJwuuSzNtAlVR48384109 = ONjxXqmmeMqgmJwuuSzNtAlVR96569030;     ONjxXqmmeMqgmJwuuSzNtAlVR96569030 = ONjxXqmmeMqgmJwuuSzNtAlVR2783956;     ONjxXqmmeMqgmJwuuSzNtAlVR2783956 = ONjxXqmmeMqgmJwuuSzNtAlVR425639;     ONjxXqmmeMqgmJwuuSzNtAlVR425639 = ONjxXqmmeMqgmJwuuSzNtAlVR30880002;     ONjxXqmmeMqgmJwuuSzNtAlVR30880002 = ONjxXqmmeMqgmJwuuSzNtAlVR62721919;     ONjxXqmmeMqgmJwuuSzNtAlVR62721919 = ONjxXqmmeMqgmJwuuSzNtAlVR503508;     ONjxXqmmeMqgmJwuuSzNtAlVR503508 = ONjxXqmmeMqgmJwuuSzNtAlVR89614342;     ONjxXqmmeMqgmJwuuSzNtAlVR89614342 = ONjxXqmmeMqgmJwuuSzNtAlVR42956860;     ONjxXqmmeMqgmJwuuSzNtAlVR42956860 = ONjxXqmmeMqgmJwuuSzNtAlVR13840436;     ONjxXqmmeMqgmJwuuSzNtAlVR13840436 = ONjxXqmmeMqgmJwuuSzNtAlVR30853987;     ONjxXqmmeMqgmJwuuSzNtAlVR30853987 = ONjxXqmmeMqgmJwuuSzNtAlVR42617270;     ONjxXqmmeMqgmJwuuSzNtAlVR42617270 = ONjxXqmmeMqgmJwuuSzNtAlVR79644422;     ONjxXqmmeMqgmJwuuSzNtAlVR79644422 = ONjxXqmmeMqgmJwuuSzNtAlVR37030943;     ONjxXqmmeMqgmJwuuSzNtAlVR37030943 = ONjxXqmmeMqgmJwuuSzNtAlVR93888114;     ONjxXqmmeMqgmJwuuSzNtAlVR93888114 = ONjxXqmmeMqgmJwuuSzNtAlVR1600689;     ONjxXqmmeMqgmJwuuSzNtAlVR1600689 = ONjxXqmmeMqgmJwuuSzNtAlVR87803051;     ONjxXqmmeMqgmJwuuSzNtAlVR87803051 = ONjxXqmmeMqgmJwuuSzNtAlVR45817320;     ONjxXqmmeMqgmJwuuSzNtAlVR45817320 = ONjxXqmmeMqgmJwuuSzNtAlVR40280186;     ONjxXqmmeMqgmJwuuSzNtAlVR40280186 = ONjxXqmmeMqgmJwuuSzNtAlVR59753126;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void TQWuIFhxTNqZjIrZyCQVRPcAbzeGIVLytHBzdIFKudCKKVsmpmKWBGDEn46221719() {     long WTIabpyBsfcHrvpwFboMSpFGr95212094 = -119919990;    long WTIabpyBsfcHrvpwFboMSpFGr50251977 = -168681523;    long WTIabpyBsfcHrvpwFboMSpFGr80035475 = -921192827;    long WTIabpyBsfcHrvpwFboMSpFGr8971983 = -944365850;    long WTIabpyBsfcHrvpwFboMSpFGr21213226 = -684386975;    long WTIabpyBsfcHrvpwFboMSpFGr49477456 = -243237926;    long WTIabpyBsfcHrvpwFboMSpFGr39899808 = -785479511;    long WTIabpyBsfcHrvpwFboMSpFGr9849309 = -74725470;    long WTIabpyBsfcHrvpwFboMSpFGr87651372 = -738850209;    long WTIabpyBsfcHrvpwFboMSpFGr14259555 = -900217640;    long WTIabpyBsfcHrvpwFboMSpFGr67455356 = -465688756;    long WTIabpyBsfcHrvpwFboMSpFGr54397818 = -238544896;    long WTIabpyBsfcHrvpwFboMSpFGr17989679 = -703978260;    long WTIabpyBsfcHrvpwFboMSpFGr1257659 = -358473542;    long WTIabpyBsfcHrvpwFboMSpFGr82562265 = -727551196;    long WTIabpyBsfcHrvpwFboMSpFGr14911023 = -142965725;    long WTIabpyBsfcHrvpwFboMSpFGr97617046 = -551928889;    long WTIabpyBsfcHrvpwFboMSpFGr96045260 = -821411793;    long WTIabpyBsfcHrvpwFboMSpFGr5221818 = -418934434;    long WTIabpyBsfcHrvpwFboMSpFGr63862726 = -178844005;    long WTIabpyBsfcHrvpwFboMSpFGr76905468 = -903630666;    long WTIabpyBsfcHrvpwFboMSpFGr52926524 = -55274623;    long WTIabpyBsfcHrvpwFboMSpFGr55643134 = -798069004;    long WTIabpyBsfcHrvpwFboMSpFGr16873487 = -939320167;    long WTIabpyBsfcHrvpwFboMSpFGr56636233 = -530913132;    long WTIabpyBsfcHrvpwFboMSpFGr77767478 = -137550612;    long WTIabpyBsfcHrvpwFboMSpFGr80486877 = -53705673;    long WTIabpyBsfcHrvpwFboMSpFGr84761281 = -739258870;    long WTIabpyBsfcHrvpwFboMSpFGr68691436 = -62460252;    long WTIabpyBsfcHrvpwFboMSpFGr9638905 = 32929907;    long WTIabpyBsfcHrvpwFboMSpFGr73631249 = -67830763;    long WTIabpyBsfcHrvpwFboMSpFGr26770719 = -862394554;    long WTIabpyBsfcHrvpwFboMSpFGr71784021 = -606678792;    long WTIabpyBsfcHrvpwFboMSpFGr34474283 = 59442923;    long WTIabpyBsfcHrvpwFboMSpFGr19013440 = -845913225;    long WTIabpyBsfcHrvpwFboMSpFGr17263424 = -525864051;    long WTIabpyBsfcHrvpwFboMSpFGr99834260 = -76945092;    long WTIabpyBsfcHrvpwFboMSpFGr81963019 = -897181470;    long WTIabpyBsfcHrvpwFboMSpFGr7893635 = 58535364;    long WTIabpyBsfcHrvpwFboMSpFGr94490754 = -379690495;    long WTIabpyBsfcHrvpwFboMSpFGr12549267 = -488765122;    long WTIabpyBsfcHrvpwFboMSpFGr16660342 = -474112853;    long WTIabpyBsfcHrvpwFboMSpFGr59214703 = -197123406;    long WTIabpyBsfcHrvpwFboMSpFGr30257484 = -383044006;    long WTIabpyBsfcHrvpwFboMSpFGr80622565 = -690304680;    long WTIabpyBsfcHrvpwFboMSpFGr62621070 = -412254712;    long WTIabpyBsfcHrvpwFboMSpFGr59089803 = -892626747;    long WTIabpyBsfcHrvpwFboMSpFGr89408506 = -215626492;    long WTIabpyBsfcHrvpwFboMSpFGr70356492 = -563522056;    long WTIabpyBsfcHrvpwFboMSpFGr43768855 = -476532330;    long WTIabpyBsfcHrvpwFboMSpFGr84450579 = -816552966;    long WTIabpyBsfcHrvpwFboMSpFGr7653489 = -348061049;    long WTIabpyBsfcHrvpwFboMSpFGr94846929 = -687840981;    long WTIabpyBsfcHrvpwFboMSpFGr75054349 = -835235044;    long WTIabpyBsfcHrvpwFboMSpFGr69316250 = -657052125;    long WTIabpyBsfcHrvpwFboMSpFGr42285571 = 35354632;    long WTIabpyBsfcHrvpwFboMSpFGr94608842 = -370612519;    long WTIabpyBsfcHrvpwFboMSpFGr63161988 = -981872661;    long WTIabpyBsfcHrvpwFboMSpFGr52335749 = -313452718;    long WTIabpyBsfcHrvpwFboMSpFGr43445748 = -446836363;    long WTIabpyBsfcHrvpwFboMSpFGr68990578 = -89532254;    long WTIabpyBsfcHrvpwFboMSpFGr55138527 = 53779359;    long WTIabpyBsfcHrvpwFboMSpFGr41157873 = 87734781;    long WTIabpyBsfcHrvpwFboMSpFGr78012468 = -671780117;    long WTIabpyBsfcHrvpwFboMSpFGr40628306 = -732386877;    long WTIabpyBsfcHrvpwFboMSpFGr40684638 = -603294203;    long WTIabpyBsfcHrvpwFboMSpFGr82613796 = -631866104;    long WTIabpyBsfcHrvpwFboMSpFGr83515395 = -663421183;    long WTIabpyBsfcHrvpwFboMSpFGr82244218 = -512560317;    long WTIabpyBsfcHrvpwFboMSpFGr65298842 = -101687145;    long WTIabpyBsfcHrvpwFboMSpFGr15076762 = 33979366;    long WTIabpyBsfcHrvpwFboMSpFGr15654027 = -654747420;    long WTIabpyBsfcHrvpwFboMSpFGr88151625 = -779947158;    long WTIabpyBsfcHrvpwFboMSpFGr10731063 = 60756061;    long WTIabpyBsfcHrvpwFboMSpFGr51313459 = -690078883;    long WTIabpyBsfcHrvpwFboMSpFGr60245127 = -329517814;    long WTIabpyBsfcHrvpwFboMSpFGr93711821 = -858151218;    long WTIabpyBsfcHrvpwFboMSpFGr25385651 = -315024999;    long WTIabpyBsfcHrvpwFboMSpFGr36250921 = -149015487;    long WTIabpyBsfcHrvpwFboMSpFGr94015162 = -18658421;    long WTIabpyBsfcHrvpwFboMSpFGr18677675 = -244923866;    long WTIabpyBsfcHrvpwFboMSpFGr91078371 = -838079181;    long WTIabpyBsfcHrvpwFboMSpFGr14404790 = -75736815;    long WTIabpyBsfcHrvpwFboMSpFGr24922581 = -585927922;    long WTIabpyBsfcHrvpwFboMSpFGr25188326 = -150517128;    long WTIabpyBsfcHrvpwFboMSpFGr65977761 = -719769714;    long WTIabpyBsfcHrvpwFboMSpFGr31923789 = -74553573;    long WTIabpyBsfcHrvpwFboMSpFGr96729671 = -771443748;    long WTIabpyBsfcHrvpwFboMSpFGr65158032 = -283504953;    long WTIabpyBsfcHrvpwFboMSpFGr76727869 = -781267858;    long WTIabpyBsfcHrvpwFboMSpFGr22654581 = -55251533;    long WTIabpyBsfcHrvpwFboMSpFGr36672272 = -95072432;    long WTIabpyBsfcHrvpwFboMSpFGr29627270 = -483728753;    long WTIabpyBsfcHrvpwFboMSpFGr64447886 = -494628273;    long WTIabpyBsfcHrvpwFboMSpFGr25500177 = -190158242;    long WTIabpyBsfcHrvpwFboMSpFGr57410740 = -442544481;    long WTIabpyBsfcHrvpwFboMSpFGr75502469 = -461847634;    long WTIabpyBsfcHrvpwFboMSpFGr81202235 = -525343290;    long WTIabpyBsfcHrvpwFboMSpFGr89629177 = -650657130;    long WTIabpyBsfcHrvpwFboMSpFGr39937928 = -119919990;     WTIabpyBsfcHrvpwFboMSpFGr95212094 = WTIabpyBsfcHrvpwFboMSpFGr50251977;     WTIabpyBsfcHrvpwFboMSpFGr50251977 = WTIabpyBsfcHrvpwFboMSpFGr80035475;     WTIabpyBsfcHrvpwFboMSpFGr80035475 = WTIabpyBsfcHrvpwFboMSpFGr8971983;     WTIabpyBsfcHrvpwFboMSpFGr8971983 = WTIabpyBsfcHrvpwFboMSpFGr21213226;     WTIabpyBsfcHrvpwFboMSpFGr21213226 = WTIabpyBsfcHrvpwFboMSpFGr49477456;     WTIabpyBsfcHrvpwFboMSpFGr49477456 = WTIabpyBsfcHrvpwFboMSpFGr39899808;     WTIabpyBsfcHrvpwFboMSpFGr39899808 = WTIabpyBsfcHrvpwFboMSpFGr9849309;     WTIabpyBsfcHrvpwFboMSpFGr9849309 = WTIabpyBsfcHrvpwFboMSpFGr87651372;     WTIabpyBsfcHrvpwFboMSpFGr87651372 = WTIabpyBsfcHrvpwFboMSpFGr14259555;     WTIabpyBsfcHrvpwFboMSpFGr14259555 = WTIabpyBsfcHrvpwFboMSpFGr67455356;     WTIabpyBsfcHrvpwFboMSpFGr67455356 = WTIabpyBsfcHrvpwFboMSpFGr54397818;     WTIabpyBsfcHrvpwFboMSpFGr54397818 = WTIabpyBsfcHrvpwFboMSpFGr17989679;     WTIabpyBsfcHrvpwFboMSpFGr17989679 = WTIabpyBsfcHrvpwFboMSpFGr1257659;     WTIabpyBsfcHrvpwFboMSpFGr1257659 = WTIabpyBsfcHrvpwFboMSpFGr82562265;     WTIabpyBsfcHrvpwFboMSpFGr82562265 = WTIabpyBsfcHrvpwFboMSpFGr14911023;     WTIabpyBsfcHrvpwFboMSpFGr14911023 = WTIabpyBsfcHrvpwFboMSpFGr97617046;     WTIabpyBsfcHrvpwFboMSpFGr97617046 = WTIabpyBsfcHrvpwFboMSpFGr96045260;     WTIabpyBsfcHrvpwFboMSpFGr96045260 = WTIabpyBsfcHrvpwFboMSpFGr5221818;     WTIabpyBsfcHrvpwFboMSpFGr5221818 = WTIabpyBsfcHrvpwFboMSpFGr63862726;     WTIabpyBsfcHrvpwFboMSpFGr63862726 = WTIabpyBsfcHrvpwFboMSpFGr76905468;     WTIabpyBsfcHrvpwFboMSpFGr76905468 = WTIabpyBsfcHrvpwFboMSpFGr52926524;     WTIabpyBsfcHrvpwFboMSpFGr52926524 = WTIabpyBsfcHrvpwFboMSpFGr55643134;     WTIabpyBsfcHrvpwFboMSpFGr55643134 = WTIabpyBsfcHrvpwFboMSpFGr16873487;     WTIabpyBsfcHrvpwFboMSpFGr16873487 = WTIabpyBsfcHrvpwFboMSpFGr56636233;     WTIabpyBsfcHrvpwFboMSpFGr56636233 = WTIabpyBsfcHrvpwFboMSpFGr77767478;     WTIabpyBsfcHrvpwFboMSpFGr77767478 = WTIabpyBsfcHrvpwFboMSpFGr80486877;     WTIabpyBsfcHrvpwFboMSpFGr80486877 = WTIabpyBsfcHrvpwFboMSpFGr84761281;     WTIabpyBsfcHrvpwFboMSpFGr84761281 = WTIabpyBsfcHrvpwFboMSpFGr68691436;     WTIabpyBsfcHrvpwFboMSpFGr68691436 = WTIabpyBsfcHrvpwFboMSpFGr9638905;     WTIabpyBsfcHrvpwFboMSpFGr9638905 = WTIabpyBsfcHrvpwFboMSpFGr73631249;     WTIabpyBsfcHrvpwFboMSpFGr73631249 = WTIabpyBsfcHrvpwFboMSpFGr26770719;     WTIabpyBsfcHrvpwFboMSpFGr26770719 = WTIabpyBsfcHrvpwFboMSpFGr71784021;     WTIabpyBsfcHrvpwFboMSpFGr71784021 = WTIabpyBsfcHrvpwFboMSpFGr34474283;     WTIabpyBsfcHrvpwFboMSpFGr34474283 = WTIabpyBsfcHrvpwFboMSpFGr19013440;     WTIabpyBsfcHrvpwFboMSpFGr19013440 = WTIabpyBsfcHrvpwFboMSpFGr17263424;     WTIabpyBsfcHrvpwFboMSpFGr17263424 = WTIabpyBsfcHrvpwFboMSpFGr99834260;     WTIabpyBsfcHrvpwFboMSpFGr99834260 = WTIabpyBsfcHrvpwFboMSpFGr81963019;     WTIabpyBsfcHrvpwFboMSpFGr81963019 = WTIabpyBsfcHrvpwFboMSpFGr7893635;     WTIabpyBsfcHrvpwFboMSpFGr7893635 = WTIabpyBsfcHrvpwFboMSpFGr94490754;     WTIabpyBsfcHrvpwFboMSpFGr94490754 = WTIabpyBsfcHrvpwFboMSpFGr12549267;     WTIabpyBsfcHrvpwFboMSpFGr12549267 = WTIabpyBsfcHrvpwFboMSpFGr16660342;     WTIabpyBsfcHrvpwFboMSpFGr16660342 = WTIabpyBsfcHrvpwFboMSpFGr59214703;     WTIabpyBsfcHrvpwFboMSpFGr59214703 = WTIabpyBsfcHrvpwFboMSpFGr30257484;     WTIabpyBsfcHrvpwFboMSpFGr30257484 = WTIabpyBsfcHrvpwFboMSpFGr80622565;     WTIabpyBsfcHrvpwFboMSpFGr80622565 = WTIabpyBsfcHrvpwFboMSpFGr62621070;     WTIabpyBsfcHrvpwFboMSpFGr62621070 = WTIabpyBsfcHrvpwFboMSpFGr59089803;     WTIabpyBsfcHrvpwFboMSpFGr59089803 = WTIabpyBsfcHrvpwFboMSpFGr89408506;     WTIabpyBsfcHrvpwFboMSpFGr89408506 = WTIabpyBsfcHrvpwFboMSpFGr70356492;     WTIabpyBsfcHrvpwFboMSpFGr70356492 = WTIabpyBsfcHrvpwFboMSpFGr43768855;     WTIabpyBsfcHrvpwFboMSpFGr43768855 = WTIabpyBsfcHrvpwFboMSpFGr84450579;     WTIabpyBsfcHrvpwFboMSpFGr84450579 = WTIabpyBsfcHrvpwFboMSpFGr7653489;     WTIabpyBsfcHrvpwFboMSpFGr7653489 = WTIabpyBsfcHrvpwFboMSpFGr94846929;     WTIabpyBsfcHrvpwFboMSpFGr94846929 = WTIabpyBsfcHrvpwFboMSpFGr75054349;     WTIabpyBsfcHrvpwFboMSpFGr75054349 = WTIabpyBsfcHrvpwFboMSpFGr69316250;     WTIabpyBsfcHrvpwFboMSpFGr69316250 = WTIabpyBsfcHrvpwFboMSpFGr42285571;     WTIabpyBsfcHrvpwFboMSpFGr42285571 = WTIabpyBsfcHrvpwFboMSpFGr94608842;     WTIabpyBsfcHrvpwFboMSpFGr94608842 = WTIabpyBsfcHrvpwFboMSpFGr63161988;     WTIabpyBsfcHrvpwFboMSpFGr63161988 = WTIabpyBsfcHrvpwFboMSpFGr52335749;     WTIabpyBsfcHrvpwFboMSpFGr52335749 = WTIabpyBsfcHrvpwFboMSpFGr43445748;     WTIabpyBsfcHrvpwFboMSpFGr43445748 = WTIabpyBsfcHrvpwFboMSpFGr68990578;     WTIabpyBsfcHrvpwFboMSpFGr68990578 = WTIabpyBsfcHrvpwFboMSpFGr55138527;     WTIabpyBsfcHrvpwFboMSpFGr55138527 = WTIabpyBsfcHrvpwFboMSpFGr41157873;     WTIabpyBsfcHrvpwFboMSpFGr41157873 = WTIabpyBsfcHrvpwFboMSpFGr78012468;     WTIabpyBsfcHrvpwFboMSpFGr78012468 = WTIabpyBsfcHrvpwFboMSpFGr40628306;     WTIabpyBsfcHrvpwFboMSpFGr40628306 = WTIabpyBsfcHrvpwFboMSpFGr40684638;     WTIabpyBsfcHrvpwFboMSpFGr40684638 = WTIabpyBsfcHrvpwFboMSpFGr82613796;     WTIabpyBsfcHrvpwFboMSpFGr82613796 = WTIabpyBsfcHrvpwFboMSpFGr83515395;     WTIabpyBsfcHrvpwFboMSpFGr83515395 = WTIabpyBsfcHrvpwFboMSpFGr82244218;     WTIabpyBsfcHrvpwFboMSpFGr82244218 = WTIabpyBsfcHrvpwFboMSpFGr65298842;     WTIabpyBsfcHrvpwFboMSpFGr65298842 = WTIabpyBsfcHrvpwFboMSpFGr15076762;     WTIabpyBsfcHrvpwFboMSpFGr15076762 = WTIabpyBsfcHrvpwFboMSpFGr15654027;     WTIabpyBsfcHrvpwFboMSpFGr15654027 = WTIabpyBsfcHrvpwFboMSpFGr88151625;     WTIabpyBsfcHrvpwFboMSpFGr88151625 = WTIabpyBsfcHrvpwFboMSpFGr10731063;     WTIabpyBsfcHrvpwFboMSpFGr10731063 = WTIabpyBsfcHrvpwFboMSpFGr51313459;     WTIabpyBsfcHrvpwFboMSpFGr51313459 = WTIabpyBsfcHrvpwFboMSpFGr60245127;     WTIabpyBsfcHrvpwFboMSpFGr60245127 = WTIabpyBsfcHrvpwFboMSpFGr93711821;     WTIabpyBsfcHrvpwFboMSpFGr93711821 = WTIabpyBsfcHrvpwFboMSpFGr25385651;     WTIabpyBsfcHrvpwFboMSpFGr25385651 = WTIabpyBsfcHrvpwFboMSpFGr36250921;     WTIabpyBsfcHrvpwFboMSpFGr36250921 = WTIabpyBsfcHrvpwFboMSpFGr94015162;     WTIabpyBsfcHrvpwFboMSpFGr94015162 = WTIabpyBsfcHrvpwFboMSpFGr18677675;     WTIabpyBsfcHrvpwFboMSpFGr18677675 = WTIabpyBsfcHrvpwFboMSpFGr91078371;     WTIabpyBsfcHrvpwFboMSpFGr91078371 = WTIabpyBsfcHrvpwFboMSpFGr14404790;     WTIabpyBsfcHrvpwFboMSpFGr14404790 = WTIabpyBsfcHrvpwFboMSpFGr24922581;     WTIabpyBsfcHrvpwFboMSpFGr24922581 = WTIabpyBsfcHrvpwFboMSpFGr25188326;     WTIabpyBsfcHrvpwFboMSpFGr25188326 = WTIabpyBsfcHrvpwFboMSpFGr65977761;     WTIabpyBsfcHrvpwFboMSpFGr65977761 = WTIabpyBsfcHrvpwFboMSpFGr31923789;     WTIabpyBsfcHrvpwFboMSpFGr31923789 = WTIabpyBsfcHrvpwFboMSpFGr96729671;     WTIabpyBsfcHrvpwFboMSpFGr96729671 = WTIabpyBsfcHrvpwFboMSpFGr65158032;     WTIabpyBsfcHrvpwFboMSpFGr65158032 = WTIabpyBsfcHrvpwFboMSpFGr76727869;     WTIabpyBsfcHrvpwFboMSpFGr76727869 = WTIabpyBsfcHrvpwFboMSpFGr22654581;     WTIabpyBsfcHrvpwFboMSpFGr22654581 = WTIabpyBsfcHrvpwFboMSpFGr36672272;     WTIabpyBsfcHrvpwFboMSpFGr36672272 = WTIabpyBsfcHrvpwFboMSpFGr29627270;     WTIabpyBsfcHrvpwFboMSpFGr29627270 = WTIabpyBsfcHrvpwFboMSpFGr64447886;     WTIabpyBsfcHrvpwFboMSpFGr64447886 = WTIabpyBsfcHrvpwFboMSpFGr25500177;     WTIabpyBsfcHrvpwFboMSpFGr25500177 = WTIabpyBsfcHrvpwFboMSpFGr57410740;     WTIabpyBsfcHrvpwFboMSpFGr57410740 = WTIabpyBsfcHrvpwFboMSpFGr75502469;     WTIabpyBsfcHrvpwFboMSpFGr75502469 = WTIabpyBsfcHrvpwFboMSpFGr81202235;     WTIabpyBsfcHrvpwFboMSpFGr81202235 = WTIabpyBsfcHrvpwFboMSpFGr89629177;     WTIabpyBsfcHrvpwFboMSpFGr89629177 = WTIabpyBsfcHrvpwFboMSpFGr39937928;     WTIabpyBsfcHrvpwFboMSpFGr39937928 = WTIabpyBsfcHrvpwFboMSpFGr95212094;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void rNqGHbFjCwkoleNMUEMqqnkAQHWOTUPqYGRBTqEFjhKdMkAkDfaSnaYEd61270787() {     long pqzFqPhgtQeNLtdzHHIdGngHl1329202 = -231821879;    long pqzFqPhgtQeNLtdzHHIdGngHl93625256 = -978281303;    long pqzFqPhgtQeNLtdzHHIdGngHl96077658 = 27974252;    long pqzFqPhgtQeNLtdzHHIdGngHl36046763 = -35114480;    long pqzFqPhgtQeNLtdzHHIdGngHl90108714 = -105036846;    long pqzFqPhgtQeNLtdzHHIdGngHl40894658 = -507734161;    long pqzFqPhgtQeNLtdzHHIdGngHl388774 = -924444488;    long pqzFqPhgtQeNLtdzHHIdGngHl59609200 = -361599383;    long pqzFqPhgtQeNLtdzHHIdGngHl52293868 = -506882875;    long pqzFqPhgtQeNLtdzHHIdGngHl55489214 = -129193117;    long pqzFqPhgtQeNLtdzHHIdGngHl27565646 = -343126343;    long pqzFqPhgtQeNLtdzHHIdGngHl86220860 = -682951098;    long pqzFqPhgtQeNLtdzHHIdGngHl4198797 = -43869349;    long pqzFqPhgtQeNLtdzHHIdGngHl84401334 = -890712110;    long pqzFqPhgtQeNLtdzHHIdGngHl78304692 = -318013362;    long pqzFqPhgtQeNLtdzHHIdGngHl56416416 = -115965268;    long pqzFqPhgtQeNLtdzHHIdGngHl91453049 = -68474002;    long pqzFqPhgtQeNLtdzHHIdGngHl93098413 = -486934436;    long pqzFqPhgtQeNLtdzHHIdGngHl67051659 = -824703531;    long pqzFqPhgtQeNLtdzHHIdGngHl44412891 = -535746924;    long pqzFqPhgtQeNLtdzHHIdGngHl65458661 = -759118122;    long pqzFqPhgtQeNLtdzHHIdGngHl39447548 = 36795660;    long pqzFqPhgtQeNLtdzHHIdGngHl91233926 = -544586491;    long pqzFqPhgtQeNLtdzHHIdGngHl865861 = -61625155;    long pqzFqPhgtQeNLtdzHHIdGngHl335883 = -904109165;    long pqzFqPhgtQeNLtdzHHIdGngHl2489154 = -16205935;    long pqzFqPhgtQeNLtdzHHIdGngHl78946655 = 45632124;    long pqzFqPhgtQeNLtdzHHIdGngHl97868406 = -805187824;    long pqzFqPhgtQeNLtdzHHIdGngHl34823692 = -284842956;    long pqzFqPhgtQeNLtdzHHIdGngHl78254541 = -884540960;    long pqzFqPhgtQeNLtdzHHIdGngHl65873798 = 18848299;    long pqzFqPhgtQeNLtdzHHIdGngHl24381340 = -571841370;    long pqzFqPhgtQeNLtdzHHIdGngHl81494969 = -499292162;    long pqzFqPhgtQeNLtdzHHIdGngHl29304847 = -792098842;    long pqzFqPhgtQeNLtdzHHIdGngHl80488092 = -384646330;    long pqzFqPhgtQeNLtdzHHIdGngHl85989336 = -739890159;    long pqzFqPhgtQeNLtdzHHIdGngHl81096195 = -30580961;    long pqzFqPhgtQeNLtdzHHIdGngHl16053232 = -668687480;    long pqzFqPhgtQeNLtdzHHIdGngHl81503888 = 64611867;    long pqzFqPhgtQeNLtdzHHIdGngHl81992692 = -853129718;    long pqzFqPhgtQeNLtdzHHIdGngHl18218491 = -554039016;    long pqzFqPhgtQeNLtdzHHIdGngHl48810798 = -744255131;    long pqzFqPhgtQeNLtdzHHIdGngHl37281681 = -277927990;    long pqzFqPhgtQeNLtdzHHIdGngHl17665224 = -402386944;    long pqzFqPhgtQeNLtdzHHIdGngHl92575030 = -352202835;    long pqzFqPhgtQeNLtdzHHIdGngHl74560265 = -397470828;    long pqzFqPhgtQeNLtdzHHIdGngHl76868377 = 88597715;    long pqzFqPhgtQeNLtdzHHIdGngHl97365447 = -225522024;    long pqzFqPhgtQeNLtdzHHIdGngHl80032221 = -649259044;    long pqzFqPhgtQeNLtdzHHIdGngHl56680508 = -563543138;    long pqzFqPhgtQeNLtdzHHIdGngHl20151258 = -658846637;    long pqzFqPhgtQeNLtdzHHIdGngHl18463208 = -148787370;    long pqzFqPhgtQeNLtdzHHIdGngHl43095387 = -479630569;    long pqzFqPhgtQeNLtdzHHIdGngHl71023230 = -55705189;    long pqzFqPhgtQeNLtdzHHIdGngHl95812125 = -257583907;    long pqzFqPhgtQeNLtdzHHIdGngHl61881654 = -168617540;    long pqzFqPhgtQeNLtdzHHIdGngHl2391330 = -333694813;    long pqzFqPhgtQeNLtdzHHIdGngHl95211798 = -910400594;    long pqzFqPhgtQeNLtdzHHIdGngHl35710880 = -131005315;    long pqzFqPhgtQeNLtdzHHIdGngHl87619561 = 11169089;    long pqzFqPhgtQeNLtdzHHIdGngHl61948002 = -453366286;    long pqzFqPhgtQeNLtdzHHIdGngHl2520368 = -19256665;    long pqzFqPhgtQeNLtdzHHIdGngHl24785508 = 23243572;    long pqzFqPhgtQeNLtdzHHIdGngHl74039326 = -622341915;    long pqzFqPhgtQeNLtdzHHIdGngHl89615415 = -48041416;    long pqzFqPhgtQeNLtdzHHIdGngHl3184306 = -771284974;    long pqzFqPhgtQeNLtdzHHIdGngHl4725891 = -83658936;    long pqzFqPhgtQeNLtdzHHIdGngHl74893950 = -251770507;    long pqzFqPhgtQeNLtdzHHIdGngHl3913243 = -406065780;    long pqzFqPhgtQeNLtdzHHIdGngHl92315355 = -578123204;    long pqzFqPhgtQeNLtdzHHIdGngHl75320221 = 14615692;    long pqzFqPhgtQeNLtdzHHIdGngHl75399817 = -399786523;    long pqzFqPhgtQeNLtdzHHIdGngHl11594525 = -451546304;    long pqzFqPhgtQeNLtdzHHIdGngHl85058967 = -971573814;    long pqzFqPhgtQeNLtdzHHIdGngHl26194400 = -981707909;    long pqzFqPhgtQeNLtdzHHIdGngHl16647863 = 85137009;    long pqzFqPhgtQeNLtdzHHIdGngHl2165867 = -685276350;    long pqzFqPhgtQeNLtdzHHIdGngHl73568702 = -42199547;    long pqzFqPhgtQeNLtdzHHIdGngHl8290830 = -709422320;    long pqzFqPhgtQeNLtdzHHIdGngHl25775618 = -406638337;    long pqzFqPhgtQeNLtdzHHIdGngHl25620776 = -4803651;    long pqzFqPhgtQeNLtdzHHIdGngHl81581208 = -728845852;    long pqzFqPhgtQeNLtdzHHIdGngHl17836186 = -55928781;    long pqzFqPhgtQeNLtdzHHIdGngHl78143184 = -721299819;    long pqzFqPhgtQeNLtdzHHIdGngHl58103284 = -125694324;    long pqzFqPhgtQeNLtdzHHIdGngHl47410591 = -832364332;    long pqzFqPhgtQeNLtdzHHIdGngHl81285953 = 7789199;    long pqzFqPhgtQeNLtdzHHIdGngHl10471740 = -343586973;    long pqzFqPhgtQeNLtdzHHIdGngHl33492722 = -434514936;    long pqzFqPhgtQeNLtdzHHIdGngHl18606439 = -116028791;    long pqzFqPhgtQeNLtdzHHIdGngHl83598006 = -306195346;    long pqzFqPhgtQeNLtdzHHIdGngHl85884397 = -120180368;    long pqzFqPhgtQeNLtdzHHIdGngHl80342351 = -437682165;    long pqzFqPhgtQeNLtdzHHIdGngHl93884326 = -946557222;    long pqzFqPhgtQeNLtdzHHIdGngHl20044691 = -299763432;    long pqzFqPhgtQeNLtdzHHIdGngHl15698124 = -434782352;    long pqzFqPhgtQeNLtdzHHIdGngHl24025291 = -667498704;    long pqzFqPhgtQeNLtdzHHIdGngHl63242355 = -655586075;    long pqzFqPhgtQeNLtdzHHIdGngHl28049808 = -254345528;    long pqzFqPhgtQeNLtdzHHIdGngHl89390724 = -231821879;     pqzFqPhgtQeNLtdzHHIdGngHl1329202 = pqzFqPhgtQeNLtdzHHIdGngHl93625256;     pqzFqPhgtQeNLtdzHHIdGngHl93625256 = pqzFqPhgtQeNLtdzHHIdGngHl96077658;     pqzFqPhgtQeNLtdzHHIdGngHl96077658 = pqzFqPhgtQeNLtdzHHIdGngHl36046763;     pqzFqPhgtQeNLtdzHHIdGngHl36046763 = pqzFqPhgtQeNLtdzHHIdGngHl90108714;     pqzFqPhgtQeNLtdzHHIdGngHl90108714 = pqzFqPhgtQeNLtdzHHIdGngHl40894658;     pqzFqPhgtQeNLtdzHHIdGngHl40894658 = pqzFqPhgtQeNLtdzHHIdGngHl388774;     pqzFqPhgtQeNLtdzHHIdGngHl388774 = pqzFqPhgtQeNLtdzHHIdGngHl59609200;     pqzFqPhgtQeNLtdzHHIdGngHl59609200 = pqzFqPhgtQeNLtdzHHIdGngHl52293868;     pqzFqPhgtQeNLtdzHHIdGngHl52293868 = pqzFqPhgtQeNLtdzHHIdGngHl55489214;     pqzFqPhgtQeNLtdzHHIdGngHl55489214 = pqzFqPhgtQeNLtdzHHIdGngHl27565646;     pqzFqPhgtQeNLtdzHHIdGngHl27565646 = pqzFqPhgtQeNLtdzHHIdGngHl86220860;     pqzFqPhgtQeNLtdzHHIdGngHl86220860 = pqzFqPhgtQeNLtdzHHIdGngHl4198797;     pqzFqPhgtQeNLtdzHHIdGngHl4198797 = pqzFqPhgtQeNLtdzHHIdGngHl84401334;     pqzFqPhgtQeNLtdzHHIdGngHl84401334 = pqzFqPhgtQeNLtdzHHIdGngHl78304692;     pqzFqPhgtQeNLtdzHHIdGngHl78304692 = pqzFqPhgtQeNLtdzHHIdGngHl56416416;     pqzFqPhgtQeNLtdzHHIdGngHl56416416 = pqzFqPhgtQeNLtdzHHIdGngHl91453049;     pqzFqPhgtQeNLtdzHHIdGngHl91453049 = pqzFqPhgtQeNLtdzHHIdGngHl93098413;     pqzFqPhgtQeNLtdzHHIdGngHl93098413 = pqzFqPhgtQeNLtdzHHIdGngHl67051659;     pqzFqPhgtQeNLtdzHHIdGngHl67051659 = pqzFqPhgtQeNLtdzHHIdGngHl44412891;     pqzFqPhgtQeNLtdzHHIdGngHl44412891 = pqzFqPhgtQeNLtdzHHIdGngHl65458661;     pqzFqPhgtQeNLtdzHHIdGngHl65458661 = pqzFqPhgtQeNLtdzHHIdGngHl39447548;     pqzFqPhgtQeNLtdzHHIdGngHl39447548 = pqzFqPhgtQeNLtdzHHIdGngHl91233926;     pqzFqPhgtQeNLtdzHHIdGngHl91233926 = pqzFqPhgtQeNLtdzHHIdGngHl865861;     pqzFqPhgtQeNLtdzHHIdGngHl865861 = pqzFqPhgtQeNLtdzHHIdGngHl335883;     pqzFqPhgtQeNLtdzHHIdGngHl335883 = pqzFqPhgtQeNLtdzHHIdGngHl2489154;     pqzFqPhgtQeNLtdzHHIdGngHl2489154 = pqzFqPhgtQeNLtdzHHIdGngHl78946655;     pqzFqPhgtQeNLtdzHHIdGngHl78946655 = pqzFqPhgtQeNLtdzHHIdGngHl97868406;     pqzFqPhgtQeNLtdzHHIdGngHl97868406 = pqzFqPhgtQeNLtdzHHIdGngHl34823692;     pqzFqPhgtQeNLtdzHHIdGngHl34823692 = pqzFqPhgtQeNLtdzHHIdGngHl78254541;     pqzFqPhgtQeNLtdzHHIdGngHl78254541 = pqzFqPhgtQeNLtdzHHIdGngHl65873798;     pqzFqPhgtQeNLtdzHHIdGngHl65873798 = pqzFqPhgtQeNLtdzHHIdGngHl24381340;     pqzFqPhgtQeNLtdzHHIdGngHl24381340 = pqzFqPhgtQeNLtdzHHIdGngHl81494969;     pqzFqPhgtQeNLtdzHHIdGngHl81494969 = pqzFqPhgtQeNLtdzHHIdGngHl29304847;     pqzFqPhgtQeNLtdzHHIdGngHl29304847 = pqzFqPhgtQeNLtdzHHIdGngHl80488092;     pqzFqPhgtQeNLtdzHHIdGngHl80488092 = pqzFqPhgtQeNLtdzHHIdGngHl85989336;     pqzFqPhgtQeNLtdzHHIdGngHl85989336 = pqzFqPhgtQeNLtdzHHIdGngHl81096195;     pqzFqPhgtQeNLtdzHHIdGngHl81096195 = pqzFqPhgtQeNLtdzHHIdGngHl16053232;     pqzFqPhgtQeNLtdzHHIdGngHl16053232 = pqzFqPhgtQeNLtdzHHIdGngHl81503888;     pqzFqPhgtQeNLtdzHHIdGngHl81503888 = pqzFqPhgtQeNLtdzHHIdGngHl81992692;     pqzFqPhgtQeNLtdzHHIdGngHl81992692 = pqzFqPhgtQeNLtdzHHIdGngHl18218491;     pqzFqPhgtQeNLtdzHHIdGngHl18218491 = pqzFqPhgtQeNLtdzHHIdGngHl48810798;     pqzFqPhgtQeNLtdzHHIdGngHl48810798 = pqzFqPhgtQeNLtdzHHIdGngHl37281681;     pqzFqPhgtQeNLtdzHHIdGngHl37281681 = pqzFqPhgtQeNLtdzHHIdGngHl17665224;     pqzFqPhgtQeNLtdzHHIdGngHl17665224 = pqzFqPhgtQeNLtdzHHIdGngHl92575030;     pqzFqPhgtQeNLtdzHHIdGngHl92575030 = pqzFqPhgtQeNLtdzHHIdGngHl74560265;     pqzFqPhgtQeNLtdzHHIdGngHl74560265 = pqzFqPhgtQeNLtdzHHIdGngHl76868377;     pqzFqPhgtQeNLtdzHHIdGngHl76868377 = pqzFqPhgtQeNLtdzHHIdGngHl97365447;     pqzFqPhgtQeNLtdzHHIdGngHl97365447 = pqzFqPhgtQeNLtdzHHIdGngHl80032221;     pqzFqPhgtQeNLtdzHHIdGngHl80032221 = pqzFqPhgtQeNLtdzHHIdGngHl56680508;     pqzFqPhgtQeNLtdzHHIdGngHl56680508 = pqzFqPhgtQeNLtdzHHIdGngHl20151258;     pqzFqPhgtQeNLtdzHHIdGngHl20151258 = pqzFqPhgtQeNLtdzHHIdGngHl18463208;     pqzFqPhgtQeNLtdzHHIdGngHl18463208 = pqzFqPhgtQeNLtdzHHIdGngHl43095387;     pqzFqPhgtQeNLtdzHHIdGngHl43095387 = pqzFqPhgtQeNLtdzHHIdGngHl71023230;     pqzFqPhgtQeNLtdzHHIdGngHl71023230 = pqzFqPhgtQeNLtdzHHIdGngHl95812125;     pqzFqPhgtQeNLtdzHHIdGngHl95812125 = pqzFqPhgtQeNLtdzHHIdGngHl61881654;     pqzFqPhgtQeNLtdzHHIdGngHl61881654 = pqzFqPhgtQeNLtdzHHIdGngHl2391330;     pqzFqPhgtQeNLtdzHHIdGngHl2391330 = pqzFqPhgtQeNLtdzHHIdGngHl95211798;     pqzFqPhgtQeNLtdzHHIdGngHl95211798 = pqzFqPhgtQeNLtdzHHIdGngHl35710880;     pqzFqPhgtQeNLtdzHHIdGngHl35710880 = pqzFqPhgtQeNLtdzHHIdGngHl87619561;     pqzFqPhgtQeNLtdzHHIdGngHl87619561 = pqzFqPhgtQeNLtdzHHIdGngHl61948002;     pqzFqPhgtQeNLtdzHHIdGngHl61948002 = pqzFqPhgtQeNLtdzHHIdGngHl2520368;     pqzFqPhgtQeNLtdzHHIdGngHl2520368 = pqzFqPhgtQeNLtdzHHIdGngHl24785508;     pqzFqPhgtQeNLtdzHHIdGngHl24785508 = pqzFqPhgtQeNLtdzHHIdGngHl74039326;     pqzFqPhgtQeNLtdzHHIdGngHl74039326 = pqzFqPhgtQeNLtdzHHIdGngHl89615415;     pqzFqPhgtQeNLtdzHHIdGngHl89615415 = pqzFqPhgtQeNLtdzHHIdGngHl3184306;     pqzFqPhgtQeNLtdzHHIdGngHl3184306 = pqzFqPhgtQeNLtdzHHIdGngHl4725891;     pqzFqPhgtQeNLtdzHHIdGngHl4725891 = pqzFqPhgtQeNLtdzHHIdGngHl74893950;     pqzFqPhgtQeNLtdzHHIdGngHl74893950 = pqzFqPhgtQeNLtdzHHIdGngHl3913243;     pqzFqPhgtQeNLtdzHHIdGngHl3913243 = pqzFqPhgtQeNLtdzHHIdGngHl92315355;     pqzFqPhgtQeNLtdzHHIdGngHl92315355 = pqzFqPhgtQeNLtdzHHIdGngHl75320221;     pqzFqPhgtQeNLtdzHHIdGngHl75320221 = pqzFqPhgtQeNLtdzHHIdGngHl75399817;     pqzFqPhgtQeNLtdzHHIdGngHl75399817 = pqzFqPhgtQeNLtdzHHIdGngHl11594525;     pqzFqPhgtQeNLtdzHHIdGngHl11594525 = pqzFqPhgtQeNLtdzHHIdGngHl85058967;     pqzFqPhgtQeNLtdzHHIdGngHl85058967 = pqzFqPhgtQeNLtdzHHIdGngHl26194400;     pqzFqPhgtQeNLtdzHHIdGngHl26194400 = pqzFqPhgtQeNLtdzHHIdGngHl16647863;     pqzFqPhgtQeNLtdzHHIdGngHl16647863 = pqzFqPhgtQeNLtdzHHIdGngHl2165867;     pqzFqPhgtQeNLtdzHHIdGngHl2165867 = pqzFqPhgtQeNLtdzHHIdGngHl73568702;     pqzFqPhgtQeNLtdzHHIdGngHl73568702 = pqzFqPhgtQeNLtdzHHIdGngHl8290830;     pqzFqPhgtQeNLtdzHHIdGngHl8290830 = pqzFqPhgtQeNLtdzHHIdGngHl25775618;     pqzFqPhgtQeNLtdzHHIdGngHl25775618 = pqzFqPhgtQeNLtdzHHIdGngHl25620776;     pqzFqPhgtQeNLtdzHHIdGngHl25620776 = pqzFqPhgtQeNLtdzHHIdGngHl81581208;     pqzFqPhgtQeNLtdzHHIdGngHl81581208 = pqzFqPhgtQeNLtdzHHIdGngHl17836186;     pqzFqPhgtQeNLtdzHHIdGngHl17836186 = pqzFqPhgtQeNLtdzHHIdGngHl78143184;     pqzFqPhgtQeNLtdzHHIdGngHl78143184 = pqzFqPhgtQeNLtdzHHIdGngHl58103284;     pqzFqPhgtQeNLtdzHHIdGngHl58103284 = pqzFqPhgtQeNLtdzHHIdGngHl47410591;     pqzFqPhgtQeNLtdzHHIdGngHl47410591 = pqzFqPhgtQeNLtdzHHIdGngHl81285953;     pqzFqPhgtQeNLtdzHHIdGngHl81285953 = pqzFqPhgtQeNLtdzHHIdGngHl10471740;     pqzFqPhgtQeNLtdzHHIdGngHl10471740 = pqzFqPhgtQeNLtdzHHIdGngHl33492722;     pqzFqPhgtQeNLtdzHHIdGngHl33492722 = pqzFqPhgtQeNLtdzHHIdGngHl18606439;     pqzFqPhgtQeNLtdzHHIdGngHl18606439 = pqzFqPhgtQeNLtdzHHIdGngHl83598006;     pqzFqPhgtQeNLtdzHHIdGngHl83598006 = pqzFqPhgtQeNLtdzHHIdGngHl85884397;     pqzFqPhgtQeNLtdzHHIdGngHl85884397 = pqzFqPhgtQeNLtdzHHIdGngHl80342351;     pqzFqPhgtQeNLtdzHHIdGngHl80342351 = pqzFqPhgtQeNLtdzHHIdGngHl93884326;     pqzFqPhgtQeNLtdzHHIdGngHl93884326 = pqzFqPhgtQeNLtdzHHIdGngHl20044691;     pqzFqPhgtQeNLtdzHHIdGngHl20044691 = pqzFqPhgtQeNLtdzHHIdGngHl15698124;     pqzFqPhgtQeNLtdzHHIdGngHl15698124 = pqzFqPhgtQeNLtdzHHIdGngHl24025291;     pqzFqPhgtQeNLtdzHHIdGngHl24025291 = pqzFqPhgtQeNLtdzHHIdGngHl63242355;     pqzFqPhgtQeNLtdzHHIdGngHl63242355 = pqzFqPhgtQeNLtdzHHIdGngHl28049808;     pqzFqPhgtQeNLtdzHHIdGngHl28049808 = pqzFqPhgtQeNLtdzHHIdGngHl89390724;     pqzFqPhgtQeNLtdzHHIdGngHl89390724 = pqzFqPhgtQeNLtdzHHIdGngHl1329202;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void JLqMGadfVxufvUymIEhYeFVVsyujHUYzZPDmzLAvEEfcTdPFmXfjnRDEq28562386() {     long VTHgtYBYvGfRLmwDmTZasBPjo36788170 = -698098779;    long VTHgtYBYvGfRLmwDmTZasBPjo6897335 = -858832910;    long VTHgtYBYvGfRLmwDmTZasBPjo33464136 = -737692823;    long VTHgtYBYvGfRLmwDmTZasBPjo8270118 = -956265551;    long VTHgtYBYvGfRLmwDmTZasBPjo46393984 = -210635691;    long VTHgtYBYvGfRLmwDmTZasBPjo77117530 = -770082057;    long VTHgtYBYvGfRLmwDmTZasBPjo11046180 = -769170222;    long VTHgtYBYvGfRLmwDmTZasBPjo21740761 = -5833524;    long VTHgtYBYvGfRLmwDmTZasBPjo53811473 = -995214282;    long VTHgtYBYvGfRLmwDmTZasBPjo70391926 = -893880115;    long VTHgtYBYvGfRLmwDmTZasBPjo65747381 = -145134072;    long VTHgtYBYvGfRLmwDmTZasBPjo86789008 = -547071869;    long VTHgtYBYvGfRLmwDmTZasBPjo42433442 = -595881854;    long VTHgtYBYvGfRLmwDmTZasBPjo37542198 = -867075519;    long VTHgtYBYvGfRLmwDmTZasBPjo36499209 = -821438377;    long VTHgtYBYvGfRLmwDmTZasBPjo39957717 = -851776875;    long VTHgtYBYvGfRLmwDmTZasBPjo47288985 = -595448555;    long VTHgtYBYvGfRLmwDmTZasBPjo92858604 = -560362505;    long VTHgtYBYvGfRLmwDmTZasBPjo67601989 = -41266952;    long VTHgtYBYvGfRLmwDmTZasBPjo38250110 = -962307990;    long VTHgtYBYvGfRLmwDmTZasBPjo78545524 = -416392811;    long VTHgtYBYvGfRLmwDmTZasBPjo42869072 = -49840634;    long VTHgtYBYvGfRLmwDmTZasBPjo61759306 = -182218675;    long VTHgtYBYvGfRLmwDmTZasBPjo94658805 = -572449759;    long VTHgtYBYvGfRLmwDmTZasBPjo8353834 = -928094364;    long VTHgtYBYvGfRLmwDmTZasBPjo13187325 = -804782742;    long VTHgtYBYvGfRLmwDmTZasBPjo39367230 = -860652017;    long VTHgtYBYvGfRLmwDmTZasBPjo38596832 = -974959998;    long VTHgtYBYvGfRLmwDmTZasBPjo81491906 = -858937759;    long VTHgtYBYvGfRLmwDmTZasBPjo83787952 = -919048131;    long VTHgtYBYvGfRLmwDmTZasBPjo84457030 = -533132188;    long VTHgtYBYvGfRLmwDmTZasBPjo62204358 = -344812784;    long VTHgtYBYvGfRLmwDmTZasBPjo93712980 = -646888140;    long VTHgtYBYvGfRLmwDmTZasBPjo59053273 = -856792656;    long VTHgtYBYvGfRLmwDmTZasBPjo46296546 = -335746581;    long VTHgtYBYvGfRLmwDmTZasBPjo37550181 = -954455465;    long VTHgtYBYvGfRLmwDmTZasBPjo30508012 = -995277001;    long VTHgtYBYvGfRLmwDmTZasBPjo67268635 = -651343061;    long VTHgtYBYvGfRLmwDmTZasBPjo11894450 = -686264409;    long VTHgtYBYvGfRLmwDmTZasBPjo46264225 = -318392264;    long VTHgtYBYvGfRLmwDmTZasBPjo51670099 = -323237930;    long VTHgtYBYvGfRLmwDmTZasBPjo38175925 = -338800422;    long VTHgtYBYvGfRLmwDmTZasBPjo26665060 = -931108776;    long VTHgtYBYvGfRLmwDmTZasBPjo57796562 = 93280646;    long VTHgtYBYvGfRLmwDmTZasBPjo92591489 = -178713996;    long VTHgtYBYvGfRLmwDmTZasBPjo20521594 = -436394460;    long VTHgtYBYvGfRLmwDmTZasBPjo96213540 = -395388645;    long VTHgtYBYvGfRLmwDmTZasBPjo15091760 = -392048618;    long VTHgtYBYvGfRLmwDmTZasBPjo2924888 = -312995924;    long VTHgtYBYvGfRLmwDmTZasBPjo81210097 = 45430046;    long VTHgtYBYvGfRLmwDmTZasBPjo921982 = -533123194;    long VTHgtYBYvGfRLmwDmTZasBPjo1948681 = -362439716;    long VTHgtYBYvGfRLmwDmTZasBPjo11716536 = -235676123;    long VTHgtYBYvGfRLmwDmTZasBPjo87015076 = -247213689;    long VTHgtYBYvGfRLmwDmTZasBPjo50016862 = -604074053;    long VTHgtYBYvGfRLmwDmTZasBPjo93919097 = -548258146;    long VTHgtYBYvGfRLmwDmTZasBPjo45138029 = -576614235;    long VTHgtYBYvGfRLmwDmTZasBPjo38805330 = -65243065;    long VTHgtYBYvGfRLmwDmTZasBPjo99916283 = 71828812;    long VTHgtYBYvGfRLmwDmTZasBPjo33206659 = -405852949;    long VTHgtYBYvGfRLmwDmTZasBPjo37750300 = -909430041;    long VTHgtYBYvGfRLmwDmTZasBPjo72449348 = -794210224;    long VTHgtYBYvGfRLmwDmTZasBPjo40248854 = -146895765;    long VTHgtYBYvGfRLmwDmTZasBPjo70023521 = 23833849;    long VTHgtYBYvGfRLmwDmTZasBPjo85934896 = -260747927;    long VTHgtYBYvGfRLmwDmTZasBPjo3543023 = -800321289;    long VTHgtYBYvGfRLmwDmTZasBPjo93076028 = -900183730;    long VTHgtYBYvGfRLmwDmTZasBPjo83380168 = -739089198;    long VTHgtYBYvGfRLmwDmTZasBPjo91245652 = -431328939;    long VTHgtYBYvGfRLmwDmTZasBPjo98949028 = -866982913;    long VTHgtYBYvGfRLmwDmTZasBPjo9449706 = -856499875;    long VTHgtYBYvGfRLmwDmTZasBPjo80020350 = -944105494;    long VTHgtYBYvGfRLmwDmTZasBPjo80964154 = -874098096;    long VTHgtYBYvGfRLmwDmTZasBPjo21337765 = -722874689;    long VTHgtYBYvGfRLmwDmTZasBPjo86580011 = -539070060;    long VTHgtYBYvGfRLmwDmTZasBPjo40369599 = 22407611;    long VTHgtYBYvGfRLmwDmTZasBPjo16204013 = -118731858;    long VTHgtYBYvGfRLmwDmTZasBPjo3962744 = -175499321;    long VTHgtYBYvGfRLmwDmTZasBPjo2067317 = -293735763;    long VTHgtYBYvGfRLmwDmTZasBPjo87832240 = -391699904;    long VTHgtYBYvGfRLmwDmTZasBPjo16973785 = -309394097;    long VTHgtYBYvGfRLmwDmTZasBPjo24275471 = -368603399;    long VTHgtYBYvGfRLmwDmTZasBPjo35671945 = -561964075;    long VTHgtYBYvGfRLmwDmTZasBPjo281810 = -804367805;    long VTHgtYBYvGfRLmwDmTZasBPjo82865971 = -285924937;    long VTHgtYBYvGfRLmwDmTZasBPjo82508350 = -70692473;    long VTHgtYBYvGfRLmwDmTZasBPjo50487823 = -9136661;    long VTHgtYBYvGfRLmwDmTZasBPjo6697904 = -299674451;    long VTHgtYBYvGfRLmwDmTZasBPjo9036412 = -152718603;    long VTHgtYBYvGfRLmwDmTZasBPjo52377448 = -787488436;    long VTHgtYBYvGfRLmwDmTZasBPjo92412152 = -277841230;    long VTHgtYBYvGfRLmwDmTZasBPjo91702682 = -830033937;    long VTHgtYBYvGfRLmwDmTZasBPjo67352351 = -623171873;    long VTHgtYBYvGfRLmwDmTZasBPjo78687791 = -180411460;    long VTHgtYBYvGfRLmwDmTZasBPjo8513925 = -408962224;    long VTHgtYBYvGfRLmwDmTZasBPjo79220750 = -529027706;    long VTHgtYBYvGfRLmwDmTZasBPjo97927070 = -91904657;    long VTHgtYBYvGfRLmwDmTZasBPjo56641539 = -854942625;    long VTHgtYBYvGfRLmwDmTZasBPjo71861665 = -645971427;    long VTHgtYBYvGfRLmwDmTZasBPjo89048467 = -698098779;     VTHgtYBYvGfRLmwDmTZasBPjo36788170 = VTHgtYBYvGfRLmwDmTZasBPjo6897335;     VTHgtYBYvGfRLmwDmTZasBPjo6897335 = VTHgtYBYvGfRLmwDmTZasBPjo33464136;     VTHgtYBYvGfRLmwDmTZasBPjo33464136 = VTHgtYBYvGfRLmwDmTZasBPjo8270118;     VTHgtYBYvGfRLmwDmTZasBPjo8270118 = VTHgtYBYvGfRLmwDmTZasBPjo46393984;     VTHgtYBYvGfRLmwDmTZasBPjo46393984 = VTHgtYBYvGfRLmwDmTZasBPjo77117530;     VTHgtYBYvGfRLmwDmTZasBPjo77117530 = VTHgtYBYvGfRLmwDmTZasBPjo11046180;     VTHgtYBYvGfRLmwDmTZasBPjo11046180 = VTHgtYBYvGfRLmwDmTZasBPjo21740761;     VTHgtYBYvGfRLmwDmTZasBPjo21740761 = VTHgtYBYvGfRLmwDmTZasBPjo53811473;     VTHgtYBYvGfRLmwDmTZasBPjo53811473 = VTHgtYBYvGfRLmwDmTZasBPjo70391926;     VTHgtYBYvGfRLmwDmTZasBPjo70391926 = VTHgtYBYvGfRLmwDmTZasBPjo65747381;     VTHgtYBYvGfRLmwDmTZasBPjo65747381 = VTHgtYBYvGfRLmwDmTZasBPjo86789008;     VTHgtYBYvGfRLmwDmTZasBPjo86789008 = VTHgtYBYvGfRLmwDmTZasBPjo42433442;     VTHgtYBYvGfRLmwDmTZasBPjo42433442 = VTHgtYBYvGfRLmwDmTZasBPjo37542198;     VTHgtYBYvGfRLmwDmTZasBPjo37542198 = VTHgtYBYvGfRLmwDmTZasBPjo36499209;     VTHgtYBYvGfRLmwDmTZasBPjo36499209 = VTHgtYBYvGfRLmwDmTZasBPjo39957717;     VTHgtYBYvGfRLmwDmTZasBPjo39957717 = VTHgtYBYvGfRLmwDmTZasBPjo47288985;     VTHgtYBYvGfRLmwDmTZasBPjo47288985 = VTHgtYBYvGfRLmwDmTZasBPjo92858604;     VTHgtYBYvGfRLmwDmTZasBPjo92858604 = VTHgtYBYvGfRLmwDmTZasBPjo67601989;     VTHgtYBYvGfRLmwDmTZasBPjo67601989 = VTHgtYBYvGfRLmwDmTZasBPjo38250110;     VTHgtYBYvGfRLmwDmTZasBPjo38250110 = VTHgtYBYvGfRLmwDmTZasBPjo78545524;     VTHgtYBYvGfRLmwDmTZasBPjo78545524 = VTHgtYBYvGfRLmwDmTZasBPjo42869072;     VTHgtYBYvGfRLmwDmTZasBPjo42869072 = VTHgtYBYvGfRLmwDmTZasBPjo61759306;     VTHgtYBYvGfRLmwDmTZasBPjo61759306 = VTHgtYBYvGfRLmwDmTZasBPjo94658805;     VTHgtYBYvGfRLmwDmTZasBPjo94658805 = VTHgtYBYvGfRLmwDmTZasBPjo8353834;     VTHgtYBYvGfRLmwDmTZasBPjo8353834 = VTHgtYBYvGfRLmwDmTZasBPjo13187325;     VTHgtYBYvGfRLmwDmTZasBPjo13187325 = VTHgtYBYvGfRLmwDmTZasBPjo39367230;     VTHgtYBYvGfRLmwDmTZasBPjo39367230 = VTHgtYBYvGfRLmwDmTZasBPjo38596832;     VTHgtYBYvGfRLmwDmTZasBPjo38596832 = VTHgtYBYvGfRLmwDmTZasBPjo81491906;     VTHgtYBYvGfRLmwDmTZasBPjo81491906 = VTHgtYBYvGfRLmwDmTZasBPjo83787952;     VTHgtYBYvGfRLmwDmTZasBPjo83787952 = VTHgtYBYvGfRLmwDmTZasBPjo84457030;     VTHgtYBYvGfRLmwDmTZasBPjo84457030 = VTHgtYBYvGfRLmwDmTZasBPjo62204358;     VTHgtYBYvGfRLmwDmTZasBPjo62204358 = VTHgtYBYvGfRLmwDmTZasBPjo93712980;     VTHgtYBYvGfRLmwDmTZasBPjo93712980 = VTHgtYBYvGfRLmwDmTZasBPjo59053273;     VTHgtYBYvGfRLmwDmTZasBPjo59053273 = VTHgtYBYvGfRLmwDmTZasBPjo46296546;     VTHgtYBYvGfRLmwDmTZasBPjo46296546 = VTHgtYBYvGfRLmwDmTZasBPjo37550181;     VTHgtYBYvGfRLmwDmTZasBPjo37550181 = VTHgtYBYvGfRLmwDmTZasBPjo30508012;     VTHgtYBYvGfRLmwDmTZasBPjo30508012 = VTHgtYBYvGfRLmwDmTZasBPjo67268635;     VTHgtYBYvGfRLmwDmTZasBPjo67268635 = VTHgtYBYvGfRLmwDmTZasBPjo11894450;     VTHgtYBYvGfRLmwDmTZasBPjo11894450 = VTHgtYBYvGfRLmwDmTZasBPjo46264225;     VTHgtYBYvGfRLmwDmTZasBPjo46264225 = VTHgtYBYvGfRLmwDmTZasBPjo51670099;     VTHgtYBYvGfRLmwDmTZasBPjo51670099 = VTHgtYBYvGfRLmwDmTZasBPjo38175925;     VTHgtYBYvGfRLmwDmTZasBPjo38175925 = VTHgtYBYvGfRLmwDmTZasBPjo26665060;     VTHgtYBYvGfRLmwDmTZasBPjo26665060 = VTHgtYBYvGfRLmwDmTZasBPjo57796562;     VTHgtYBYvGfRLmwDmTZasBPjo57796562 = VTHgtYBYvGfRLmwDmTZasBPjo92591489;     VTHgtYBYvGfRLmwDmTZasBPjo92591489 = VTHgtYBYvGfRLmwDmTZasBPjo20521594;     VTHgtYBYvGfRLmwDmTZasBPjo20521594 = VTHgtYBYvGfRLmwDmTZasBPjo96213540;     VTHgtYBYvGfRLmwDmTZasBPjo96213540 = VTHgtYBYvGfRLmwDmTZasBPjo15091760;     VTHgtYBYvGfRLmwDmTZasBPjo15091760 = VTHgtYBYvGfRLmwDmTZasBPjo2924888;     VTHgtYBYvGfRLmwDmTZasBPjo2924888 = VTHgtYBYvGfRLmwDmTZasBPjo81210097;     VTHgtYBYvGfRLmwDmTZasBPjo81210097 = VTHgtYBYvGfRLmwDmTZasBPjo921982;     VTHgtYBYvGfRLmwDmTZasBPjo921982 = VTHgtYBYvGfRLmwDmTZasBPjo1948681;     VTHgtYBYvGfRLmwDmTZasBPjo1948681 = VTHgtYBYvGfRLmwDmTZasBPjo11716536;     VTHgtYBYvGfRLmwDmTZasBPjo11716536 = VTHgtYBYvGfRLmwDmTZasBPjo87015076;     VTHgtYBYvGfRLmwDmTZasBPjo87015076 = VTHgtYBYvGfRLmwDmTZasBPjo50016862;     VTHgtYBYvGfRLmwDmTZasBPjo50016862 = VTHgtYBYvGfRLmwDmTZasBPjo93919097;     VTHgtYBYvGfRLmwDmTZasBPjo93919097 = VTHgtYBYvGfRLmwDmTZasBPjo45138029;     VTHgtYBYvGfRLmwDmTZasBPjo45138029 = VTHgtYBYvGfRLmwDmTZasBPjo38805330;     VTHgtYBYvGfRLmwDmTZasBPjo38805330 = VTHgtYBYvGfRLmwDmTZasBPjo99916283;     VTHgtYBYvGfRLmwDmTZasBPjo99916283 = VTHgtYBYvGfRLmwDmTZasBPjo33206659;     VTHgtYBYvGfRLmwDmTZasBPjo33206659 = VTHgtYBYvGfRLmwDmTZasBPjo37750300;     VTHgtYBYvGfRLmwDmTZasBPjo37750300 = VTHgtYBYvGfRLmwDmTZasBPjo72449348;     VTHgtYBYvGfRLmwDmTZasBPjo72449348 = VTHgtYBYvGfRLmwDmTZasBPjo40248854;     VTHgtYBYvGfRLmwDmTZasBPjo40248854 = VTHgtYBYvGfRLmwDmTZasBPjo70023521;     VTHgtYBYvGfRLmwDmTZasBPjo70023521 = VTHgtYBYvGfRLmwDmTZasBPjo85934896;     VTHgtYBYvGfRLmwDmTZasBPjo85934896 = VTHgtYBYvGfRLmwDmTZasBPjo3543023;     VTHgtYBYvGfRLmwDmTZasBPjo3543023 = VTHgtYBYvGfRLmwDmTZasBPjo93076028;     VTHgtYBYvGfRLmwDmTZasBPjo93076028 = VTHgtYBYvGfRLmwDmTZasBPjo83380168;     VTHgtYBYvGfRLmwDmTZasBPjo83380168 = VTHgtYBYvGfRLmwDmTZasBPjo91245652;     VTHgtYBYvGfRLmwDmTZasBPjo91245652 = VTHgtYBYvGfRLmwDmTZasBPjo98949028;     VTHgtYBYvGfRLmwDmTZasBPjo98949028 = VTHgtYBYvGfRLmwDmTZasBPjo9449706;     VTHgtYBYvGfRLmwDmTZasBPjo9449706 = VTHgtYBYvGfRLmwDmTZasBPjo80020350;     VTHgtYBYvGfRLmwDmTZasBPjo80020350 = VTHgtYBYvGfRLmwDmTZasBPjo80964154;     VTHgtYBYvGfRLmwDmTZasBPjo80964154 = VTHgtYBYvGfRLmwDmTZasBPjo21337765;     VTHgtYBYvGfRLmwDmTZasBPjo21337765 = VTHgtYBYvGfRLmwDmTZasBPjo86580011;     VTHgtYBYvGfRLmwDmTZasBPjo86580011 = VTHgtYBYvGfRLmwDmTZasBPjo40369599;     VTHgtYBYvGfRLmwDmTZasBPjo40369599 = VTHgtYBYvGfRLmwDmTZasBPjo16204013;     VTHgtYBYvGfRLmwDmTZasBPjo16204013 = VTHgtYBYvGfRLmwDmTZasBPjo3962744;     VTHgtYBYvGfRLmwDmTZasBPjo3962744 = VTHgtYBYvGfRLmwDmTZasBPjo2067317;     VTHgtYBYvGfRLmwDmTZasBPjo2067317 = VTHgtYBYvGfRLmwDmTZasBPjo87832240;     VTHgtYBYvGfRLmwDmTZasBPjo87832240 = VTHgtYBYvGfRLmwDmTZasBPjo16973785;     VTHgtYBYvGfRLmwDmTZasBPjo16973785 = VTHgtYBYvGfRLmwDmTZasBPjo24275471;     VTHgtYBYvGfRLmwDmTZasBPjo24275471 = VTHgtYBYvGfRLmwDmTZasBPjo35671945;     VTHgtYBYvGfRLmwDmTZasBPjo35671945 = VTHgtYBYvGfRLmwDmTZasBPjo281810;     VTHgtYBYvGfRLmwDmTZasBPjo281810 = VTHgtYBYvGfRLmwDmTZasBPjo82865971;     VTHgtYBYvGfRLmwDmTZasBPjo82865971 = VTHgtYBYvGfRLmwDmTZasBPjo82508350;     VTHgtYBYvGfRLmwDmTZasBPjo82508350 = VTHgtYBYvGfRLmwDmTZasBPjo50487823;     VTHgtYBYvGfRLmwDmTZasBPjo50487823 = VTHgtYBYvGfRLmwDmTZasBPjo6697904;     VTHgtYBYvGfRLmwDmTZasBPjo6697904 = VTHgtYBYvGfRLmwDmTZasBPjo9036412;     VTHgtYBYvGfRLmwDmTZasBPjo9036412 = VTHgtYBYvGfRLmwDmTZasBPjo52377448;     VTHgtYBYvGfRLmwDmTZasBPjo52377448 = VTHgtYBYvGfRLmwDmTZasBPjo92412152;     VTHgtYBYvGfRLmwDmTZasBPjo92412152 = VTHgtYBYvGfRLmwDmTZasBPjo91702682;     VTHgtYBYvGfRLmwDmTZasBPjo91702682 = VTHgtYBYvGfRLmwDmTZasBPjo67352351;     VTHgtYBYvGfRLmwDmTZasBPjo67352351 = VTHgtYBYvGfRLmwDmTZasBPjo78687791;     VTHgtYBYvGfRLmwDmTZasBPjo78687791 = VTHgtYBYvGfRLmwDmTZasBPjo8513925;     VTHgtYBYvGfRLmwDmTZasBPjo8513925 = VTHgtYBYvGfRLmwDmTZasBPjo79220750;     VTHgtYBYvGfRLmwDmTZasBPjo79220750 = VTHgtYBYvGfRLmwDmTZasBPjo97927070;     VTHgtYBYvGfRLmwDmTZasBPjo97927070 = VTHgtYBYvGfRLmwDmTZasBPjo56641539;     VTHgtYBYvGfRLmwDmTZasBPjo56641539 = VTHgtYBYvGfRLmwDmTZasBPjo71861665;     VTHgtYBYvGfRLmwDmTZasBPjo71861665 = VTHgtYBYvGfRLmwDmTZasBPjo89048467;     VTHgtYBYvGfRLmwDmTZasBPjo89048467 = VTHgtYBYvGfRLmwDmTZasBPjo36788170;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void LHDoQDhPxyWpMkLCaTjWvmDicfZnuVmdTFzoXeUtUFAXqAfaULlUyVPYE43611454() {     long UMkduUcMsWGlXfwzpCqmgsbAz42905277 = -810000668;    long UMkduUcMsWGlXfwzpCqmgsbAz50270614 = -568432691;    long UMkduUcMsWGlXfwzpCqmgsbAz49506319 = -888525744;    long UMkduUcMsWGlXfwzpCqmgsbAz35344899 = -47014182;    long UMkduUcMsWGlXfwzpCqmgsbAz15289473 = -731285562;    long UMkduUcMsWGlXfwzpCqmgsbAz68534732 = 65421708;    long UMkduUcMsWGlXfwzpCqmgsbAz71535146 = -908135199;    long UMkduUcMsWGlXfwzpCqmgsbAz71500651 = -292707437;    long UMkduUcMsWGlXfwzpCqmgsbAz18453969 = -763246947;    long UMkduUcMsWGlXfwzpCqmgsbAz11621586 = -122855593;    long UMkduUcMsWGlXfwzpCqmgsbAz25857671 = -22571659;    long UMkduUcMsWGlXfwzpCqmgsbAz18612051 = -991478071;    long UMkduUcMsWGlXfwzpCqmgsbAz28642561 = 64227058;    long UMkduUcMsWGlXfwzpCqmgsbAz20685875 = -299314087;    long UMkduUcMsWGlXfwzpCqmgsbAz32241635 = -411900543;    long UMkduUcMsWGlXfwzpCqmgsbAz81463111 = -824776419;    long UMkduUcMsWGlXfwzpCqmgsbAz41124988 = -111993668;    long UMkduUcMsWGlXfwzpCqmgsbAz89911757 = -225885148;    long UMkduUcMsWGlXfwzpCqmgsbAz29431832 = -447036049;    long UMkduUcMsWGlXfwzpCqmgsbAz18800275 = -219210909;    long UMkduUcMsWGlXfwzpCqmgsbAz67098717 = -271880266;    long UMkduUcMsWGlXfwzpCqmgsbAz29390096 = 42229650;    long UMkduUcMsWGlXfwzpCqmgsbAz97350097 = 71263838;    long UMkduUcMsWGlXfwzpCqmgsbAz78651179 = -794754747;    long UMkduUcMsWGlXfwzpCqmgsbAz52053484 = -201290396;    long UMkduUcMsWGlXfwzpCqmgsbAz37909000 = -683438066;    long UMkduUcMsWGlXfwzpCqmgsbAz37827008 = -761314220;    long UMkduUcMsWGlXfwzpCqmgsbAz51703957 = 59111048;    long UMkduUcMsWGlXfwzpCqmgsbAz47624162 = 18679537;    long UMkduUcMsWGlXfwzpCqmgsbAz52403589 = -736518998;    long UMkduUcMsWGlXfwzpCqmgsbAz76699579 = -446453127;    long UMkduUcMsWGlXfwzpCqmgsbAz59814980 = -54259600;    long UMkduUcMsWGlXfwzpCqmgsbAz3423929 = -539501510;    long UMkduUcMsWGlXfwzpCqmgsbAz53883838 = -608334421;    long UMkduUcMsWGlXfwzpCqmgsbAz7771198 = -974479686;    long UMkduUcMsWGlXfwzpCqmgsbAz6276094 = -68481572;    long UMkduUcMsWGlXfwzpCqmgsbAz11769947 = -948912871;    long UMkduUcMsWGlXfwzpCqmgsbAz1358848 = -422849071;    long UMkduUcMsWGlXfwzpCqmgsbAz85504703 = -680187906;    long UMkduUcMsWGlXfwzpCqmgsbAz33766163 = -791831486;    long UMkduUcMsWGlXfwzpCqmgsbAz57339323 = -388511824;    long UMkduUcMsWGlXfwzpCqmgsbAz70326382 = -608942700;    long UMkduUcMsWGlXfwzpCqmgsbAz4732038 = 88086640;    long UMkduUcMsWGlXfwzpCqmgsbAz45204302 = 73937708;    long UMkduUcMsWGlXfwzpCqmgsbAz4543955 = -940612151;    long UMkduUcMsWGlXfwzpCqmgsbAz32460789 = -421610577;    long UMkduUcMsWGlXfwzpCqmgsbAz13992115 = -514164183;    long UMkduUcMsWGlXfwzpCqmgsbAz23048700 = -401944150;    long UMkduUcMsWGlXfwzpCqmgsbAz12600616 = -398732912;    long UMkduUcMsWGlXfwzpCqmgsbAz94121749 = -41580762;    long UMkduUcMsWGlXfwzpCqmgsbAz36622660 = -375416866;    long UMkduUcMsWGlXfwzpCqmgsbAz12758400 = -163166036;    long UMkduUcMsWGlXfwzpCqmgsbAz59964993 = -27465711;    long UMkduUcMsWGlXfwzpCqmgsbAz82983956 = -567683834;    long UMkduUcMsWGlXfwzpCqmgsbAz76512736 = -204605836;    long UMkduUcMsWGlXfwzpCqmgsbAz13515181 = -752230318;    long UMkduUcMsWGlXfwzpCqmgsbAz52920516 = -539696529;    long UMkduUcMsWGlXfwzpCqmgsbAz70855139 = 6229002;    long UMkduUcMsWGlXfwzpCqmgsbAz83291414 = -845723786;    long UMkduUcMsWGlXfwzpCqmgsbAz77380472 = 52152503;    long UMkduUcMsWGlXfwzpCqmgsbAz30707725 = -173264073;    long UMkduUcMsWGlXfwzpCqmgsbAz19831190 = -867246248;    long UMkduUcMsWGlXfwzpCqmgsbAz23876490 = -211386974;    long UMkduUcMsWGlXfwzpCqmgsbAz66050379 = 73272050;    long UMkduUcMsWGlXfwzpCqmgsbAz34922006 = -676402467;    long UMkduUcMsWGlXfwzpCqmgsbAz66042691 = -968312059;    long UMkduUcMsWGlXfwzpCqmgsbAz15188123 = -351976561;    long UMkduUcMsWGlXfwzpCqmgsbAz74758723 = -327438522;    long UMkduUcMsWGlXfwzpCqmgsbAz12914677 = -324834401;    long UMkduUcMsWGlXfwzpCqmgsbAz25965542 = -243418972;    long UMkduUcMsWGlXfwzpCqmgsbAz69693164 = -875863548;    long UMkduUcMsWGlXfwzpCqmgsbAz39766141 = -689144598;    long UMkduUcMsWGlXfwzpCqmgsbAz4407054 = -545697242;    long UMkduUcMsWGlXfwzpCqmgsbAz95665668 = -655204563;    long UMkduUcMsWGlXfwzpCqmgsbAz61460952 = -830699086;    long UMkduUcMsWGlXfwzpCqmgsbAz96772335 = -662937567;    long UMkduUcMsWGlXfwzpCqmgsbAz24658059 = 54143009;    long UMkduUcMsWGlXfwzpCqmgsbAz52145795 = 97326130;    long UMkduUcMsWGlXfwzpCqmgsbAz74107225 = -854142597;    long UMkduUcMsWGlXfwzpCqmgsbAz19592695 = -779679820;    long UMkduUcMsWGlXfwzpCqmgsbAz23916886 = -69273883;    long UMkduUcMsWGlXfwzpCqmgsbAz14778308 = -259370070;    long UMkduUcMsWGlXfwzpCqmgsbAz39103341 = -542156040;    long UMkduUcMsWGlXfwzpCqmgsbAz53502412 = -939739702;    long UMkduUcMsWGlXfwzpCqmgsbAz15780930 = -261102133;    long UMkduUcMsWGlXfwzpCqmgsbAz63941180 = -183287091;    long UMkduUcMsWGlXfwzpCqmgsbAz99849987 = 73206111;    long UMkduUcMsWGlXfwzpCqmgsbAz20439972 = -971817676;    long UMkduUcMsWGlXfwzpCqmgsbAz77371101 = -303728586;    long UMkduUcMsWGlXfwzpCqmgsbAz94256017 = -122249369;    long UMkduUcMsWGlXfwzpCqmgsbAz53355578 = -528785043;    long UMkduUcMsWGlXfwzpCqmgsbAz40914807 = -855141874;    long UMkduUcMsWGlXfwzpCqmgsbAz18067433 = -577125285;    long UMkduUcMsWGlXfwzpCqmgsbAz8124232 = -632340409;    long UMkduUcMsWGlXfwzpCqmgsbAz3058439 = -518567414;    long UMkduUcMsWGlXfwzpCqmgsbAz37508134 = -521265577;    long UMkduUcMsWGlXfwzpCqmgsbAz46449893 = -297555726;    long UMkduUcMsWGlXfwzpCqmgsbAz38681658 = -985185410;    long UMkduUcMsWGlXfwzpCqmgsbAz10282297 = -249659826;    long UMkduUcMsWGlXfwzpCqmgsbAz38501264 = -810000668;     UMkduUcMsWGlXfwzpCqmgsbAz42905277 = UMkduUcMsWGlXfwzpCqmgsbAz50270614;     UMkduUcMsWGlXfwzpCqmgsbAz50270614 = UMkduUcMsWGlXfwzpCqmgsbAz49506319;     UMkduUcMsWGlXfwzpCqmgsbAz49506319 = UMkduUcMsWGlXfwzpCqmgsbAz35344899;     UMkduUcMsWGlXfwzpCqmgsbAz35344899 = UMkduUcMsWGlXfwzpCqmgsbAz15289473;     UMkduUcMsWGlXfwzpCqmgsbAz15289473 = UMkduUcMsWGlXfwzpCqmgsbAz68534732;     UMkduUcMsWGlXfwzpCqmgsbAz68534732 = UMkduUcMsWGlXfwzpCqmgsbAz71535146;     UMkduUcMsWGlXfwzpCqmgsbAz71535146 = UMkduUcMsWGlXfwzpCqmgsbAz71500651;     UMkduUcMsWGlXfwzpCqmgsbAz71500651 = UMkduUcMsWGlXfwzpCqmgsbAz18453969;     UMkduUcMsWGlXfwzpCqmgsbAz18453969 = UMkduUcMsWGlXfwzpCqmgsbAz11621586;     UMkduUcMsWGlXfwzpCqmgsbAz11621586 = UMkduUcMsWGlXfwzpCqmgsbAz25857671;     UMkduUcMsWGlXfwzpCqmgsbAz25857671 = UMkduUcMsWGlXfwzpCqmgsbAz18612051;     UMkduUcMsWGlXfwzpCqmgsbAz18612051 = UMkduUcMsWGlXfwzpCqmgsbAz28642561;     UMkduUcMsWGlXfwzpCqmgsbAz28642561 = UMkduUcMsWGlXfwzpCqmgsbAz20685875;     UMkduUcMsWGlXfwzpCqmgsbAz20685875 = UMkduUcMsWGlXfwzpCqmgsbAz32241635;     UMkduUcMsWGlXfwzpCqmgsbAz32241635 = UMkduUcMsWGlXfwzpCqmgsbAz81463111;     UMkduUcMsWGlXfwzpCqmgsbAz81463111 = UMkduUcMsWGlXfwzpCqmgsbAz41124988;     UMkduUcMsWGlXfwzpCqmgsbAz41124988 = UMkduUcMsWGlXfwzpCqmgsbAz89911757;     UMkduUcMsWGlXfwzpCqmgsbAz89911757 = UMkduUcMsWGlXfwzpCqmgsbAz29431832;     UMkduUcMsWGlXfwzpCqmgsbAz29431832 = UMkduUcMsWGlXfwzpCqmgsbAz18800275;     UMkduUcMsWGlXfwzpCqmgsbAz18800275 = UMkduUcMsWGlXfwzpCqmgsbAz67098717;     UMkduUcMsWGlXfwzpCqmgsbAz67098717 = UMkduUcMsWGlXfwzpCqmgsbAz29390096;     UMkduUcMsWGlXfwzpCqmgsbAz29390096 = UMkduUcMsWGlXfwzpCqmgsbAz97350097;     UMkduUcMsWGlXfwzpCqmgsbAz97350097 = UMkduUcMsWGlXfwzpCqmgsbAz78651179;     UMkduUcMsWGlXfwzpCqmgsbAz78651179 = UMkduUcMsWGlXfwzpCqmgsbAz52053484;     UMkduUcMsWGlXfwzpCqmgsbAz52053484 = UMkduUcMsWGlXfwzpCqmgsbAz37909000;     UMkduUcMsWGlXfwzpCqmgsbAz37909000 = UMkduUcMsWGlXfwzpCqmgsbAz37827008;     UMkduUcMsWGlXfwzpCqmgsbAz37827008 = UMkduUcMsWGlXfwzpCqmgsbAz51703957;     UMkduUcMsWGlXfwzpCqmgsbAz51703957 = UMkduUcMsWGlXfwzpCqmgsbAz47624162;     UMkduUcMsWGlXfwzpCqmgsbAz47624162 = UMkduUcMsWGlXfwzpCqmgsbAz52403589;     UMkduUcMsWGlXfwzpCqmgsbAz52403589 = UMkduUcMsWGlXfwzpCqmgsbAz76699579;     UMkduUcMsWGlXfwzpCqmgsbAz76699579 = UMkduUcMsWGlXfwzpCqmgsbAz59814980;     UMkduUcMsWGlXfwzpCqmgsbAz59814980 = UMkduUcMsWGlXfwzpCqmgsbAz3423929;     UMkduUcMsWGlXfwzpCqmgsbAz3423929 = UMkduUcMsWGlXfwzpCqmgsbAz53883838;     UMkduUcMsWGlXfwzpCqmgsbAz53883838 = UMkduUcMsWGlXfwzpCqmgsbAz7771198;     UMkduUcMsWGlXfwzpCqmgsbAz7771198 = UMkduUcMsWGlXfwzpCqmgsbAz6276094;     UMkduUcMsWGlXfwzpCqmgsbAz6276094 = UMkduUcMsWGlXfwzpCqmgsbAz11769947;     UMkduUcMsWGlXfwzpCqmgsbAz11769947 = UMkduUcMsWGlXfwzpCqmgsbAz1358848;     UMkduUcMsWGlXfwzpCqmgsbAz1358848 = UMkduUcMsWGlXfwzpCqmgsbAz85504703;     UMkduUcMsWGlXfwzpCqmgsbAz85504703 = UMkduUcMsWGlXfwzpCqmgsbAz33766163;     UMkduUcMsWGlXfwzpCqmgsbAz33766163 = UMkduUcMsWGlXfwzpCqmgsbAz57339323;     UMkduUcMsWGlXfwzpCqmgsbAz57339323 = UMkduUcMsWGlXfwzpCqmgsbAz70326382;     UMkduUcMsWGlXfwzpCqmgsbAz70326382 = UMkduUcMsWGlXfwzpCqmgsbAz4732038;     UMkduUcMsWGlXfwzpCqmgsbAz4732038 = UMkduUcMsWGlXfwzpCqmgsbAz45204302;     UMkduUcMsWGlXfwzpCqmgsbAz45204302 = UMkduUcMsWGlXfwzpCqmgsbAz4543955;     UMkduUcMsWGlXfwzpCqmgsbAz4543955 = UMkduUcMsWGlXfwzpCqmgsbAz32460789;     UMkduUcMsWGlXfwzpCqmgsbAz32460789 = UMkduUcMsWGlXfwzpCqmgsbAz13992115;     UMkduUcMsWGlXfwzpCqmgsbAz13992115 = UMkduUcMsWGlXfwzpCqmgsbAz23048700;     UMkduUcMsWGlXfwzpCqmgsbAz23048700 = UMkduUcMsWGlXfwzpCqmgsbAz12600616;     UMkduUcMsWGlXfwzpCqmgsbAz12600616 = UMkduUcMsWGlXfwzpCqmgsbAz94121749;     UMkduUcMsWGlXfwzpCqmgsbAz94121749 = UMkduUcMsWGlXfwzpCqmgsbAz36622660;     UMkduUcMsWGlXfwzpCqmgsbAz36622660 = UMkduUcMsWGlXfwzpCqmgsbAz12758400;     UMkduUcMsWGlXfwzpCqmgsbAz12758400 = UMkduUcMsWGlXfwzpCqmgsbAz59964993;     UMkduUcMsWGlXfwzpCqmgsbAz59964993 = UMkduUcMsWGlXfwzpCqmgsbAz82983956;     UMkduUcMsWGlXfwzpCqmgsbAz82983956 = UMkduUcMsWGlXfwzpCqmgsbAz76512736;     UMkduUcMsWGlXfwzpCqmgsbAz76512736 = UMkduUcMsWGlXfwzpCqmgsbAz13515181;     UMkduUcMsWGlXfwzpCqmgsbAz13515181 = UMkduUcMsWGlXfwzpCqmgsbAz52920516;     UMkduUcMsWGlXfwzpCqmgsbAz52920516 = UMkduUcMsWGlXfwzpCqmgsbAz70855139;     UMkduUcMsWGlXfwzpCqmgsbAz70855139 = UMkduUcMsWGlXfwzpCqmgsbAz83291414;     UMkduUcMsWGlXfwzpCqmgsbAz83291414 = UMkduUcMsWGlXfwzpCqmgsbAz77380472;     UMkduUcMsWGlXfwzpCqmgsbAz77380472 = UMkduUcMsWGlXfwzpCqmgsbAz30707725;     UMkduUcMsWGlXfwzpCqmgsbAz30707725 = UMkduUcMsWGlXfwzpCqmgsbAz19831190;     UMkduUcMsWGlXfwzpCqmgsbAz19831190 = UMkduUcMsWGlXfwzpCqmgsbAz23876490;     UMkduUcMsWGlXfwzpCqmgsbAz23876490 = UMkduUcMsWGlXfwzpCqmgsbAz66050379;     UMkduUcMsWGlXfwzpCqmgsbAz66050379 = UMkduUcMsWGlXfwzpCqmgsbAz34922006;     UMkduUcMsWGlXfwzpCqmgsbAz34922006 = UMkduUcMsWGlXfwzpCqmgsbAz66042691;     UMkduUcMsWGlXfwzpCqmgsbAz66042691 = UMkduUcMsWGlXfwzpCqmgsbAz15188123;     UMkduUcMsWGlXfwzpCqmgsbAz15188123 = UMkduUcMsWGlXfwzpCqmgsbAz74758723;     UMkduUcMsWGlXfwzpCqmgsbAz74758723 = UMkduUcMsWGlXfwzpCqmgsbAz12914677;     UMkduUcMsWGlXfwzpCqmgsbAz12914677 = UMkduUcMsWGlXfwzpCqmgsbAz25965542;     UMkduUcMsWGlXfwzpCqmgsbAz25965542 = UMkduUcMsWGlXfwzpCqmgsbAz69693164;     UMkduUcMsWGlXfwzpCqmgsbAz69693164 = UMkduUcMsWGlXfwzpCqmgsbAz39766141;     UMkduUcMsWGlXfwzpCqmgsbAz39766141 = UMkduUcMsWGlXfwzpCqmgsbAz4407054;     UMkduUcMsWGlXfwzpCqmgsbAz4407054 = UMkduUcMsWGlXfwzpCqmgsbAz95665668;     UMkduUcMsWGlXfwzpCqmgsbAz95665668 = UMkduUcMsWGlXfwzpCqmgsbAz61460952;     UMkduUcMsWGlXfwzpCqmgsbAz61460952 = UMkduUcMsWGlXfwzpCqmgsbAz96772335;     UMkduUcMsWGlXfwzpCqmgsbAz96772335 = UMkduUcMsWGlXfwzpCqmgsbAz24658059;     UMkduUcMsWGlXfwzpCqmgsbAz24658059 = UMkduUcMsWGlXfwzpCqmgsbAz52145795;     UMkduUcMsWGlXfwzpCqmgsbAz52145795 = UMkduUcMsWGlXfwzpCqmgsbAz74107225;     UMkduUcMsWGlXfwzpCqmgsbAz74107225 = UMkduUcMsWGlXfwzpCqmgsbAz19592695;     UMkduUcMsWGlXfwzpCqmgsbAz19592695 = UMkduUcMsWGlXfwzpCqmgsbAz23916886;     UMkduUcMsWGlXfwzpCqmgsbAz23916886 = UMkduUcMsWGlXfwzpCqmgsbAz14778308;     UMkduUcMsWGlXfwzpCqmgsbAz14778308 = UMkduUcMsWGlXfwzpCqmgsbAz39103341;     UMkduUcMsWGlXfwzpCqmgsbAz39103341 = UMkduUcMsWGlXfwzpCqmgsbAz53502412;     UMkduUcMsWGlXfwzpCqmgsbAz53502412 = UMkduUcMsWGlXfwzpCqmgsbAz15780930;     UMkduUcMsWGlXfwzpCqmgsbAz15780930 = UMkduUcMsWGlXfwzpCqmgsbAz63941180;     UMkduUcMsWGlXfwzpCqmgsbAz63941180 = UMkduUcMsWGlXfwzpCqmgsbAz99849987;     UMkduUcMsWGlXfwzpCqmgsbAz99849987 = UMkduUcMsWGlXfwzpCqmgsbAz20439972;     UMkduUcMsWGlXfwzpCqmgsbAz20439972 = UMkduUcMsWGlXfwzpCqmgsbAz77371101;     UMkduUcMsWGlXfwzpCqmgsbAz77371101 = UMkduUcMsWGlXfwzpCqmgsbAz94256017;     UMkduUcMsWGlXfwzpCqmgsbAz94256017 = UMkduUcMsWGlXfwzpCqmgsbAz53355578;     UMkduUcMsWGlXfwzpCqmgsbAz53355578 = UMkduUcMsWGlXfwzpCqmgsbAz40914807;     UMkduUcMsWGlXfwzpCqmgsbAz40914807 = UMkduUcMsWGlXfwzpCqmgsbAz18067433;     UMkduUcMsWGlXfwzpCqmgsbAz18067433 = UMkduUcMsWGlXfwzpCqmgsbAz8124232;     UMkduUcMsWGlXfwzpCqmgsbAz8124232 = UMkduUcMsWGlXfwzpCqmgsbAz3058439;     UMkduUcMsWGlXfwzpCqmgsbAz3058439 = UMkduUcMsWGlXfwzpCqmgsbAz37508134;     UMkduUcMsWGlXfwzpCqmgsbAz37508134 = UMkduUcMsWGlXfwzpCqmgsbAz46449893;     UMkduUcMsWGlXfwzpCqmgsbAz46449893 = UMkduUcMsWGlXfwzpCqmgsbAz38681658;     UMkduUcMsWGlXfwzpCqmgsbAz38681658 = UMkduUcMsWGlXfwzpCqmgsbAz10282297;     UMkduUcMsWGlXfwzpCqmgsbAz10282297 = UMkduUcMsWGlXfwzpCqmgsbAz38501264;     UMkduUcMsWGlXfwzpCqmgsbAz38501264 = UMkduUcMsWGlXfwzpCqmgsbAz42905277;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void GtDsONxsvBlzSiYgGROeqnmOOTrgwZlGtgabkqYJemgOePYKkHvaGPwSH10903054() {     long pdvWRwVPeGmIwvQsFzEGYkyug78364245 = -176277568;    long pdvWRwVPeGmIwvQsFzEGYkyug63542692 = -448984297;    long pdvWRwVPeGmIwvQsFzEGYkyug86892796 = -554192819;    long pdvWRwVPeGmIwvQsFzEGYkyug7568254 = -968165253;    long pdvWRwVPeGmIwvQsFzEGYkyug71574741 = -836884408;    long pdvWRwVPeGmIwvQsFzEGYkyug4757605 = -196926187;    long pdvWRwVPeGmIwvQsFzEGYkyug82192552 = -752860934;    long pdvWRwVPeGmIwvQsFzEGYkyug33632213 = 63058423;    long pdvWRwVPeGmIwvQsFzEGYkyug19971574 = -151578354;    long pdvWRwVPeGmIwvQsFzEGYkyug26524298 = -887542591;    long pdvWRwVPeGmIwvQsFzEGYkyug64039406 = -924579388;    long pdvWRwVPeGmIwvQsFzEGYkyug19180200 = -855598842;    long pdvWRwVPeGmIwvQsFzEGYkyug66877206 = -487785447;    long pdvWRwVPeGmIwvQsFzEGYkyug73826738 = -275677496;    long pdvWRwVPeGmIwvQsFzEGYkyug90436151 = -915325559;    long pdvWRwVPeGmIwvQsFzEGYkyug65004412 = -460588026;    long pdvWRwVPeGmIwvQsFzEGYkyug96960923 = -638968220;    long pdvWRwVPeGmIwvQsFzEGYkyug89671949 = -299313216;    long pdvWRwVPeGmIwvQsFzEGYkyug29982162 = -763599471;    long pdvWRwVPeGmIwvQsFzEGYkyug12637493 = -645771975;    long pdvWRwVPeGmIwvQsFzEGYkyug80185580 = 70845045;    long pdvWRwVPeGmIwvQsFzEGYkyug32811621 = -44406644;    long pdvWRwVPeGmIwvQsFzEGYkyug67875477 = -666368346;    long pdvWRwVPeGmIwvQsFzEGYkyug72444125 = -205579351;    long pdvWRwVPeGmIwvQsFzEGYkyug60071435 = -225275595;    long pdvWRwVPeGmIwvQsFzEGYkyug48607172 = -372014872;    long pdvWRwVPeGmIwvQsFzEGYkyug98247582 = -567598360;    long pdvWRwVPeGmIwvQsFzEGYkyug92432381 = -110661126;    long pdvWRwVPeGmIwvQsFzEGYkyug94292376 = -555415266;    long pdvWRwVPeGmIwvQsFzEGYkyug57937000 = -771026169;    long pdvWRwVPeGmIwvQsFzEGYkyug95282810 = -998433614;    long pdvWRwVPeGmIwvQsFzEGYkyug97637998 = -927231014;    long pdvWRwVPeGmIwvQsFzEGYkyug15641940 = -687097487;    long pdvWRwVPeGmIwvQsFzEGYkyug83632264 = -673028235;    long pdvWRwVPeGmIwvQsFzEGYkyug73579651 = -925579937;    long pdvWRwVPeGmIwvQsFzEGYkyug57836937 = -283046878;    long pdvWRwVPeGmIwvQsFzEGYkyug61181763 = -813608911;    long pdvWRwVPeGmIwvQsFzEGYkyug52574251 = -405504652;    long pdvWRwVPeGmIwvQsFzEGYkyug15895266 = -331064182;    long pdvWRwVPeGmIwvQsFzEGYkyug98037694 = -257094032;    long pdvWRwVPeGmIwvQsFzEGYkyug90790930 = -157710738;    long pdvWRwVPeGmIwvQsFzEGYkyug59691509 = -203487991;    long pdvWRwVPeGmIwvQsFzEGYkyug94115416 = -565094146;    long pdvWRwVPeGmIwvQsFzEGYkyug85335640 = -530394702;    long pdvWRwVPeGmIwvQsFzEGYkyug4560413 = -767123312;    long pdvWRwVPeGmIwvQsFzEGYkyug78422117 = -460534209;    long pdvWRwVPeGmIwvQsFzEGYkyug33337279 = -998150543;    long pdvWRwVPeGmIwvQsFzEGYkyug40775012 = -568470744;    long pdvWRwVPeGmIwvQsFzEGYkyug35493282 = -62469792;    long pdvWRwVPeGmIwvQsFzEGYkyug18651340 = -532607578;    long pdvWRwVPeGmIwvQsFzEGYkyug17393383 = -249693423;    long pdvWRwVPeGmIwvQsFzEGYkyug96243871 = -376818383;    long pdvWRwVPeGmIwvQsFzEGYkyug28586142 = -883511265;    long pdvWRwVPeGmIwvQsFzEGYkyug98975803 = -759192334;    long pdvWRwVPeGmIwvQsFzEGYkyug30717473 = -551095981;    long pdvWRwVPeGmIwvQsFzEGYkyug45552624 = -31870924;    long pdvWRwVPeGmIwvQsFzEGYkyug95667214 = -782615952;    long pdvWRwVPeGmIwvQsFzEGYkyug14448672 = -248613469;    long pdvWRwVPeGmIwvQsFzEGYkyug47496818 = -642889659;    long pdvWRwVPeGmIwvQsFzEGYkyug22967570 = -364869536;    long pdvWRwVPeGmIwvQsFzEGYkyug6510023 = -629327827;    long pdvWRwVPeGmIwvQsFzEGYkyug89760170 = -542199808;    long pdvWRwVPeGmIwvQsFzEGYkyug39339836 = -381526312;    long pdvWRwVPeGmIwvQsFzEGYkyug62034574 = -380552186;    long pdvWRwVPeGmIwvQsFzEGYkyug31241487 = -889108978;    long pdvWRwVPeGmIwvQsFzEGYkyug66401407 = -997348374;    long pdvWRwVPeGmIwvQsFzEGYkyug3538260 = -68501356;    long pdvWRwVPeGmIwvQsFzEGYkyug83244942 = -814757213;    long pdvWRwVPeGmIwvQsFzEGYkyug247087 = -350097560;    long pdvWRwVPeGmIwvQsFzEGYkyug32599214 = -532278681;    long pdvWRwVPeGmIwvQsFzEGYkyug3822649 = -646979115;    long pdvWRwVPeGmIwvQsFzEGYkyug44386673 = -133463569;    long pdvWRwVPeGmIwvQsFzEGYkyug73776684 = -968249034;    long pdvWRwVPeGmIwvQsFzEGYkyug31944467 = -406505439;    long pdvWRwVPeGmIwvQsFzEGYkyug21846563 = -388061237;    long pdvWRwVPeGmIwvQsFzEGYkyug20494072 = -725666965;    long pdvWRwVPeGmIwvQsFzEGYkyug38696205 = -479312499;    long pdvWRwVPeGmIwvQsFzEGYkyug82539836 = -35973644;    long pdvWRwVPeGmIwvQsFzEGYkyug67883712 = -438456040;    long pdvWRwVPeGmIwvQsFzEGYkyug81649318 = -764741386;    long pdvWRwVPeGmIwvQsFzEGYkyug15269894 = -373864329;    long pdvWRwVPeGmIwvQsFzEGYkyug57472570 = -999127617;    long pdvWRwVPeGmIwvQsFzEGYkyug56939100 = 51808665;    long pdvWRwVPeGmIwvQsFzEGYkyug75641037 = 77192312;    long pdvWRwVPeGmIwvQsFzEGYkyug40543617 = -421332746;    long pdvWRwVPeGmIwvQsFzEGYkyug99038939 = -521615231;    long pdvWRwVPeGmIwvQsFzEGYkyug69051857 = 56280250;    long pdvWRwVPeGmIwvQsFzEGYkyug16666137 = -927905154;    long pdvWRwVPeGmIwvQsFzEGYkyug52914792 = -21932254;    long pdvWRwVPeGmIwvQsFzEGYkyug28027028 = -793709014;    long pdvWRwVPeGmIwvQsFzEGYkyug62169723 = -500430927;    long pdvWRwVPeGmIwvQsFzEGYkyug46733092 = -464995443;    long pdvWRwVPeGmIwvQsFzEGYkyug5077433 = -762614993;    long pdvWRwVPeGmIwvQsFzEGYkyug92927695 = -966194647;    long pdvWRwVPeGmIwvQsFzEGYkyug91527672 = -627766206;    long pdvWRwVPeGmIwvQsFzEGYkyug1030760 = -615510931;    long pdvWRwVPeGmIwvQsFzEGYkyug20351673 = -821961679;    long pdvWRwVPeGmIwvQsFzEGYkyug32080843 = -84541960;    long pdvWRwVPeGmIwvQsFzEGYkyug54094154 = -641285725;    long pdvWRwVPeGmIwvQsFzEGYkyug38159006 = -176277568;     pdvWRwVPeGmIwvQsFzEGYkyug78364245 = pdvWRwVPeGmIwvQsFzEGYkyug63542692;     pdvWRwVPeGmIwvQsFzEGYkyug63542692 = pdvWRwVPeGmIwvQsFzEGYkyug86892796;     pdvWRwVPeGmIwvQsFzEGYkyug86892796 = pdvWRwVPeGmIwvQsFzEGYkyug7568254;     pdvWRwVPeGmIwvQsFzEGYkyug7568254 = pdvWRwVPeGmIwvQsFzEGYkyug71574741;     pdvWRwVPeGmIwvQsFzEGYkyug71574741 = pdvWRwVPeGmIwvQsFzEGYkyug4757605;     pdvWRwVPeGmIwvQsFzEGYkyug4757605 = pdvWRwVPeGmIwvQsFzEGYkyug82192552;     pdvWRwVPeGmIwvQsFzEGYkyug82192552 = pdvWRwVPeGmIwvQsFzEGYkyug33632213;     pdvWRwVPeGmIwvQsFzEGYkyug33632213 = pdvWRwVPeGmIwvQsFzEGYkyug19971574;     pdvWRwVPeGmIwvQsFzEGYkyug19971574 = pdvWRwVPeGmIwvQsFzEGYkyug26524298;     pdvWRwVPeGmIwvQsFzEGYkyug26524298 = pdvWRwVPeGmIwvQsFzEGYkyug64039406;     pdvWRwVPeGmIwvQsFzEGYkyug64039406 = pdvWRwVPeGmIwvQsFzEGYkyug19180200;     pdvWRwVPeGmIwvQsFzEGYkyug19180200 = pdvWRwVPeGmIwvQsFzEGYkyug66877206;     pdvWRwVPeGmIwvQsFzEGYkyug66877206 = pdvWRwVPeGmIwvQsFzEGYkyug73826738;     pdvWRwVPeGmIwvQsFzEGYkyug73826738 = pdvWRwVPeGmIwvQsFzEGYkyug90436151;     pdvWRwVPeGmIwvQsFzEGYkyug90436151 = pdvWRwVPeGmIwvQsFzEGYkyug65004412;     pdvWRwVPeGmIwvQsFzEGYkyug65004412 = pdvWRwVPeGmIwvQsFzEGYkyug96960923;     pdvWRwVPeGmIwvQsFzEGYkyug96960923 = pdvWRwVPeGmIwvQsFzEGYkyug89671949;     pdvWRwVPeGmIwvQsFzEGYkyug89671949 = pdvWRwVPeGmIwvQsFzEGYkyug29982162;     pdvWRwVPeGmIwvQsFzEGYkyug29982162 = pdvWRwVPeGmIwvQsFzEGYkyug12637493;     pdvWRwVPeGmIwvQsFzEGYkyug12637493 = pdvWRwVPeGmIwvQsFzEGYkyug80185580;     pdvWRwVPeGmIwvQsFzEGYkyug80185580 = pdvWRwVPeGmIwvQsFzEGYkyug32811621;     pdvWRwVPeGmIwvQsFzEGYkyug32811621 = pdvWRwVPeGmIwvQsFzEGYkyug67875477;     pdvWRwVPeGmIwvQsFzEGYkyug67875477 = pdvWRwVPeGmIwvQsFzEGYkyug72444125;     pdvWRwVPeGmIwvQsFzEGYkyug72444125 = pdvWRwVPeGmIwvQsFzEGYkyug60071435;     pdvWRwVPeGmIwvQsFzEGYkyug60071435 = pdvWRwVPeGmIwvQsFzEGYkyug48607172;     pdvWRwVPeGmIwvQsFzEGYkyug48607172 = pdvWRwVPeGmIwvQsFzEGYkyug98247582;     pdvWRwVPeGmIwvQsFzEGYkyug98247582 = pdvWRwVPeGmIwvQsFzEGYkyug92432381;     pdvWRwVPeGmIwvQsFzEGYkyug92432381 = pdvWRwVPeGmIwvQsFzEGYkyug94292376;     pdvWRwVPeGmIwvQsFzEGYkyug94292376 = pdvWRwVPeGmIwvQsFzEGYkyug57937000;     pdvWRwVPeGmIwvQsFzEGYkyug57937000 = pdvWRwVPeGmIwvQsFzEGYkyug95282810;     pdvWRwVPeGmIwvQsFzEGYkyug95282810 = pdvWRwVPeGmIwvQsFzEGYkyug97637998;     pdvWRwVPeGmIwvQsFzEGYkyug97637998 = pdvWRwVPeGmIwvQsFzEGYkyug15641940;     pdvWRwVPeGmIwvQsFzEGYkyug15641940 = pdvWRwVPeGmIwvQsFzEGYkyug83632264;     pdvWRwVPeGmIwvQsFzEGYkyug83632264 = pdvWRwVPeGmIwvQsFzEGYkyug73579651;     pdvWRwVPeGmIwvQsFzEGYkyug73579651 = pdvWRwVPeGmIwvQsFzEGYkyug57836937;     pdvWRwVPeGmIwvQsFzEGYkyug57836937 = pdvWRwVPeGmIwvQsFzEGYkyug61181763;     pdvWRwVPeGmIwvQsFzEGYkyug61181763 = pdvWRwVPeGmIwvQsFzEGYkyug52574251;     pdvWRwVPeGmIwvQsFzEGYkyug52574251 = pdvWRwVPeGmIwvQsFzEGYkyug15895266;     pdvWRwVPeGmIwvQsFzEGYkyug15895266 = pdvWRwVPeGmIwvQsFzEGYkyug98037694;     pdvWRwVPeGmIwvQsFzEGYkyug98037694 = pdvWRwVPeGmIwvQsFzEGYkyug90790930;     pdvWRwVPeGmIwvQsFzEGYkyug90790930 = pdvWRwVPeGmIwvQsFzEGYkyug59691509;     pdvWRwVPeGmIwvQsFzEGYkyug59691509 = pdvWRwVPeGmIwvQsFzEGYkyug94115416;     pdvWRwVPeGmIwvQsFzEGYkyug94115416 = pdvWRwVPeGmIwvQsFzEGYkyug85335640;     pdvWRwVPeGmIwvQsFzEGYkyug85335640 = pdvWRwVPeGmIwvQsFzEGYkyug4560413;     pdvWRwVPeGmIwvQsFzEGYkyug4560413 = pdvWRwVPeGmIwvQsFzEGYkyug78422117;     pdvWRwVPeGmIwvQsFzEGYkyug78422117 = pdvWRwVPeGmIwvQsFzEGYkyug33337279;     pdvWRwVPeGmIwvQsFzEGYkyug33337279 = pdvWRwVPeGmIwvQsFzEGYkyug40775012;     pdvWRwVPeGmIwvQsFzEGYkyug40775012 = pdvWRwVPeGmIwvQsFzEGYkyug35493282;     pdvWRwVPeGmIwvQsFzEGYkyug35493282 = pdvWRwVPeGmIwvQsFzEGYkyug18651340;     pdvWRwVPeGmIwvQsFzEGYkyug18651340 = pdvWRwVPeGmIwvQsFzEGYkyug17393383;     pdvWRwVPeGmIwvQsFzEGYkyug17393383 = pdvWRwVPeGmIwvQsFzEGYkyug96243871;     pdvWRwVPeGmIwvQsFzEGYkyug96243871 = pdvWRwVPeGmIwvQsFzEGYkyug28586142;     pdvWRwVPeGmIwvQsFzEGYkyug28586142 = pdvWRwVPeGmIwvQsFzEGYkyug98975803;     pdvWRwVPeGmIwvQsFzEGYkyug98975803 = pdvWRwVPeGmIwvQsFzEGYkyug30717473;     pdvWRwVPeGmIwvQsFzEGYkyug30717473 = pdvWRwVPeGmIwvQsFzEGYkyug45552624;     pdvWRwVPeGmIwvQsFzEGYkyug45552624 = pdvWRwVPeGmIwvQsFzEGYkyug95667214;     pdvWRwVPeGmIwvQsFzEGYkyug95667214 = pdvWRwVPeGmIwvQsFzEGYkyug14448672;     pdvWRwVPeGmIwvQsFzEGYkyug14448672 = pdvWRwVPeGmIwvQsFzEGYkyug47496818;     pdvWRwVPeGmIwvQsFzEGYkyug47496818 = pdvWRwVPeGmIwvQsFzEGYkyug22967570;     pdvWRwVPeGmIwvQsFzEGYkyug22967570 = pdvWRwVPeGmIwvQsFzEGYkyug6510023;     pdvWRwVPeGmIwvQsFzEGYkyug6510023 = pdvWRwVPeGmIwvQsFzEGYkyug89760170;     pdvWRwVPeGmIwvQsFzEGYkyug89760170 = pdvWRwVPeGmIwvQsFzEGYkyug39339836;     pdvWRwVPeGmIwvQsFzEGYkyug39339836 = pdvWRwVPeGmIwvQsFzEGYkyug62034574;     pdvWRwVPeGmIwvQsFzEGYkyug62034574 = pdvWRwVPeGmIwvQsFzEGYkyug31241487;     pdvWRwVPeGmIwvQsFzEGYkyug31241487 = pdvWRwVPeGmIwvQsFzEGYkyug66401407;     pdvWRwVPeGmIwvQsFzEGYkyug66401407 = pdvWRwVPeGmIwvQsFzEGYkyug3538260;     pdvWRwVPeGmIwvQsFzEGYkyug3538260 = pdvWRwVPeGmIwvQsFzEGYkyug83244942;     pdvWRwVPeGmIwvQsFzEGYkyug83244942 = pdvWRwVPeGmIwvQsFzEGYkyug247087;     pdvWRwVPeGmIwvQsFzEGYkyug247087 = pdvWRwVPeGmIwvQsFzEGYkyug32599214;     pdvWRwVPeGmIwvQsFzEGYkyug32599214 = pdvWRwVPeGmIwvQsFzEGYkyug3822649;     pdvWRwVPeGmIwvQsFzEGYkyug3822649 = pdvWRwVPeGmIwvQsFzEGYkyug44386673;     pdvWRwVPeGmIwvQsFzEGYkyug44386673 = pdvWRwVPeGmIwvQsFzEGYkyug73776684;     pdvWRwVPeGmIwvQsFzEGYkyug73776684 = pdvWRwVPeGmIwvQsFzEGYkyug31944467;     pdvWRwVPeGmIwvQsFzEGYkyug31944467 = pdvWRwVPeGmIwvQsFzEGYkyug21846563;     pdvWRwVPeGmIwvQsFzEGYkyug21846563 = pdvWRwVPeGmIwvQsFzEGYkyug20494072;     pdvWRwVPeGmIwvQsFzEGYkyug20494072 = pdvWRwVPeGmIwvQsFzEGYkyug38696205;     pdvWRwVPeGmIwvQsFzEGYkyug38696205 = pdvWRwVPeGmIwvQsFzEGYkyug82539836;     pdvWRwVPeGmIwvQsFzEGYkyug82539836 = pdvWRwVPeGmIwvQsFzEGYkyug67883712;     pdvWRwVPeGmIwvQsFzEGYkyug67883712 = pdvWRwVPeGmIwvQsFzEGYkyug81649318;     pdvWRwVPeGmIwvQsFzEGYkyug81649318 = pdvWRwVPeGmIwvQsFzEGYkyug15269894;     pdvWRwVPeGmIwvQsFzEGYkyug15269894 = pdvWRwVPeGmIwvQsFzEGYkyug57472570;     pdvWRwVPeGmIwvQsFzEGYkyug57472570 = pdvWRwVPeGmIwvQsFzEGYkyug56939100;     pdvWRwVPeGmIwvQsFzEGYkyug56939100 = pdvWRwVPeGmIwvQsFzEGYkyug75641037;     pdvWRwVPeGmIwvQsFzEGYkyug75641037 = pdvWRwVPeGmIwvQsFzEGYkyug40543617;     pdvWRwVPeGmIwvQsFzEGYkyug40543617 = pdvWRwVPeGmIwvQsFzEGYkyug99038939;     pdvWRwVPeGmIwvQsFzEGYkyug99038939 = pdvWRwVPeGmIwvQsFzEGYkyug69051857;     pdvWRwVPeGmIwvQsFzEGYkyug69051857 = pdvWRwVPeGmIwvQsFzEGYkyug16666137;     pdvWRwVPeGmIwvQsFzEGYkyug16666137 = pdvWRwVPeGmIwvQsFzEGYkyug52914792;     pdvWRwVPeGmIwvQsFzEGYkyug52914792 = pdvWRwVPeGmIwvQsFzEGYkyug28027028;     pdvWRwVPeGmIwvQsFzEGYkyug28027028 = pdvWRwVPeGmIwvQsFzEGYkyug62169723;     pdvWRwVPeGmIwvQsFzEGYkyug62169723 = pdvWRwVPeGmIwvQsFzEGYkyug46733092;     pdvWRwVPeGmIwvQsFzEGYkyug46733092 = pdvWRwVPeGmIwvQsFzEGYkyug5077433;     pdvWRwVPeGmIwvQsFzEGYkyug5077433 = pdvWRwVPeGmIwvQsFzEGYkyug92927695;     pdvWRwVPeGmIwvQsFzEGYkyug92927695 = pdvWRwVPeGmIwvQsFzEGYkyug91527672;     pdvWRwVPeGmIwvQsFzEGYkyug91527672 = pdvWRwVPeGmIwvQsFzEGYkyug1030760;     pdvWRwVPeGmIwvQsFzEGYkyug1030760 = pdvWRwVPeGmIwvQsFzEGYkyug20351673;     pdvWRwVPeGmIwvQsFzEGYkyug20351673 = pdvWRwVPeGmIwvQsFzEGYkyug32080843;     pdvWRwVPeGmIwvQsFzEGYkyug32080843 = pdvWRwVPeGmIwvQsFzEGYkyug54094154;     pdvWRwVPeGmIwvQsFzEGYkyug54094154 = pdvWRwVPeGmIwvQsFzEGYkyug38159006;     pdvWRwVPeGmIwvQsFzEGYkyug38159006 = pdvWRwVPeGmIwvQsFzEGYkyug78364245;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ucfyXFBGyuZtBpyLoacVrDgGyZCRHsXHUsmfYIEZSWYJBnIILGGiIAMqw25952121() {     long ZzxCjyFXRZICSmfWCDVfWEKRu84481351 = -288179456;    long ZzxCjyFXRZICSmfWCDVfWEKRu6915972 = -158584078;    long ZzxCjyFXRZICSmfWCDVfWEKRu2934980 = -705025740;    long ZzxCjyFXRZICSmfWCDVfWEKRu34643034 = -58913883;    long ZzxCjyFXRZICSmfWCDVfWEKRu40470230 = -257534279;    long ZzxCjyFXRZICSmfWCDVfWEKRu96174806 = -461422422;    long ZzxCjyFXRZICSmfWCDVfWEKRu42681518 = -891825911;    long ZzxCjyFXRZICSmfWCDVfWEKRu83392103 = -223815491;    long ZzxCjyFXRZICSmfWCDVfWEKRu84614068 = 80388980;    long ZzxCjyFXRZICSmfWCDVfWEKRu67753957 = -116518068;    long ZzxCjyFXRZICSmfWCDVfWEKRu24149697 = -802016974;    long ZzxCjyFXRZICSmfWCDVfWEKRu51003242 = -200005044;    long ZzxCjyFXRZICSmfWCDVfWEKRu53086325 = -927676536;    long ZzxCjyFXRZICSmfWCDVfWEKRu56970415 = -807916064;    long ZzxCjyFXRZICSmfWCDVfWEKRu86178578 = -505787725;    long ZzxCjyFXRZICSmfWCDVfWEKRu6509806 = -433587569;    long ZzxCjyFXRZICSmfWCDVfWEKRu90796927 = -155513333;    long ZzxCjyFXRZICSmfWCDVfWEKRu86725102 = 35164141;    long ZzxCjyFXRZICSmfWCDVfWEKRu91812003 = -69368567;    long ZzxCjyFXRZICSmfWCDVfWEKRu93187657 = 97325105;    long ZzxCjyFXRZICSmfWCDVfWEKRu68738774 = -884642410;    long ZzxCjyFXRZICSmfWCDVfWEKRu19332645 = 47663640;    long ZzxCjyFXRZICSmfWCDVfWEKRu3466270 = -412885833;    long ZzxCjyFXRZICSmfWCDVfWEKRu56436499 = -427884339;    long ZzxCjyFXRZICSmfWCDVfWEKRu3771086 = -598471628;    long ZzxCjyFXRZICSmfWCDVfWEKRu73328847 = -250670196;    long ZzxCjyFXRZICSmfWCDVfWEKRu96707360 = -468260563;    long ZzxCjyFXRZICSmfWCDVfWEKRu5539507 = -176590080;    long ZzxCjyFXRZICSmfWCDVfWEKRu60424632 = -777797970;    long ZzxCjyFXRZICSmfWCDVfWEKRu26552637 = -588497036;    long ZzxCjyFXRZICSmfWCDVfWEKRu87525360 = -911754552;    long ZzxCjyFXRZICSmfWCDVfWEKRu95248620 = -636677830;    long ZzxCjyFXRZICSmfWCDVfWEKRu25352888 = -579710858;    long ZzxCjyFXRZICSmfWCDVfWEKRu78462828 = -424570000;    long ZzxCjyFXRZICSmfWCDVfWEKRu35054304 = -464313042;    long ZzxCjyFXRZICSmfWCDVfWEKRu26562851 = -497072986;    long ZzxCjyFXRZICSmfWCDVfWEKRu42443698 = -767244781;    long ZzxCjyFXRZICSmfWCDVfWEKRu86664463 = -177010661;    long ZzxCjyFXRZICSmfWCDVfWEKRu89505519 = -324987679;    long ZzxCjyFXRZICSmfWCDVfWEKRu85539632 = -730533255;    long ZzxCjyFXRZICSmfWCDVfWEKRu96460154 = -222984633;    long ZzxCjyFXRZICSmfWCDVfWEKRu91841965 = -473630269;    long ZzxCjyFXRZICSmfWCDVfWEKRu72182394 = -645898729;    long ZzxCjyFXRZICSmfWCDVfWEKRu72743381 = -549737640;    long ZzxCjyFXRZICSmfWCDVfWEKRu16512878 = -429021466;    long ZzxCjyFXRZICSmfWCDVfWEKRu90361312 = -445750325;    long ZzxCjyFXRZICSmfWCDVfWEKRu51115853 = -16926081;    long ZzxCjyFXRZICSmfWCDVfWEKRu48731953 = -578366276;    long ZzxCjyFXRZICSmfWCDVfWEKRu45169011 = -148206780;    long ZzxCjyFXRZICSmfWCDVfWEKRu31562992 = -619618386;    long ZzxCjyFXRZICSmfWCDVfWEKRu53094061 = -91987094;    long ZzxCjyFXRZICSmfWCDVfWEKRu7053592 = -177544703;    long ZzxCjyFXRZICSmfWCDVfWEKRu76834598 = -675300853;    long ZzxCjyFXRZICSmfWCDVfWEKRu94944683 = 20337521;    long ZzxCjyFXRZICSmfWCDVfWEKRu57213347 = -151627764;    long ZzxCjyFXRZICSmfWCDVfWEKRu65148707 = -235843096;    long ZzxCjyFXRZICSmfWCDVfWEKRu3449703 = -745698246;    long ZzxCjyFXRZICSmfWCDVfWEKRu46498481 = -177141402;    long ZzxCjyFXRZICSmfWCDVfWEKRu30871949 = -460442256;    long ZzxCjyFXRZICSmfWCDVfWEKRu67141383 = 93135916;    long ZzxCjyFXRZICSmfWCDVfWEKRu99467446 = -993161859;    long ZzxCjyFXRZICSmfWCDVfWEKRu37142011 = -615235831;    long ZzxCjyFXRZICSmfWCDVfWEKRu22967472 = -446017521;    long ZzxCjyFXRZICSmfWCDVfWEKRu58061432 = -331113984;    long ZzxCjyFXRZICSmfWCDVfWEKRu80228596 = -204763517;    long ZzxCjyFXRZICSmfWCDVfWEKRu28901076 = -65339145;    long ZzxCjyFXRZICSmfWCDVfWEKRu25650354 = -620294187;    long ZzxCjyFXRZICSmfWCDVfWEKRu74623496 = -403106537;    long ZzxCjyFXRZICSmfWCDVfWEKRu21916111 = -243603022;    long ZzxCjyFXRZICSmfWCDVfWEKRu59615728 = 91285260;    long ZzxCjyFXRZICSmfWCDVfWEKRu64066108 = -666342788;    long ZzxCjyFXRZICSmfWCDVfWEKRu4132464 = -978502672;    long ZzxCjyFXRZICSmfWCDVfWEKRu97219583 = -639848180;    long ZzxCjyFXRZICSmfWCDVfWEKRu6272371 = -338835313;    long ZzxCjyFXRZICSmfWCDVfWEKRu96727503 = -679690262;    long ZzxCjyFXRZICSmfWCDVfWEKRu76896808 = -311012142;    long ZzxCjyFXRZICSmfWCDVfWEKRu47150250 = -306437631;    long ZzxCjyFXRZICSmfWCDVfWEKRu30722888 = -863148193;    long ZzxCjyFXRZICSmfWCDVfWEKRu39923621 = -998862873;    long ZzxCjyFXRZICSmfWCDVfWEKRu13409773 = -52721303;    long ZzxCjyFXRZICSmfWCDVfWEKRu22212995 = -133744115;    long ZzxCjyFXRZICSmfWCDVfWEKRu47975407 = -889894288;    long ZzxCjyFXRZICSmfWCDVfWEKRu60370496 = 71616700;    long ZzxCjyFXRZICSmfWCDVfWEKRu28861640 = -58179585;    long ZzxCjyFXRZICSmfWCDVfWEKRu73458575 = -396509942;    long ZzxCjyFXRZICSmfWCDVfWEKRu80471769 = -634209849;    long ZzxCjyFXRZICSmfWCDVfWEKRu18414022 = -961376978;    long ZzxCjyFXRZICSmfWCDVfWEKRu30408205 = -500048379;    long ZzxCjyFXRZICSmfWCDVfWEKRu21249481 = -172942237;    long ZzxCjyFXRZICSmfWCDVfWEKRu69905596 = -128469946;    long ZzxCjyFXRZICSmfWCDVfWEKRu23113149 = -751374741;    long ZzxCjyFXRZICSmfWCDVfWEKRu95945216 = -490103379;    long ZzxCjyFXRZICSmfWCDVfWEKRu55792515 = -716568406;    long ZzxCjyFXRZICSmfWCDVfWEKRu22364136 = -318123595;    long ZzxCjyFXRZICSmfWCDVfWEKRu86072186 = -737371396;    long ZzxCjyFXRZICSmfWCDVfWEKRu59318143 = -607748802;    long ZzxCjyFXRZICSmfWCDVfWEKRu68874494 = 72387251;    long ZzxCjyFXRZICSmfWCDVfWEKRu14120962 = -214784746;    long ZzxCjyFXRZICSmfWCDVfWEKRu92514784 = -244974124;    long ZzxCjyFXRZICSmfWCDVfWEKRu87611802 = -288179456;     ZzxCjyFXRZICSmfWCDVfWEKRu84481351 = ZzxCjyFXRZICSmfWCDVfWEKRu6915972;     ZzxCjyFXRZICSmfWCDVfWEKRu6915972 = ZzxCjyFXRZICSmfWCDVfWEKRu2934980;     ZzxCjyFXRZICSmfWCDVfWEKRu2934980 = ZzxCjyFXRZICSmfWCDVfWEKRu34643034;     ZzxCjyFXRZICSmfWCDVfWEKRu34643034 = ZzxCjyFXRZICSmfWCDVfWEKRu40470230;     ZzxCjyFXRZICSmfWCDVfWEKRu40470230 = ZzxCjyFXRZICSmfWCDVfWEKRu96174806;     ZzxCjyFXRZICSmfWCDVfWEKRu96174806 = ZzxCjyFXRZICSmfWCDVfWEKRu42681518;     ZzxCjyFXRZICSmfWCDVfWEKRu42681518 = ZzxCjyFXRZICSmfWCDVfWEKRu83392103;     ZzxCjyFXRZICSmfWCDVfWEKRu83392103 = ZzxCjyFXRZICSmfWCDVfWEKRu84614068;     ZzxCjyFXRZICSmfWCDVfWEKRu84614068 = ZzxCjyFXRZICSmfWCDVfWEKRu67753957;     ZzxCjyFXRZICSmfWCDVfWEKRu67753957 = ZzxCjyFXRZICSmfWCDVfWEKRu24149697;     ZzxCjyFXRZICSmfWCDVfWEKRu24149697 = ZzxCjyFXRZICSmfWCDVfWEKRu51003242;     ZzxCjyFXRZICSmfWCDVfWEKRu51003242 = ZzxCjyFXRZICSmfWCDVfWEKRu53086325;     ZzxCjyFXRZICSmfWCDVfWEKRu53086325 = ZzxCjyFXRZICSmfWCDVfWEKRu56970415;     ZzxCjyFXRZICSmfWCDVfWEKRu56970415 = ZzxCjyFXRZICSmfWCDVfWEKRu86178578;     ZzxCjyFXRZICSmfWCDVfWEKRu86178578 = ZzxCjyFXRZICSmfWCDVfWEKRu6509806;     ZzxCjyFXRZICSmfWCDVfWEKRu6509806 = ZzxCjyFXRZICSmfWCDVfWEKRu90796927;     ZzxCjyFXRZICSmfWCDVfWEKRu90796927 = ZzxCjyFXRZICSmfWCDVfWEKRu86725102;     ZzxCjyFXRZICSmfWCDVfWEKRu86725102 = ZzxCjyFXRZICSmfWCDVfWEKRu91812003;     ZzxCjyFXRZICSmfWCDVfWEKRu91812003 = ZzxCjyFXRZICSmfWCDVfWEKRu93187657;     ZzxCjyFXRZICSmfWCDVfWEKRu93187657 = ZzxCjyFXRZICSmfWCDVfWEKRu68738774;     ZzxCjyFXRZICSmfWCDVfWEKRu68738774 = ZzxCjyFXRZICSmfWCDVfWEKRu19332645;     ZzxCjyFXRZICSmfWCDVfWEKRu19332645 = ZzxCjyFXRZICSmfWCDVfWEKRu3466270;     ZzxCjyFXRZICSmfWCDVfWEKRu3466270 = ZzxCjyFXRZICSmfWCDVfWEKRu56436499;     ZzxCjyFXRZICSmfWCDVfWEKRu56436499 = ZzxCjyFXRZICSmfWCDVfWEKRu3771086;     ZzxCjyFXRZICSmfWCDVfWEKRu3771086 = ZzxCjyFXRZICSmfWCDVfWEKRu73328847;     ZzxCjyFXRZICSmfWCDVfWEKRu73328847 = ZzxCjyFXRZICSmfWCDVfWEKRu96707360;     ZzxCjyFXRZICSmfWCDVfWEKRu96707360 = ZzxCjyFXRZICSmfWCDVfWEKRu5539507;     ZzxCjyFXRZICSmfWCDVfWEKRu5539507 = ZzxCjyFXRZICSmfWCDVfWEKRu60424632;     ZzxCjyFXRZICSmfWCDVfWEKRu60424632 = ZzxCjyFXRZICSmfWCDVfWEKRu26552637;     ZzxCjyFXRZICSmfWCDVfWEKRu26552637 = ZzxCjyFXRZICSmfWCDVfWEKRu87525360;     ZzxCjyFXRZICSmfWCDVfWEKRu87525360 = ZzxCjyFXRZICSmfWCDVfWEKRu95248620;     ZzxCjyFXRZICSmfWCDVfWEKRu95248620 = ZzxCjyFXRZICSmfWCDVfWEKRu25352888;     ZzxCjyFXRZICSmfWCDVfWEKRu25352888 = ZzxCjyFXRZICSmfWCDVfWEKRu78462828;     ZzxCjyFXRZICSmfWCDVfWEKRu78462828 = ZzxCjyFXRZICSmfWCDVfWEKRu35054304;     ZzxCjyFXRZICSmfWCDVfWEKRu35054304 = ZzxCjyFXRZICSmfWCDVfWEKRu26562851;     ZzxCjyFXRZICSmfWCDVfWEKRu26562851 = ZzxCjyFXRZICSmfWCDVfWEKRu42443698;     ZzxCjyFXRZICSmfWCDVfWEKRu42443698 = ZzxCjyFXRZICSmfWCDVfWEKRu86664463;     ZzxCjyFXRZICSmfWCDVfWEKRu86664463 = ZzxCjyFXRZICSmfWCDVfWEKRu89505519;     ZzxCjyFXRZICSmfWCDVfWEKRu89505519 = ZzxCjyFXRZICSmfWCDVfWEKRu85539632;     ZzxCjyFXRZICSmfWCDVfWEKRu85539632 = ZzxCjyFXRZICSmfWCDVfWEKRu96460154;     ZzxCjyFXRZICSmfWCDVfWEKRu96460154 = ZzxCjyFXRZICSmfWCDVfWEKRu91841965;     ZzxCjyFXRZICSmfWCDVfWEKRu91841965 = ZzxCjyFXRZICSmfWCDVfWEKRu72182394;     ZzxCjyFXRZICSmfWCDVfWEKRu72182394 = ZzxCjyFXRZICSmfWCDVfWEKRu72743381;     ZzxCjyFXRZICSmfWCDVfWEKRu72743381 = ZzxCjyFXRZICSmfWCDVfWEKRu16512878;     ZzxCjyFXRZICSmfWCDVfWEKRu16512878 = ZzxCjyFXRZICSmfWCDVfWEKRu90361312;     ZzxCjyFXRZICSmfWCDVfWEKRu90361312 = ZzxCjyFXRZICSmfWCDVfWEKRu51115853;     ZzxCjyFXRZICSmfWCDVfWEKRu51115853 = ZzxCjyFXRZICSmfWCDVfWEKRu48731953;     ZzxCjyFXRZICSmfWCDVfWEKRu48731953 = ZzxCjyFXRZICSmfWCDVfWEKRu45169011;     ZzxCjyFXRZICSmfWCDVfWEKRu45169011 = ZzxCjyFXRZICSmfWCDVfWEKRu31562992;     ZzxCjyFXRZICSmfWCDVfWEKRu31562992 = ZzxCjyFXRZICSmfWCDVfWEKRu53094061;     ZzxCjyFXRZICSmfWCDVfWEKRu53094061 = ZzxCjyFXRZICSmfWCDVfWEKRu7053592;     ZzxCjyFXRZICSmfWCDVfWEKRu7053592 = ZzxCjyFXRZICSmfWCDVfWEKRu76834598;     ZzxCjyFXRZICSmfWCDVfWEKRu76834598 = ZzxCjyFXRZICSmfWCDVfWEKRu94944683;     ZzxCjyFXRZICSmfWCDVfWEKRu94944683 = ZzxCjyFXRZICSmfWCDVfWEKRu57213347;     ZzxCjyFXRZICSmfWCDVfWEKRu57213347 = ZzxCjyFXRZICSmfWCDVfWEKRu65148707;     ZzxCjyFXRZICSmfWCDVfWEKRu65148707 = ZzxCjyFXRZICSmfWCDVfWEKRu3449703;     ZzxCjyFXRZICSmfWCDVfWEKRu3449703 = ZzxCjyFXRZICSmfWCDVfWEKRu46498481;     ZzxCjyFXRZICSmfWCDVfWEKRu46498481 = ZzxCjyFXRZICSmfWCDVfWEKRu30871949;     ZzxCjyFXRZICSmfWCDVfWEKRu30871949 = ZzxCjyFXRZICSmfWCDVfWEKRu67141383;     ZzxCjyFXRZICSmfWCDVfWEKRu67141383 = ZzxCjyFXRZICSmfWCDVfWEKRu99467446;     ZzxCjyFXRZICSmfWCDVfWEKRu99467446 = ZzxCjyFXRZICSmfWCDVfWEKRu37142011;     ZzxCjyFXRZICSmfWCDVfWEKRu37142011 = ZzxCjyFXRZICSmfWCDVfWEKRu22967472;     ZzxCjyFXRZICSmfWCDVfWEKRu22967472 = ZzxCjyFXRZICSmfWCDVfWEKRu58061432;     ZzxCjyFXRZICSmfWCDVfWEKRu58061432 = ZzxCjyFXRZICSmfWCDVfWEKRu80228596;     ZzxCjyFXRZICSmfWCDVfWEKRu80228596 = ZzxCjyFXRZICSmfWCDVfWEKRu28901076;     ZzxCjyFXRZICSmfWCDVfWEKRu28901076 = ZzxCjyFXRZICSmfWCDVfWEKRu25650354;     ZzxCjyFXRZICSmfWCDVfWEKRu25650354 = ZzxCjyFXRZICSmfWCDVfWEKRu74623496;     ZzxCjyFXRZICSmfWCDVfWEKRu74623496 = ZzxCjyFXRZICSmfWCDVfWEKRu21916111;     ZzxCjyFXRZICSmfWCDVfWEKRu21916111 = ZzxCjyFXRZICSmfWCDVfWEKRu59615728;     ZzxCjyFXRZICSmfWCDVfWEKRu59615728 = ZzxCjyFXRZICSmfWCDVfWEKRu64066108;     ZzxCjyFXRZICSmfWCDVfWEKRu64066108 = ZzxCjyFXRZICSmfWCDVfWEKRu4132464;     ZzxCjyFXRZICSmfWCDVfWEKRu4132464 = ZzxCjyFXRZICSmfWCDVfWEKRu97219583;     ZzxCjyFXRZICSmfWCDVfWEKRu97219583 = ZzxCjyFXRZICSmfWCDVfWEKRu6272371;     ZzxCjyFXRZICSmfWCDVfWEKRu6272371 = ZzxCjyFXRZICSmfWCDVfWEKRu96727503;     ZzxCjyFXRZICSmfWCDVfWEKRu96727503 = ZzxCjyFXRZICSmfWCDVfWEKRu76896808;     ZzxCjyFXRZICSmfWCDVfWEKRu76896808 = ZzxCjyFXRZICSmfWCDVfWEKRu47150250;     ZzxCjyFXRZICSmfWCDVfWEKRu47150250 = ZzxCjyFXRZICSmfWCDVfWEKRu30722888;     ZzxCjyFXRZICSmfWCDVfWEKRu30722888 = ZzxCjyFXRZICSmfWCDVfWEKRu39923621;     ZzxCjyFXRZICSmfWCDVfWEKRu39923621 = ZzxCjyFXRZICSmfWCDVfWEKRu13409773;     ZzxCjyFXRZICSmfWCDVfWEKRu13409773 = ZzxCjyFXRZICSmfWCDVfWEKRu22212995;     ZzxCjyFXRZICSmfWCDVfWEKRu22212995 = ZzxCjyFXRZICSmfWCDVfWEKRu47975407;     ZzxCjyFXRZICSmfWCDVfWEKRu47975407 = ZzxCjyFXRZICSmfWCDVfWEKRu60370496;     ZzxCjyFXRZICSmfWCDVfWEKRu60370496 = ZzxCjyFXRZICSmfWCDVfWEKRu28861640;     ZzxCjyFXRZICSmfWCDVfWEKRu28861640 = ZzxCjyFXRZICSmfWCDVfWEKRu73458575;     ZzxCjyFXRZICSmfWCDVfWEKRu73458575 = ZzxCjyFXRZICSmfWCDVfWEKRu80471769;     ZzxCjyFXRZICSmfWCDVfWEKRu80471769 = ZzxCjyFXRZICSmfWCDVfWEKRu18414022;     ZzxCjyFXRZICSmfWCDVfWEKRu18414022 = ZzxCjyFXRZICSmfWCDVfWEKRu30408205;     ZzxCjyFXRZICSmfWCDVfWEKRu30408205 = ZzxCjyFXRZICSmfWCDVfWEKRu21249481;     ZzxCjyFXRZICSmfWCDVfWEKRu21249481 = ZzxCjyFXRZICSmfWCDVfWEKRu69905596;     ZzxCjyFXRZICSmfWCDVfWEKRu69905596 = ZzxCjyFXRZICSmfWCDVfWEKRu23113149;     ZzxCjyFXRZICSmfWCDVfWEKRu23113149 = ZzxCjyFXRZICSmfWCDVfWEKRu95945216;     ZzxCjyFXRZICSmfWCDVfWEKRu95945216 = ZzxCjyFXRZICSmfWCDVfWEKRu55792515;     ZzxCjyFXRZICSmfWCDVfWEKRu55792515 = ZzxCjyFXRZICSmfWCDVfWEKRu22364136;     ZzxCjyFXRZICSmfWCDVfWEKRu22364136 = ZzxCjyFXRZICSmfWCDVfWEKRu86072186;     ZzxCjyFXRZICSmfWCDVfWEKRu86072186 = ZzxCjyFXRZICSmfWCDVfWEKRu59318143;     ZzxCjyFXRZICSmfWCDVfWEKRu59318143 = ZzxCjyFXRZICSmfWCDVfWEKRu68874494;     ZzxCjyFXRZICSmfWCDVfWEKRu68874494 = ZzxCjyFXRZICSmfWCDVfWEKRu14120962;     ZzxCjyFXRZICSmfWCDVfWEKRu14120962 = ZzxCjyFXRZICSmfWCDVfWEKRu92514784;     ZzxCjyFXRZICSmfWCDVfWEKRu92514784 = ZzxCjyFXRZICSmfWCDVfWEKRu87611802;     ZzxCjyFXRZICSmfWCDVfWEKRu87611802 = ZzxCjyFXRZICSmfWCDVfWEKRu84481351;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void HAAGKpWdOOLNPtdlUekFxfTwVxpXmBKcTRNkdjJDhubhfYsxySqFKFqbg93243720() {     long EkMAzqNEiuxftIlUhXDEmQxEr19940320 = -754456356;    long EkMAzqNEiuxftIlUhXDEmQxEr20188050 = -39135685;    long EkMAzqNEiuxftIlUhXDEmQxEr40321457 = -370692815;    long EkMAzqNEiuxftIlUhXDEmQxEr6866390 = -980064955;    long EkMAzqNEiuxftIlUhXDEmQxEr96755499 = -363133125;    long EkMAzqNEiuxftIlUhXDEmQxEr32397679 = -723770318;    long EkMAzqNEiuxftIlUhXDEmQxEr53338925 = -736551645;    long EkMAzqNEiuxftIlUhXDEmQxEr45523664 = -968049631;    long EkMAzqNEiuxftIlUhXDEmQxEr86131674 = -407942427;    long EkMAzqNEiuxftIlUhXDEmQxEr82656669 = -881205066;    long EkMAzqNEiuxftIlUhXDEmQxEr62331431 = -604024704;    long EkMAzqNEiuxftIlUhXDEmQxEr51571390 = -64125816;    long EkMAzqNEiuxftIlUhXDEmQxEr91320970 = -379689041;    long EkMAzqNEiuxftIlUhXDEmQxEr10111278 = -784279473;    long EkMAzqNEiuxftIlUhXDEmQxEr44373095 = 90787260;    long EkMAzqNEiuxftIlUhXDEmQxEr90051106 = -69399176;    long EkMAzqNEiuxftIlUhXDEmQxEr46632863 = -682487886;    long EkMAzqNEiuxftIlUhXDEmQxEr86485294 = -38263927;    long EkMAzqNEiuxftIlUhXDEmQxEr92362333 = -385931989;    long EkMAzqNEiuxftIlUhXDEmQxEr87024876 = -329235960;    long EkMAzqNEiuxftIlUhXDEmQxEr81825636 = -541917099;    long EkMAzqNEiuxftIlUhXDEmQxEr22754170 = -38972654;    long EkMAzqNEiuxftIlUhXDEmQxEr73991649 = -50518017;    long EkMAzqNEiuxftIlUhXDEmQxEr50229444 = -938708943;    long EkMAzqNEiuxftIlUhXDEmQxEr11789037 = -622456826;    long EkMAzqNEiuxftIlUhXDEmQxEr84027019 = 60752998;    long EkMAzqNEiuxftIlUhXDEmQxEr57127934 = -274544704;    long EkMAzqNEiuxftIlUhXDEmQxEr46267932 = -346362254;    long EkMAzqNEiuxftIlUhXDEmQxEr7092847 = -251892773;    long EkMAzqNEiuxftIlUhXDEmQxEr32086047 = -623004207;    long EkMAzqNEiuxftIlUhXDEmQxEr6108592 = -363735039;    long EkMAzqNEiuxftIlUhXDEmQxEr33071639 = -409649244;    long EkMAzqNEiuxftIlUhXDEmQxEr37570899 = -727306835;    long EkMAzqNEiuxftIlUhXDEmQxEr8211255 = -489263813;    long EkMAzqNEiuxftIlUhXDEmQxEr862758 = -415413293;    long EkMAzqNEiuxftIlUhXDEmQxEr78123694 = -711638292;    long EkMAzqNEiuxftIlUhXDEmQxEr91855514 = -631940821;    long EkMAzqNEiuxftIlUhXDEmQxEr37879867 = -159666242;    long EkMAzqNEiuxftIlUhXDEmQxEr19896081 = 24136045;    long EkMAzqNEiuxftIlUhXDEmQxEr49811165 = -195795801;    long EkMAzqNEiuxftIlUhXDEmQxEr29911762 = 7816453;    long EkMAzqNEiuxftIlUhXDEmQxEr81207092 = -68175560;    long EkMAzqNEiuxftIlUhXDEmQxEr61565773 = -199079515;    long EkMAzqNEiuxftIlUhXDEmQxEr12874720 = -54070050;    long EkMAzqNEiuxftIlUhXDEmQxEr16529337 = -255532628;    long EkMAzqNEiuxftIlUhXDEmQxEr36322641 = -484673958;    long EkMAzqNEiuxftIlUhXDEmQxEr70461016 = -500912442;    long EkMAzqNEiuxftIlUhXDEmQxEr66458265 = -744892869;    long EkMAzqNEiuxftIlUhXDEmQxEr68061677 = -911943660;    long EkMAzqNEiuxftIlUhXDEmQxEr56092581 = -10645202;    long EkMAzqNEiuxftIlUhXDEmQxEr33864785 = 33736348;    long EkMAzqNEiuxftIlUhXDEmQxEr90539063 = -391197049;    long EkMAzqNEiuxftIlUhXDEmQxEr45455747 = -431346407;    long EkMAzqNEiuxftIlUhXDEmQxEr10936530 = -171170979;    long EkMAzqNEiuxftIlUhXDEmQxEr11418084 = -498117910;    long EkMAzqNEiuxftIlUhXDEmQxEr97186150 = -615483702;    long EkMAzqNEiuxftIlUhXDEmQxEr46196401 = -988617668;    long EkMAzqNEiuxftIlUhXDEmQxEr90092012 = -431983873;    long EkMAzqNEiuxftIlUhXDEmQxEr95077352 = -257608129;    long EkMAzqNEiuxftIlUhXDEmQxEr12728481 = -323886123;    long EkMAzqNEiuxftIlUhXDEmQxEr75269744 = -349225614;    long EkMAzqNEiuxftIlUhXDEmQxEr7070993 = -290189391;    long EkMAzqNEiuxftIlUhXDEmQxEr38430818 = -616156859;    long EkMAzqNEiuxftIlUhXDEmQxEr54045627 = -784938221;    long EkMAzqNEiuxftIlUhXDEmQxEr76548077 = -417470028;    long EkMAzqNEiuxftIlUhXDEmQxEr29259792 = -94375460;    long EkMAzqNEiuxftIlUhXDEmQxEr14000492 = -336818981;    long EkMAzqNEiuxftIlUhXDEmQxEr83109715 = -890425228;    long EkMAzqNEiuxftIlUhXDEmQxEr9248521 = -268866181;    long EkMAzqNEiuxftIlUhXDEmQxEr66249400 = -197574449;    long EkMAzqNEiuxftIlUhXDEmQxEr98195592 = -437458355;    long EkMAzqNEiuxftIlUhXDEmQxEr8752996 = -422821644;    long EkMAzqNEiuxftIlUhXDEmQxEr66589213 = 37600027;    long EkMAzqNEiuxftIlUhXDEmQxEr42551168 = -90136188;    long EkMAzqNEiuxftIlUhXDEmQxEr57113114 = -237052414;    long EkMAzqNEiuxftIlUhXDEmQxEr618545 = -373741540;    long EkMAzqNEiuxftIlUhXDEmQxEr61188396 = -839893139;    long EkMAzqNEiuxftIlUhXDEmQxEr61116930 = -996447967;    long EkMAzqNEiuxftIlUhXDEmQxEr33700107 = -583176316;    long EkMAzqNEiuxftIlUhXDEmQxEr75466395 = -37782869;    long EkMAzqNEiuxftIlUhXDEmQxEr13566003 = -438334561;    long EkMAzqNEiuxftIlUhXDEmQxEr90669669 = -529651835;    long EkMAzqNEiuxftIlUhXDEmQxEr78206255 = -434418594;    long EkMAzqNEiuxftIlUhXDEmQxEr51000266 = -141247572;    long EkMAzqNEiuxftIlUhXDEmQxEr98221262 = -556740555;    long EkMAzqNEiuxftIlUhXDEmQxEr15569528 = -972537990;    long EkMAzqNEiuxftIlUhXDEmQxEr87615891 = -978302838;    long EkMAzqNEiuxftIlUhXDEmQxEr26634369 = -456135857;    long EkMAzqNEiuxftIlUhXDEmQxEr96793171 = -991145904;    long EkMAzqNEiuxftIlUhXDEmQxEr3676607 = -799929591;    long EkMAzqNEiuxftIlUhXDEmQxEr31927294 = -723020624;    long EkMAzqNEiuxftIlUhXDEmQxEr1763502 = -99956949;    long EkMAzqNEiuxftIlUhXDEmQxEr42802514 = -902058114;    long EkMAzqNEiuxftIlUhXDEmQxEr7167600 = -651977833;    long EkMAzqNEiuxftIlUhXDEmQxEr74541420 = -846570188;    long EkMAzqNEiuxftIlUhXDEmQxEr22840770 = -701994156;    long EkMAzqNEiuxftIlUhXDEmQxEr42776275 = -452018702;    long EkMAzqNEiuxftIlUhXDEmQxEr7520146 = -414141295;    long EkMAzqNEiuxftIlUhXDEmQxEr36326642 = -636600023;    long EkMAzqNEiuxftIlUhXDEmQxEr87269544 = -754456356;     EkMAzqNEiuxftIlUhXDEmQxEr19940320 = EkMAzqNEiuxftIlUhXDEmQxEr20188050;     EkMAzqNEiuxftIlUhXDEmQxEr20188050 = EkMAzqNEiuxftIlUhXDEmQxEr40321457;     EkMAzqNEiuxftIlUhXDEmQxEr40321457 = EkMAzqNEiuxftIlUhXDEmQxEr6866390;     EkMAzqNEiuxftIlUhXDEmQxEr6866390 = EkMAzqNEiuxftIlUhXDEmQxEr96755499;     EkMAzqNEiuxftIlUhXDEmQxEr96755499 = EkMAzqNEiuxftIlUhXDEmQxEr32397679;     EkMAzqNEiuxftIlUhXDEmQxEr32397679 = EkMAzqNEiuxftIlUhXDEmQxEr53338925;     EkMAzqNEiuxftIlUhXDEmQxEr53338925 = EkMAzqNEiuxftIlUhXDEmQxEr45523664;     EkMAzqNEiuxftIlUhXDEmQxEr45523664 = EkMAzqNEiuxftIlUhXDEmQxEr86131674;     EkMAzqNEiuxftIlUhXDEmQxEr86131674 = EkMAzqNEiuxftIlUhXDEmQxEr82656669;     EkMAzqNEiuxftIlUhXDEmQxEr82656669 = EkMAzqNEiuxftIlUhXDEmQxEr62331431;     EkMAzqNEiuxftIlUhXDEmQxEr62331431 = EkMAzqNEiuxftIlUhXDEmQxEr51571390;     EkMAzqNEiuxftIlUhXDEmQxEr51571390 = EkMAzqNEiuxftIlUhXDEmQxEr91320970;     EkMAzqNEiuxftIlUhXDEmQxEr91320970 = EkMAzqNEiuxftIlUhXDEmQxEr10111278;     EkMAzqNEiuxftIlUhXDEmQxEr10111278 = EkMAzqNEiuxftIlUhXDEmQxEr44373095;     EkMAzqNEiuxftIlUhXDEmQxEr44373095 = EkMAzqNEiuxftIlUhXDEmQxEr90051106;     EkMAzqNEiuxftIlUhXDEmQxEr90051106 = EkMAzqNEiuxftIlUhXDEmQxEr46632863;     EkMAzqNEiuxftIlUhXDEmQxEr46632863 = EkMAzqNEiuxftIlUhXDEmQxEr86485294;     EkMAzqNEiuxftIlUhXDEmQxEr86485294 = EkMAzqNEiuxftIlUhXDEmQxEr92362333;     EkMAzqNEiuxftIlUhXDEmQxEr92362333 = EkMAzqNEiuxftIlUhXDEmQxEr87024876;     EkMAzqNEiuxftIlUhXDEmQxEr87024876 = EkMAzqNEiuxftIlUhXDEmQxEr81825636;     EkMAzqNEiuxftIlUhXDEmQxEr81825636 = EkMAzqNEiuxftIlUhXDEmQxEr22754170;     EkMAzqNEiuxftIlUhXDEmQxEr22754170 = EkMAzqNEiuxftIlUhXDEmQxEr73991649;     EkMAzqNEiuxftIlUhXDEmQxEr73991649 = EkMAzqNEiuxftIlUhXDEmQxEr50229444;     EkMAzqNEiuxftIlUhXDEmQxEr50229444 = EkMAzqNEiuxftIlUhXDEmQxEr11789037;     EkMAzqNEiuxftIlUhXDEmQxEr11789037 = EkMAzqNEiuxftIlUhXDEmQxEr84027019;     EkMAzqNEiuxftIlUhXDEmQxEr84027019 = EkMAzqNEiuxftIlUhXDEmQxEr57127934;     EkMAzqNEiuxftIlUhXDEmQxEr57127934 = EkMAzqNEiuxftIlUhXDEmQxEr46267932;     EkMAzqNEiuxftIlUhXDEmQxEr46267932 = EkMAzqNEiuxftIlUhXDEmQxEr7092847;     EkMAzqNEiuxftIlUhXDEmQxEr7092847 = EkMAzqNEiuxftIlUhXDEmQxEr32086047;     EkMAzqNEiuxftIlUhXDEmQxEr32086047 = EkMAzqNEiuxftIlUhXDEmQxEr6108592;     EkMAzqNEiuxftIlUhXDEmQxEr6108592 = EkMAzqNEiuxftIlUhXDEmQxEr33071639;     EkMAzqNEiuxftIlUhXDEmQxEr33071639 = EkMAzqNEiuxftIlUhXDEmQxEr37570899;     EkMAzqNEiuxftIlUhXDEmQxEr37570899 = EkMAzqNEiuxftIlUhXDEmQxEr8211255;     EkMAzqNEiuxftIlUhXDEmQxEr8211255 = EkMAzqNEiuxftIlUhXDEmQxEr862758;     EkMAzqNEiuxftIlUhXDEmQxEr862758 = EkMAzqNEiuxftIlUhXDEmQxEr78123694;     EkMAzqNEiuxftIlUhXDEmQxEr78123694 = EkMAzqNEiuxftIlUhXDEmQxEr91855514;     EkMAzqNEiuxftIlUhXDEmQxEr91855514 = EkMAzqNEiuxftIlUhXDEmQxEr37879867;     EkMAzqNEiuxftIlUhXDEmQxEr37879867 = EkMAzqNEiuxftIlUhXDEmQxEr19896081;     EkMAzqNEiuxftIlUhXDEmQxEr19896081 = EkMAzqNEiuxftIlUhXDEmQxEr49811165;     EkMAzqNEiuxftIlUhXDEmQxEr49811165 = EkMAzqNEiuxftIlUhXDEmQxEr29911762;     EkMAzqNEiuxftIlUhXDEmQxEr29911762 = EkMAzqNEiuxftIlUhXDEmQxEr81207092;     EkMAzqNEiuxftIlUhXDEmQxEr81207092 = EkMAzqNEiuxftIlUhXDEmQxEr61565773;     EkMAzqNEiuxftIlUhXDEmQxEr61565773 = EkMAzqNEiuxftIlUhXDEmQxEr12874720;     EkMAzqNEiuxftIlUhXDEmQxEr12874720 = EkMAzqNEiuxftIlUhXDEmQxEr16529337;     EkMAzqNEiuxftIlUhXDEmQxEr16529337 = EkMAzqNEiuxftIlUhXDEmQxEr36322641;     EkMAzqNEiuxftIlUhXDEmQxEr36322641 = EkMAzqNEiuxftIlUhXDEmQxEr70461016;     EkMAzqNEiuxftIlUhXDEmQxEr70461016 = EkMAzqNEiuxftIlUhXDEmQxEr66458265;     EkMAzqNEiuxftIlUhXDEmQxEr66458265 = EkMAzqNEiuxftIlUhXDEmQxEr68061677;     EkMAzqNEiuxftIlUhXDEmQxEr68061677 = EkMAzqNEiuxftIlUhXDEmQxEr56092581;     EkMAzqNEiuxftIlUhXDEmQxEr56092581 = EkMAzqNEiuxftIlUhXDEmQxEr33864785;     EkMAzqNEiuxftIlUhXDEmQxEr33864785 = EkMAzqNEiuxftIlUhXDEmQxEr90539063;     EkMAzqNEiuxftIlUhXDEmQxEr90539063 = EkMAzqNEiuxftIlUhXDEmQxEr45455747;     EkMAzqNEiuxftIlUhXDEmQxEr45455747 = EkMAzqNEiuxftIlUhXDEmQxEr10936530;     EkMAzqNEiuxftIlUhXDEmQxEr10936530 = EkMAzqNEiuxftIlUhXDEmQxEr11418084;     EkMAzqNEiuxftIlUhXDEmQxEr11418084 = EkMAzqNEiuxftIlUhXDEmQxEr97186150;     EkMAzqNEiuxftIlUhXDEmQxEr97186150 = EkMAzqNEiuxftIlUhXDEmQxEr46196401;     EkMAzqNEiuxftIlUhXDEmQxEr46196401 = EkMAzqNEiuxftIlUhXDEmQxEr90092012;     EkMAzqNEiuxftIlUhXDEmQxEr90092012 = EkMAzqNEiuxftIlUhXDEmQxEr95077352;     EkMAzqNEiuxftIlUhXDEmQxEr95077352 = EkMAzqNEiuxftIlUhXDEmQxEr12728481;     EkMAzqNEiuxftIlUhXDEmQxEr12728481 = EkMAzqNEiuxftIlUhXDEmQxEr75269744;     EkMAzqNEiuxftIlUhXDEmQxEr75269744 = EkMAzqNEiuxftIlUhXDEmQxEr7070993;     EkMAzqNEiuxftIlUhXDEmQxEr7070993 = EkMAzqNEiuxftIlUhXDEmQxEr38430818;     EkMAzqNEiuxftIlUhXDEmQxEr38430818 = EkMAzqNEiuxftIlUhXDEmQxEr54045627;     EkMAzqNEiuxftIlUhXDEmQxEr54045627 = EkMAzqNEiuxftIlUhXDEmQxEr76548077;     EkMAzqNEiuxftIlUhXDEmQxEr76548077 = EkMAzqNEiuxftIlUhXDEmQxEr29259792;     EkMAzqNEiuxftIlUhXDEmQxEr29259792 = EkMAzqNEiuxftIlUhXDEmQxEr14000492;     EkMAzqNEiuxftIlUhXDEmQxEr14000492 = EkMAzqNEiuxftIlUhXDEmQxEr83109715;     EkMAzqNEiuxftIlUhXDEmQxEr83109715 = EkMAzqNEiuxftIlUhXDEmQxEr9248521;     EkMAzqNEiuxftIlUhXDEmQxEr9248521 = EkMAzqNEiuxftIlUhXDEmQxEr66249400;     EkMAzqNEiuxftIlUhXDEmQxEr66249400 = EkMAzqNEiuxftIlUhXDEmQxEr98195592;     EkMAzqNEiuxftIlUhXDEmQxEr98195592 = EkMAzqNEiuxftIlUhXDEmQxEr8752996;     EkMAzqNEiuxftIlUhXDEmQxEr8752996 = EkMAzqNEiuxftIlUhXDEmQxEr66589213;     EkMAzqNEiuxftIlUhXDEmQxEr66589213 = EkMAzqNEiuxftIlUhXDEmQxEr42551168;     EkMAzqNEiuxftIlUhXDEmQxEr42551168 = EkMAzqNEiuxftIlUhXDEmQxEr57113114;     EkMAzqNEiuxftIlUhXDEmQxEr57113114 = EkMAzqNEiuxftIlUhXDEmQxEr618545;     EkMAzqNEiuxftIlUhXDEmQxEr618545 = EkMAzqNEiuxftIlUhXDEmQxEr61188396;     EkMAzqNEiuxftIlUhXDEmQxEr61188396 = EkMAzqNEiuxftIlUhXDEmQxEr61116930;     EkMAzqNEiuxftIlUhXDEmQxEr61116930 = EkMAzqNEiuxftIlUhXDEmQxEr33700107;     EkMAzqNEiuxftIlUhXDEmQxEr33700107 = EkMAzqNEiuxftIlUhXDEmQxEr75466395;     EkMAzqNEiuxftIlUhXDEmQxEr75466395 = EkMAzqNEiuxftIlUhXDEmQxEr13566003;     EkMAzqNEiuxftIlUhXDEmQxEr13566003 = EkMAzqNEiuxftIlUhXDEmQxEr90669669;     EkMAzqNEiuxftIlUhXDEmQxEr90669669 = EkMAzqNEiuxftIlUhXDEmQxEr78206255;     EkMAzqNEiuxftIlUhXDEmQxEr78206255 = EkMAzqNEiuxftIlUhXDEmQxEr51000266;     EkMAzqNEiuxftIlUhXDEmQxEr51000266 = EkMAzqNEiuxftIlUhXDEmQxEr98221262;     EkMAzqNEiuxftIlUhXDEmQxEr98221262 = EkMAzqNEiuxftIlUhXDEmQxEr15569528;     EkMAzqNEiuxftIlUhXDEmQxEr15569528 = EkMAzqNEiuxftIlUhXDEmQxEr87615891;     EkMAzqNEiuxftIlUhXDEmQxEr87615891 = EkMAzqNEiuxftIlUhXDEmQxEr26634369;     EkMAzqNEiuxftIlUhXDEmQxEr26634369 = EkMAzqNEiuxftIlUhXDEmQxEr96793171;     EkMAzqNEiuxftIlUhXDEmQxEr96793171 = EkMAzqNEiuxftIlUhXDEmQxEr3676607;     EkMAzqNEiuxftIlUhXDEmQxEr3676607 = EkMAzqNEiuxftIlUhXDEmQxEr31927294;     EkMAzqNEiuxftIlUhXDEmQxEr31927294 = EkMAzqNEiuxftIlUhXDEmQxEr1763502;     EkMAzqNEiuxftIlUhXDEmQxEr1763502 = EkMAzqNEiuxftIlUhXDEmQxEr42802514;     EkMAzqNEiuxftIlUhXDEmQxEr42802514 = EkMAzqNEiuxftIlUhXDEmQxEr7167600;     EkMAzqNEiuxftIlUhXDEmQxEr7167600 = EkMAzqNEiuxftIlUhXDEmQxEr74541420;     EkMAzqNEiuxftIlUhXDEmQxEr74541420 = EkMAzqNEiuxftIlUhXDEmQxEr22840770;     EkMAzqNEiuxftIlUhXDEmQxEr22840770 = EkMAzqNEiuxftIlUhXDEmQxEr42776275;     EkMAzqNEiuxftIlUhXDEmQxEr42776275 = EkMAzqNEiuxftIlUhXDEmQxEr7520146;     EkMAzqNEiuxftIlUhXDEmQxEr7520146 = EkMAzqNEiuxftIlUhXDEmQxEr36326642;     EkMAzqNEiuxftIlUhXDEmQxEr36326642 = EkMAzqNEiuxftIlUhXDEmQxEr87269544;     EkMAzqNEiuxftIlUhXDEmQxEr87269544 = EkMAzqNEiuxftIlUhXDEmQxEr19940320;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ZTujYeKGpwnOvEwQjfhwnAVChayNpiVqDTLRHJrydbcmZJYoMvGeEfZZy8292789() {     long rCygwQHbwKcsfJaniSLXidYCJ26057427 = -866358245;    long rCygwQHbwKcsfJaniSLXidYCJ63561329 = -848735465;    long rCygwQHbwKcsfJaniSLXidYCJ56363640 = -521525737;    long rCygwQHbwKcsfJaniSLXidYCJ33941170 = -70813585;    long rCygwQHbwKcsfJaniSLXidYCJ65650988 = -883782996;    long rCygwQHbwKcsfJaniSLXidYCJ23814881 = -988266553;    long rCygwQHbwKcsfJaniSLXidYCJ13827891 = -875516622;    long rCygwQHbwKcsfJaniSLXidYCJ95283555 = -154923544;    long rCygwQHbwKcsfJaniSLXidYCJ50774169 = -175975093;    long rCygwQHbwKcsfJaniSLXidYCJ23886329 = -110180544;    long rCygwQHbwKcsfJaniSLXidYCJ22441722 = -481462290;    long rCygwQHbwKcsfJaniSLXidYCJ83394433 = -508532018;    long rCygwQHbwKcsfJaniSLXidYCJ77530088 = -819580130;    long rCygwQHbwKcsfJaniSLXidYCJ93254954 = -216518041;    long rCygwQHbwKcsfJaniSLXidYCJ40115522 = -599674906;    long rCygwQHbwKcsfJaniSLXidYCJ31556501 = -42398719;    long rCygwQHbwKcsfJaniSLXidYCJ40468866 = -199032998;    long rCygwQHbwKcsfJaniSLXidYCJ83538447 = -803786570;    long rCygwQHbwKcsfJaniSLXidYCJ54192175 = -791701086;    long rCygwQHbwKcsfJaniSLXidYCJ67575041 = -686138880;    long rCygwQHbwKcsfJaniSLXidYCJ70378830 = -397404555;    long rCygwQHbwKcsfJaniSLXidYCJ9275193 = 53097629;    long rCygwQHbwKcsfJaniSLXidYCJ9582441 = -897035504;    long rCygwQHbwKcsfJaniSLXidYCJ34221818 = -61013931;    long rCygwQHbwKcsfJaniSLXidYCJ55488687 = -995652859;    long rCygwQHbwKcsfJaniSLXidYCJ8748695 = -917902326;    long rCygwQHbwKcsfJaniSLXidYCJ55587712 = -175206907;    long rCygwQHbwKcsfJaniSLXidYCJ59375057 = -412291208;    long rCygwQHbwKcsfJaniSLXidYCJ73225102 = -474275477;    long rCygwQHbwKcsfJaniSLXidYCJ701684 = -440475074;    long rCygwQHbwKcsfJaniSLXidYCJ98351141 = -277055977;    long rCygwQHbwKcsfJaniSLXidYCJ30682261 = -119096060;    long rCygwQHbwKcsfJaniSLXidYCJ47281848 = -619920205;    long rCygwQHbwKcsfJaniSLXidYCJ3041820 = -240805579;    long rCygwQHbwKcsfJaniSLXidYCJ62337409 = 45853602;    long rCygwQHbwKcsfJaniSLXidYCJ46849608 = -925664399;    long rCygwQHbwKcsfJaniSLXidYCJ73117449 = -585576691;    long rCygwQHbwKcsfJaniSLXidYCJ71970079 = 68827748;    long rCygwQHbwKcsfJaniSLXidYCJ93506334 = 30212548;    long rCygwQHbwKcsfJaniSLXidYCJ37313103 = -669235024;    long rCygwQHbwKcsfJaniSLXidYCJ35580986 = -57457441;    long rCygwQHbwKcsfJaniSLXidYCJ13357550 = -338317838;    long rCygwQHbwKcsfJaniSLXidYCJ39632751 = -279884099;    long rCygwQHbwKcsfJaniSLXidYCJ282460 = -73412988;    long rCygwQHbwKcsfJaniSLXidYCJ28481802 = 82569218;    long rCygwQHbwKcsfJaniSLXidYCJ48261836 = -469890074;    long rCygwQHbwKcsfJaniSLXidYCJ88239591 = -619687979;    long rCygwQHbwKcsfJaniSLXidYCJ74415205 = -754788402;    long rCygwQHbwKcsfJaniSLXidYCJ77737406 = -997680649;    long rCygwQHbwKcsfJaniSLXidYCJ69004234 = -97656010;    long rCygwQHbwKcsfJaniSLXidYCJ69565463 = -908557323;    long rCygwQHbwKcsfJaniSLXidYCJ1348784 = -191923370;    long rCygwQHbwKcsfJaniSLXidYCJ93704204 = -223135994;    long rCygwQHbwKcsfJaniSLXidYCJ6905411 = -491641124;    long rCygwQHbwKcsfJaniSLXidYCJ37913958 = -98649692;    long rCygwQHbwKcsfJaniSLXidYCJ16782234 = -819455875;    long rCygwQHbwKcsfJaniSLXidYCJ53978889 = -951699962;    long rCygwQHbwKcsfJaniSLXidYCJ22141823 = -360511806;    long rCygwQHbwKcsfJaniSLXidYCJ78452483 = -75160726;    long rCygwQHbwKcsfJaniSLXidYCJ56902294 = -965880671;    long rCygwQHbwKcsfJaniSLXidYCJ68227168 = -713059646;    long rCygwQHbwKcsfJaniSLXidYCJ54452833 = -363225415;    long rCygwQHbwKcsfJaniSLXidYCJ22058453 = -680648067;    long rCygwQHbwKcsfJaniSLXidYCJ50072485 = -735500019;    long rCygwQHbwKcsfJaniSLXidYCJ25535187 = -833124567;    long rCygwQHbwKcsfJaniSLXidYCJ91759460 = -262366231;    long rCygwQHbwKcsfJaniSLXidYCJ36112585 = -888611813;    long rCygwQHbwKcsfJaniSLXidYCJ74488269 = -478774552;    long rCygwQHbwKcsfJaniSLXidYCJ30917546 = -162371643;    long rCygwQHbwKcsfJaniSLXidYCJ93265913 = -674010508;    long rCygwQHbwKcsfJaniSLXidYCJ58439051 = -456822029;    long rCygwQHbwKcsfJaniSLXidYCJ68498786 = -167860747;    long rCygwQHbwKcsfJaniSLXidYCJ90032112 = -733999118;    long rCygwQHbwKcsfJaniSLXidYCJ16879073 = -22466062;    long rCygwQHbwKcsfJaniSLXidYCJ31994055 = -528681439;    long rCygwQHbwKcsfJaniSLXidYCJ57021280 = 40913283;    long rCygwQHbwKcsfJaniSLXidYCJ69642442 = -667018272;    long rCygwQHbwKcsfJaniSLXidYCJ9299982 = -723622516;    long rCygwQHbwKcsfJaniSLXidYCJ5740016 = -43583149;    long rCygwQHbwKcsfJaniSLXidYCJ7226851 = -425762786;    long rCygwQHbwKcsfJaniSLXidYCJ20509104 = -198214347;    long rCygwQHbwKcsfJaniSLXidYCJ81172506 = -420418506;    long rCygwQHbwKcsfJaniSLXidYCJ81637651 = -414610560;    long rCygwQHbwKcsfJaniSLXidYCJ4220869 = -276619468;    long rCygwQHbwKcsfJaniSLXidYCJ31136221 = -531917752;    long rCygwQHbwKcsfJaniSLXidYCJ97002358 = 14867392;    long rCygwQHbwKcsfJaniSLXidYCJ36978056 = -895960066;    long rCygwQHbwKcsfJaniSLXidYCJ40376437 = -28279082;    long rCygwQHbwKcsfJaniSLXidYCJ65127861 = -42155887;    long rCygwQHbwKcsfJaniSLXidYCJ45555175 = -134690524;    long rCygwQHbwKcsfJaniSLXidYCJ92870719 = -973964438;    long rCygwQHbwKcsfJaniSLXidYCJ50975627 = -125064885;    long rCygwQHbwKcsfJaniSLXidYCJ93517596 = -856011526;    long rCygwQHbwKcsfJaniSLXidYCJ36604041 = -3906782;    long rCygwQHbwKcsfJaniSLXidYCJ69085934 = -956175378;    long rCygwQHbwKcsfJaniSLXidYCJ81128152 = -694232027;    long rCygwQHbwKcsfJaniSLXidYCJ91299096 = -657669771;    long rCygwQHbwKcsfJaniSLXidYCJ89560265 = -544384081;    long rCygwQHbwKcsfJaniSLXidYCJ74747272 = -240288422;    long rCygwQHbwKcsfJaniSLXidYCJ36722341 = -866358245;     rCygwQHbwKcsfJaniSLXidYCJ26057427 = rCygwQHbwKcsfJaniSLXidYCJ63561329;     rCygwQHbwKcsfJaniSLXidYCJ63561329 = rCygwQHbwKcsfJaniSLXidYCJ56363640;     rCygwQHbwKcsfJaniSLXidYCJ56363640 = rCygwQHbwKcsfJaniSLXidYCJ33941170;     rCygwQHbwKcsfJaniSLXidYCJ33941170 = rCygwQHbwKcsfJaniSLXidYCJ65650988;     rCygwQHbwKcsfJaniSLXidYCJ65650988 = rCygwQHbwKcsfJaniSLXidYCJ23814881;     rCygwQHbwKcsfJaniSLXidYCJ23814881 = rCygwQHbwKcsfJaniSLXidYCJ13827891;     rCygwQHbwKcsfJaniSLXidYCJ13827891 = rCygwQHbwKcsfJaniSLXidYCJ95283555;     rCygwQHbwKcsfJaniSLXidYCJ95283555 = rCygwQHbwKcsfJaniSLXidYCJ50774169;     rCygwQHbwKcsfJaniSLXidYCJ50774169 = rCygwQHbwKcsfJaniSLXidYCJ23886329;     rCygwQHbwKcsfJaniSLXidYCJ23886329 = rCygwQHbwKcsfJaniSLXidYCJ22441722;     rCygwQHbwKcsfJaniSLXidYCJ22441722 = rCygwQHbwKcsfJaniSLXidYCJ83394433;     rCygwQHbwKcsfJaniSLXidYCJ83394433 = rCygwQHbwKcsfJaniSLXidYCJ77530088;     rCygwQHbwKcsfJaniSLXidYCJ77530088 = rCygwQHbwKcsfJaniSLXidYCJ93254954;     rCygwQHbwKcsfJaniSLXidYCJ93254954 = rCygwQHbwKcsfJaniSLXidYCJ40115522;     rCygwQHbwKcsfJaniSLXidYCJ40115522 = rCygwQHbwKcsfJaniSLXidYCJ31556501;     rCygwQHbwKcsfJaniSLXidYCJ31556501 = rCygwQHbwKcsfJaniSLXidYCJ40468866;     rCygwQHbwKcsfJaniSLXidYCJ40468866 = rCygwQHbwKcsfJaniSLXidYCJ83538447;     rCygwQHbwKcsfJaniSLXidYCJ83538447 = rCygwQHbwKcsfJaniSLXidYCJ54192175;     rCygwQHbwKcsfJaniSLXidYCJ54192175 = rCygwQHbwKcsfJaniSLXidYCJ67575041;     rCygwQHbwKcsfJaniSLXidYCJ67575041 = rCygwQHbwKcsfJaniSLXidYCJ70378830;     rCygwQHbwKcsfJaniSLXidYCJ70378830 = rCygwQHbwKcsfJaniSLXidYCJ9275193;     rCygwQHbwKcsfJaniSLXidYCJ9275193 = rCygwQHbwKcsfJaniSLXidYCJ9582441;     rCygwQHbwKcsfJaniSLXidYCJ9582441 = rCygwQHbwKcsfJaniSLXidYCJ34221818;     rCygwQHbwKcsfJaniSLXidYCJ34221818 = rCygwQHbwKcsfJaniSLXidYCJ55488687;     rCygwQHbwKcsfJaniSLXidYCJ55488687 = rCygwQHbwKcsfJaniSLXidYCJ8748695;     rCygwQHbwKcsfJaniSLXidYCJ8748695 = rCygwQHbwKcsfJaniSLXidYCJ55587712;     rCygwQHbwKcsfJaniSLXidYCJ55587712 = rCygwQHbwKcsfJaniSLXidYCJ59375057;     rCygwQHbwKcsfJaniSLXidYCJ59375057 = rCygwQHbwKcsfJaniSLXidYCJ73225102;     rCygwQHbwKcsfJaniSLXidYCJ73225102 = rCygwQHbwKcsfJaniSLXidYCJ701684;     rCygwQHbwKcsfJaniSLXidYCJ701684 = rCygwQHbwKcsfJaniSLXidYCJ98351141;     rCygwQHbwKcsfJaniSLXidYCJ98351141 = rCygwQHbwKcsfJaniSLXidYCJ30682261;     rCygwQHbwKcsfJaniSLXidYCJ30682261 = rCygwQHbwKcsfJaniSLXidYCJ47281848;     rCygwQHbwKcsfJaniSLXidYCJ47281848 = rCygwQHbwKcsfJaniSLXidYCJ3041820;     rCygwQHbwKcsfJaniSLXidYCJ3041820 = rCygwQHbwKcsfJaniSLXidYCJ62337409;     rCygwQHbwKcsfJaniSLXidYCJ62337409 = rCygwQHbwKcsfJaniSLXidYCJ46849608;     rCygwQHbwKcsfJaniSLXidYCJ46849608 = rCygwQHbwKcsfJaniSLXidYCJ73117449;     rCygwQHbwKcsfJaniSLXidYCJ73117449 = rCygwQHbwKcsfJaniSLXidYCJ71970079;     rCygwQHbwKcsfJaniSLXidYCJ71970079 = rCygwQHbwKcsfJaniSLXidYCJ93506334;     rCygwQHbwKcsfJaniSLXidYCJ93506334 = rCygwQHbwKcsfJaniSLXidYCJ37313103;     rCygwQHbwKcsfJaniSLXidYCJ37313103 = rCygwQHbwKcsfJaniSLXidYCJ35580986;     rCygwQHbwKcsfJaniSLXidYCJ35580986 = rCygwQHbwKcsfJaniSLXidYCJ13357550;     rCygwQHbwKcsfJaniSLXidYCJ13357550 = rCygwQHbwKcsfJaniSLXidYCJ39632751;     rCygwQHbwKcsfJaniSLXidYCJ39632751 = rCygwQHbwKcsfJaniSLXidYCJ282460;     rCygwQHbwKcsfJaniSLXidYCJ282460 = rCygwQHbwKcsfJaniSLXidYCJ28481802;     rCygwQHbwKcsfJaniSLXidYCJ28481802 = rCygwQHbwKcsfJaniSLXidYCJ48261836;     rCygwQHbwKcsfJaniSLXidYCJ48261836 = rCygwQHbwKcsfJaniSLXidYCJ88239591;     rCygwQHbwKcsfJaniSLXidYCJ88239591 = rCygwQHbwKcsfJaniSLXidYCJ74415205;     rCygwQHbwKcsfJaniSLXidYCJ74415205 = rCygwQHbwKcsfJaniSLXidYCJ77737406;     rCygwQHbwKcsfJaniSLXidYCJ77737406 = rCygwQHbwKcsfJaniSLXidYCJ69004234;     rCygwQHbwKcsfJaniSLXidYCJ69004234 = rCygwQHbwKcsfJaniSLXidYCJ69565463;     rCygwQHbwKcsfJaniSLXidYCJ69565463 = rCygwQHbwKcsfJaniSLXidYCJ1348784;     rCygwQHbwKcsfJaniSLXidYCJ1348784 = rCygwQHbwKcsfJaniSLXidYCJ93704204;     rCygwQHbwKcsfJaniSLXidYCJ93704204 = rCygwQHbwKcsfJaniSLXidYCJ6905411;     rCygwQHbwKcsfJaniSLXidYCJ6905411 = rCygwQHbwKcsfJaniSLXidYCJ37913958;     rCygwQHbwKcsfJaniSLXidYCJ37913958 = rCygwQHbwKcsfJaniSLXidYCJ16782234;     rCygwQHbwKcsfJaniSLXidYCJ16782234 = rCygwQHbwKcsfJaniSLXidYCJ53978889;     rCygwQHbwKcsfJaniSLXidYCJ53978889 = rCygwQHbwKcsfJaniSLXidYCJ22141823;     rCygwQHbwKcsfJaniSLXidYCJ22141823 = rCygwQHbwKcsfJaniSLXidYCJ78452483;     rCygwQHbwKcsfJaniSLXidYCJ78452483 = rCygwQHbwKcsfJaniSLXidYCJ56902294;     rCygwQHbwKcsfJaniSLXidYCJ56902294 = rCygwQHbwKcsfJaniSLXidYCJ68227168;     rCygwQHbwKcsfJaniSLXidYCJ68227168 = rCygwQHbwKcsfJaniSLXidYCJ54452833;     rCygwQHbwKcsfJaniSLXidYCJ54452833 = rCygwQHbwKcsfJaniSLXidYCJ22058453;     rCygwQHbwKcsfJaniSLXidYCJ22058453 = rCygwQHbwKcsfJaniSLXidYCJ50072485;     rCygwQHbwKcsfJaniSLXidYCJ50072485 = rCygwQHbwKcsfJaniSLXidYCJ25535187;     rCygwQHbwKcsfJaniSLXidYCJ25535187 = rCygwQHbwKcsfJaniSLXidYCJ91759460;     rCygwQHbwKcsfJaniSLXidYCJ91759460 = rCygwQHbwKcsfJaniSLXidYCJ36112585;     rCygwQHbwKcsfJaniSLXidYCJ36112585 = rCygwQHbwKcsfJaniSLXidYCJ74488269;     rCygwQHbwKcsfJaniSLXidYCJ74488269 = rCygwQHbwKcsfJaniSLXidYCJ30917546;     rCygwQHbwKcsfJaniSLXidYCJ30917546 = rCygwQHbwKcsfJaniSLXidYCJ93265913;     rCygwQHbwKcsfJaniSLXidYCJ93265913 = rCygwQHbwKcsfJaniSLXidYCJ58439051;     rCygwQHbwKcsfJaniSLXidYCJ58439051 = rCygwQHbwKcsfJaniSLXidYCJ68498786;     rCygwQHbwKcsfJaniSLXidYCJ68498786 = rCygwQHbwKcsfJaniSLXidYCJ90032112;     rCygwQHbwKcsfJaniSLXidYCJ90032112 = rCygwQHbwKcsfJaniSLXidYCJ16879073;     rCygwQHbwKcsfJaniSLXidYCJ16879073 = rCygwQHbwKcsfJaniSLXidYCJ31994055;     rCygwQHbwKcsfJaniSLXidYCJ31994055 = rCygwQHbwKcsfJaniSLXidYCJ57021280;     rCygwQHbwKcsfJaniSLXidYCJ57021280 = rCygwQHbwKcsfJaniSLXidYCJ69642442;     rCygwQHbwKcsfJaniSLXidYCJ69642442 = rCygwQHbwKcsfJaniSLXidYCJ9299982;     rCygwQHbwKcsfJaniSLXidYCJ9299982 = rCygwQHbwKcsfJaniSLXidYCJ5740016;     rCygwQHbwKcsfJaniSLXidYCJ5740016 = rCygwQHbwKcsfJaniSLXidYCJ7226851;     rCygwQHbwKcsfJaniSLXidYCJ7226851 = rCygwQHbwKcsfJaniSLXidYCJ20509104;     rCygwQHbwKcsfJaniSLXidYCJ20509104 = rCygwQHbwKcsfJaniSLXidYCJ81172506;     rCygwQHbwKcsfJaniSLXidYCJ81172506 = rCygwQHbwKcsfJaniSLXidYCJ81637651;     rCygwQHbwKcsfJaniSLXidYCJ81637651 = rCygwQHbwKcsfJaniSLXidYCJ4220869;     rCygwQHbwKcsfJaniSLXidYCJ4220869 = rCygwQHbwKcsfJaniSLXidYCJ31136221;     rCygwQHbwKcsfJaniSLXidYCJ31136221 = rCygwQHbwKcsfJaniSLXidYCJ97002358;     rCygwQHbwKcsfJaniSLXidYCJ97002358 = rCygwQHbwKcsfJaniSLXidYCJ36978056;     rCygwQHbwKcsfJaniSLXidYCJ36978056 = rCygwQHbwKcsfJaniSLXidYCJ40376437;     rCygwQHbwKcsfJaniSLXidYCJ40376437 = rCygwQHbwKcsfJaniSLXidYCJ65127861;     rCygwQHbwKcsfJaniSLXidYCJ65127861 = rCygwQHbwKcsfJaniSLXidYCJ45555175;     rCygwQHbwKcsfJaniSLXidYCJ45555175 = rCygwQHbwKcsfJaniSLXidYCJ92870719;     rCygwQHbwKcsfJaniSLXidYCJ92870719 = rCygwQHbwKcsfJaniSLXidYCJ50975627;     rCygwQHbwKcsfJaniSLXidYCJ50975627 = rCygwQHbwKcsfJaniSLXidYCJ93517596;     rCygwQHbwKcsfJaniSLXidYCJ93517596 = rCygwQHbwKcsfJaniSLXidYCJ36604041;     rCygwQHbwKcsfJaniSLXidYCJ36604041 = rCygwQHbwKcsfJaniSLXidYCJ69085934;     rCygwQHbwKcsfJaniSLXidYCJ69085934 = rCygwQHbwKcsfJaniSLXidYCJ81128152;     rCygwQHbwKcsfJaniSLXidYCJ81128152 = rCygwQHbwKcsfJaniSLXidYCJ91299096;     rCygwQHbwKcsfJaniSLXidYCJ91299096 = rCygwQHbwKcsfJaniSLXidYCJ89560265;     rCygwQHbwKcsfJaniSLXidYCJ89560265 = rCygwQHbwKcsfJaniSLXidYCJ74747272;     rCygwQHbwKcsfJaniSLXidYCJ74747272 = rCygwQHbwKcsfJaniSLXidYCJ36722341;     rCygwQHbwKcsfJaniSLXidYCJ36722341 = rCygwQHbwKcsfJaniSLXidYCJ26057427;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void lKbnIlfUEYKVaIUOewYtcKPmSOvVQNiOlFfxlLulixHbskMEaeVgqjYau75584387() {     long oVupJEqqwjUdWcTBnKeCouhBr61516395 = -232635145;    long oVupJEqqwjUdWcTBnKeCouhBr76833408 = -729287072;    long oVupJEqqwjUdWcTBnKeCouhBr93750116 = -187192812;    long oVupJEqqwjUdWcTBnKeCouhBr6164525 = -991964656;    long oVupJEqqwjUdWcTBnKeCouhBr21936257 = -989381841;    long oVupJEqqwjUdWcTBnKeCouhBr60037753 = -150614448;    long oVupJEqqwjUdWcTBnKeCouhBr24485297 = -720242356;    long oVupJEqqwjUdWcTBnKeCouhBr57415116 = -899157685;    long oVupJEqqwjUdWcTBnKeCouhBr52291775 = -664306500;    long oVupJEqqwjUdWcTBnKeCouhBr38789041 = -874867542;    long oVupJEqqwjUdWcTBnKeCouhBr60623456 = -283470019;    long oVupJEqqwjUdWcTBnKeCouhBr83962581 = -372652789;    long oVupJEqqwjUdWcTBnKeCouhBr15764734 = -271592635;    long oVupJEqqwjUdWcTBnKeCouhBr46395818 = -192881450;    long oVupJEqqwjUdWcTBnKeCouhBr98310037 = -3099921;    long oVupJEqqwjUdWcTBnKeCouhBr15097802 = -778210326;    long oVupJEqqwjUdWcTBnKeCouhBr96304801 = -726007551;    long oVupJEqqwjUdWcTBnKeCouhBr83298638 = -877214639;    long oVupJEqqwjUdWcTBnKeCouhBr54742505 = -8264507;    long oVupJEqqwjUdWcTBnKeCouhBr61412259 = -12699946;    long oVupJEqqwjUdWcTBnKeCouhBr83465693 = -54679243;    long oVupJEqqwjUdWcTBnKeCouhBr12696718 = -33538665;    long oVupJEqqwjUdWcTBnKeCouhBr80107820 = -534667688;    long oVupJEqqwjUdWcTBnKeCouhBr28014763 = -571838535;    long oVupJEqqwjUdWcTBnKeCouhBr63506638 = 80361943;    long oVupJEqqwjUdWcTBnKeCouhBr19446866 = -606479132;    long oVupJEqqwjUdWcTBnKeCouhBr16008287 = 18508952;    long oVupJEqqwjUdWcTBnKeCouhBr103483 = -582063382;    long oVupJEqqwjUdWcTBnKeCouhBr19893317 = 51629720;    long oVupJEqqwjUdWcTBnKeCouhBr6235095 = -474982245;    long oVupJEqqwjUdWcTBnKeCouhBr16934373 = -829036464;    long oVupJEqqwjUdWcTBnKeCouhBr68505279 = -992067474;    long oVupJEqqwjUdWcTBnKeCouhBr59499858 = -767516183;    long oVupJEqqwjUdWcTBnKeCouhBr32790246 = -305499392;    long oVupJEqqwjUdWcTBnKeCouhBr28145863 = 94753351;    long oVupJEqqwjUdWcTBnKeCouhBr98410451 = -40229705;    long oVupJEqqwjUdWcTBnKeCouhBr22529266 = -450272731;    long oVupJEqqwjUdWcTBnKeCouhBr23185483 = 86172167;    long oVupJEqqwjUdWcTBnKeCouhBr23896896 = -720663728;    long oVupJEqqwjUdWcTBnKeCouhBr1584635 = -134497570;    long oVupJEqqwjUdWcTBnKeCouhBr69032593 = -926656355;    long oVupJEqqwjUdWcTBnKeCouhBr2722677 = 67136871;    long oVupJEqqwjUdWcTBnKeCouhBr29016130 = -933064885;    long oVupJEqqwjUdWcTBnKeCouhBr40413798 = -677745398;    long oVupJEqqwjUdWcTBnKeCouhBr28498261 = -843941943;    long oVupJEqqwjUdWcTBnKeCouhBr94223164 = -508813706;    long oVupJEqqwjUdWcTBnKeCouhBr7584755 = -3674340;    long oVupJEqqwjUdWcTBnKeCouhBr92141517 = -921314995;    long oVupJEqqwjUdWcTBnKeCouhBr630073 = -661417529;    long oVupJEqqwjUdWcTBnKeCouhBr93533823 = -588682826;    long oVupJEqqwjUdWcTBnKeCouhBr50336187 = -782833880;    long oVupJEqqwjUdWcTBnKeCouhBr84834255 = -405575716;    long oVupJEqqwjUdWcTBnKeCouhBr62325353 = 20818452;    long oVupJEqqwjUdWcTBnKeCouhBr22897257 = -683149624;    long oVupJEqqwjUdWcTBnKeCouhBr92118694 = -445139838;    long oVupJEqqwjUdWcTBnKeCouhBr48819678 = -99096480;    long oVupJEqqwjUdWcTBnKeCouhBr96725587 = -94619384;    long oVupJEqqwjUdWcTBnKeCouhBr65735354 = -615354277;    long oVupJEqqwjUdWcTBnKeCouhBr42657887 = -972326599;    long oVupJEqqwjUdWcTBnKeCouhBr2489392 = -282902709;    long oVupJEqqwjUdWcTBnKeCouhBr44029467 = -69123400;    long oVupJEqqwjUdWcTBnKeCouhBr24381815 = -38178974;    long oVupJEqqwjUdWcTBnKeCouhBr37521800 = -850787405;    long oVupJEqqwjUdWcTBnKeCouhBr46056680 = -89324255;    long oVupJEqqwjUdWcTBnKeCouhBr21854668 = 54168922;    long oVupJEqqwjUdWcTBnKeCouhBr92118176 = -291402546;    long oVupJEqqwjUdWcTBnKeCouhBr24462723 = -605136607;    long oVupJEqqwjUdWcTBnKeCouhBr82974488 = -966093243;    long oVupJEqqwjUdWcTBnKeCouhBr18249955 = -187634802;    long oVupJEqqwjUdWcTBnKeCouhBr99899586 = -962870217;    long oVupJEqqwjUdWcTBnKeCouhBr92568535 = -227937596;    long oVupJEqqwjUdWcTBnKeCouhBr73119319 = -712179719;    long oVupJEqqwjUdWcTBnKeCouhBr59401743 = -56550911;    long oVupJEqqwjUdWcTBnKeCouhBr53157870 = -873766938;    long oVupJEqqwjUdWcTBnKeCouhBr92379666 = -86043591;    long oVupJEqqwjUdWcTBnKeCouhBr80743016 = -21816115;    long oVupJEqqwjUdWcTBnKeCouhBr83680588 = -100473780;    long oVupJEqqwjUdWcTBnKeCouhBr39694023 = -856922290;    long oVupJEqqwjUdWcTBnKeCouhBr99516502 = -727896592;    long oVupJEqqwjUdWcTBnKeCouhBr69283473 = -410824352;    long oVupJEqqwjUdWcTBnKeCouhBr11862112 = -502804793;    long oVupJEqqwjUdWcTBnKeCouhBr23866769 = -60176053;    long oVupJEqqwjUdWcTBnKeCouhBr99473410 = -920645854;    long oVupJEqqwjUdWcTBnKeCouhBr26359494 = -359687455;    long oVupJEqqwjUdWcTBnKeCouhBr55898908 = -692148365;    long oVupJEqqwjUdWcTBnKeCouhBr32100117 = -323460748;    long oVupJEqqwjUdWcTBnKeCouhBr6179927 = -912885926;    long oVupJEqqwjUdWcTBnKeCouhBr36602602 = 15633441;    long oVupJEqqwjUdWcTBnKeCouhBr40671551 = -860359555;    long oVupJEqqwjUdWcTBnKeCouhBr79326185 = -806150169;    long oVupJEqqwjUdWcTBnKeCouhBr1684865 = -945610321;    long oVupJEqqwjUdWcTBnKeCouhBr56793911 = -834918454;    long oVupJEqqwjUdWcTBnKeCouhBr80527596 = 58498766;    long oVupJEqqwjUdWcTBnKeCouhBr21407505 = -337761020;    long oVupJEqqwjUdWcTBnKeCouhBr57555168 = 34625830;    long oVupJEqqwjUdWcTBnKeCouhBr44650779 = -788477381;    long oVupJEqqwjUdWcTBnKeCouhBr65200877 = -82075724;    long oVupJEqqwjUdWcTBnKeCouhBr82959449 = -743740630;    long oVupJEqqwjUdWcTBnKeCouhBr18559130 = -631914321;    long oVupJEqqwjUdWcTBnKeCouhBr36380084 = -232635145;     oVupJEqqwjUdWcTBnKeCouhBr61516395 = oVupJEqqwjUdWcTBnKeCouhBr76833408;     oVupJEqqwjUdWcTBnKeCouhBr76833408 = oVupJEqqwjUdWcTBnKeCouhBr93750116;     oVupJEqqwjUdWcTBnKeCouhBr93750116 = oVupJEqqwjUdWcTBnKeCouhBr6164525;     oVupJEqqwjUdWcTBnKeCouhBr6164525 = oVupJEqqwjUdWcTBnKeCouhBr21936257;     oVupJEqqwjUdWcTBnKeCouhBr21936257 = oVupJEqqwjUdWcTBnKeCouhBr60037753;     oVupJEqqwjUdWcTBnKeCouhBr60037753 = oVupJEqqwjUdWcTBnKeCouhBr24485297;     oVupJEqqwjUdWcTBnKeCouhBr24485297 = oVupJEqqwjUdWcTBnKeCouhBr57415116;     oVupJEqqwjUdWcTBnKeCouhBr57415116 = oVupJEqqwjUdWcTBnKeCouhBr52291775;     oVupJEqqwjUdWcTBnKeCouhBr52291775 = oVupJEqqwjUdWcTBnKeCouhBr38789041;     oVupJEqqwjUdWcTBnKeCouhBr38789041 = oVupJEqqwjUdWcTBnKeCouhBr60623456;     oVupJEqqwjUdWcTBnKeCouhBr60623456 = oVupJEqqwjUdWcTBnKeCouhBr83962581;     oVupJEqqwjUdWcTBnKeCouhBr83962581 = oVupJEqqwjUdWcTBnKeCouhBr15764734;     oVupJEqqwjUdWcTBnKeCouhBr15764734 = oVupJEqqwjUdWcTBnKeCouhBr46395818;     oVupJEqqwjUdWcTBnKeCouhBr46395818 = oVupJEqqwjUdWcTBnKeCouhBr98310037;     oVupJEqqwjUdWcTBnKeCouhBr98310037 = oVupJEqqwjUdWcTBnKeCouhBr15097802;     oVupJEqqwjUdWcTBnKeCouhBr15097802 = oVupJEqqwjUdWcTBnKeCouhBr96304801;     oVupJEqqwjUdWcTBnKeCouhBr96304801 = oVupJEqqwjUdWcTBnKeCouhBr83298638;     oVupJEqqwjUdWcTBnKeCouhBr83298638 = oVupJEqqwjUdWcTBnKeCouhBr54742505;     oVupJEqqwjUdWcTBnKeCouhBr54742505 = oVupJEqqwjUdWcTBnKeCouhBr61412259;     oVupJEqqwjUdWcTBnKeCouhBr61412259 = oVupJEqqwjUdWcTBnKeCouhBr83465693;     oVupJEqqwjUdWcTBnKeCouhBr83465693 = oVupJEqqwjUdWcTBnKeCouhBr12696718;     oVupJEqqwjUdWcTBnKeCouhBr12696718 = oVupJEqqwjUdWcTBnKeCouhBr80107820;     oVupJEqqwjUdWcTBnKeCouhBr80107820 = oVupJEqqwjUdWcTBnKeCouhBr28014763;     oVupJEqqwjUdWcTBnKeCouhBr28014763 = oVupJEqqwjUdWcTBnKeCouhBr63506638;     oVupJEqqwjUdWcTBnKeCouhBr63506638 = oVupJEqqwjUdWcTBnKeCouhBr19446866;     oVupJEqqwjUdWcTBnKeCouhBr19446866 = oVupJEqqwjUdWcTBnKeCouhBr16008287;     oVupJEqqwjUdWcTBnKeCouhBr16008287 = oVupJEqqwjUdWcTBnKeCouhBr103483;     oVupJEqqwjUdWcTBnKeCouhBr103483 = oVupJEqqwjUdWcTBnKeCouhBr19893317;     oVupJEqqwjUdWcTBnKeCouhBr19893317 = oVupJEqqwjUdWcTBnKeCouhBr6235095;     oVupJEqqwjUdWcTBnKeCouhBr6235095 = oVupJEqqwjUdWcTBnKeCouhBr16934373;     oVupJEqqwjUdWcTBnKeCouhBr16934373 = oVupJEqqwjUdWcTBnKeCouhBr68505279;     oVupJEqqwjUdWcTBnKeCouhBr68505279 = oVupJEqqwjUdWcTBnKeCouhBr59499858;     oVupJEqqwjUdWcTBnKeCouhBr59499858 = oVupJEqqwjUdWcTBnKeCouhBr32790246;     oVupJEqqwjUdWcTBnKeCouhBr32790246 = oVupJEqqwjUdWcTBnKeCouhBr28145863;     oVupJEqqwjUdWcTBnKeCouhBr28145863 = oVupJEqqwjUdWcTBnKeCouhBr98410451;     oVupJEqqwjUdWcTBnKeCouhBr98410451 = oVupJEqqwjUdWcTBnKeCouhBr22529266;     oVupJEqqwjUdWcTBnKeCouhBr22529266 = oVupJEqqwjUdWcTBnKeCouhBr23185483;     oVupJEqqwjUdWcTBnKeCouhBr23185483 = oVupJEqqwjUdWcTBnKeCouhBr23896896;     oVupJEqqwjUdWcTBnKeCouhBr23896896 = oVupJEqqwjUdWcTBnKeCouhBr1584635;     oVupJEqqwjUdWcTBnKeCouhBr1584635 = oVupJEqqwjUdWcTBnKeCouhBr69032593;     oVupJEqqwjUdWcTBnKeCouhBr69032593 = oVupJEqqwjUdWcTBnKeCouhBr2722677;     oVupJEqqwjUdWcTBnKeCouhBr2722677 = oVupJEqqwjUdWcTBnKeCouhBr29016130;     oVupJEqqwjUdWcTBnKeCouhBr29016130 = oVupJEqqwjUdWcTBnKeCouhBr40413798;     oVupJEqqwjUdWcTBnKeCouhBr40413798 = oVupJEqqwjUdWcTBnKeCouhBr28498261;     oVupJEqqwjUdWcTBnKeCouhBr28498261 = oVupJEqqwjUdWcTBnKeCouhBr94223164;     oVupJEqqwjUdWcTBnKeCouhBr94223164 = oVupJEqqwjUdWcTBnKeCouhBr7584755;     oVupJEqqwjUdWcTBnKeCouhBr7584755 = oVupJEqqwjUdWcTBnKeCouhBr92141517;     oVupJEqqwjUdWcTBnKeCouhBr92141517 = oVupJEqqwjUdWcTBnKeCouhBr630073;     oVupJEqqwjUdWcTBnKeCouhBr630073 = oVupJEqqwjUdWcTBnKeCouhBr93533823;     oVupJEqqwjUdWcTBnKeCouhBr93533823 = oVupJEqqwjUdWcTBnKeCouhBr50336187;     oVupJEqqwjUdWcTBnKeCouhBr50336187 = oVupJEqqwjUdWcTBnKeCouhBr84834255;     oVupJEqqwjUdWcTBnKeCouhBr84834255 = oVupJEqqwjUdWcTBnKeCouhBr62325353;     oVupJEqqwjUdWcTBnKeCouhBr62325353 = oVupJEqqwjUdWcTBnKeCouhBr22897257;     oVupJEqqwjUdWcTBnKeCouhBr22897257 = oVupJEqqwjUdWcTBnKeCouhBr92118694;     oVupJEqqwjUdWcTBnKeCouhBr92118694 = oVupJEqqwjUdWcTBnKeCouhBr48819678;     oVupJEqqwjUdWcTBnKeCouhBr48819678 = oVupJEqqwjUdWcTBnKeCouhBr96725587;     oVupJEqqwjUdWcTBnKeCouhBr96725587 = oVupJEqqwjUdWcTBnKeCouhBr65735354;     oVupJEqqwjUdWcTBnKeCouhBr65735354 = oVupJEqqwjUdWcTBnKeCouhBr42657887;     oVupJEqqwjUdWcTBnKeCouhBr42657887 = oVupJEqqwjUdWcTBnKeCouhBr2489392;     oVupJEqqwjUdWcTBnKeCouhBr2489392 = oVupJEqqwjUdWcTBnKeCouhBr44029467;     oVupJEqqwjUdWcTBnKeCouhBr44029467 = oVupJEqqwjUdWcTBnKeCouhBr24381815;     oVupJEqqwjUdWcTBnKeCouhBr24381815 = oVupJEqqwjUdWcTBnKeCouhBr37521800;     oVupJEqqwjUdWcTBnKeCouhBr37521800 = oVupJEqqwjUdWcTBnKeCouhBr46056680;     oVupJEqqwjUdWcTBnKeCouhBr46056680 = oVupJEqqwjUdWcTBnKeCouhBr21854668;     oVupJEqqwjUdWcTBnKeCouhBr21854668 = oVupJEqqwjUdWcTBnKeCouhBr92118176;     oVupJEqqwjUdWcTBnKeCouhBr92118176 = oVupJEqqwjUdWcTBnKeCouhBr24462723;     oVupJEqqwjUdWcTBnKeCouhBr24462723 = oVupJEqqwjUdWcTBnKeCouhBr82974488;     oVupJEqqwjUdWcTBnKeCouhBr82974488 = oVupJEqqwjUdWcTBnKeCouhBr18249955;     oVupJEqqwjUdWcTBnKeCouhBr18249955 = oVupJEqqwjUdWcTBnKeCouhBr99899586;     oVupJEqqwjUdWcTBnKeCouhBr99899586 = oVupJEqqwjUdWcTBnKeCouhBr92568535;     oVupJEqqwjUdWcTBnKeCouhBr92568535 = oVupJEqqwjUdWcTBnKeCouhBr73119319;     oVupJEqqwjUdWcTBnKeCouhBr73119319 = oVupJEqqwjUdWcTBnKeCouhBr59401743;     oVupJEqqwjUdWcTBnKeCouhBr59401743 = oVupJEqqwjUdWcTBnKeCouhBr53157870;     oVupJEqqwjUdWcTBnKeCouhBr53157870 = oVupJEqqwjUdWcTBnKeCouhBr92379666;     oVupJEqqwjUdWcTBnKeCouhBr92379666 = oVupJEqqwjUdWcTBnKeCouhBr80743016;     oVupJEqqwjUdWcTBnKeCouhBr80743016 = oVupJEqqwjUdWcTBnKeCouhBr83680588;     oVupJEqqwjUdWcTBnKeCouhBr83680588 = oVupJEqqwjUdWcTBnKeCouhBr39694023;     oVupJEqqwjUdWcTBnKeCouhBr39694023 = oVupJEqqwjUdWcTBnKeCouhBr99516502;     oVupJEqqwjUdWcTBnKeCouhBr99516502 = oVupJEqqwjUdWcTBnKeCouhBr69283473;     oVupJEqqwjUdWcTBnKeCouhBr69283473 = oVupJEqqwjUdWcTBnKeCouhBr11862112;     oVupJEqqwjUdWcTBnKeCouhBr11862112 = oVupJEqqwjUdWcTBnKeCouhBr23866769;     oVupJEqqwjUdWcTBnKeCouhBr23866769 = oVupJEqqwjUdWcTBnKeCouhBr99473410;     oVupJEqqwjUdWcTBnKeCouhBr99473410 = oVupJEqqwjUdWcTBnKeCouhBr26359494;     oVupJEqqwjUdWcTBnKeCouhBr26359494 = oVupJEqqwjUdWcTBnKeCouhBr55898908;     oVupJEqqwjUdWcTBnKeCouhBr55898908 = oVupJEqqwjUdWcTBnKeCouhBr32100117;     oVupJEqqwjUdWcTBnKeCouhBr32100117 = oVupJEqqwjUdWcTBnKeCouhBr6179927;     oVupJEqqwjUdWcTBnKeCouhBr6179927 = oVupJEqqwjUdWcTBnKeCouhBr36602602;     oVupJEqqwjUdWcTBnKeCouhBr36602602 = oVupJEqqwjUdWcTBnKeCouhBr40671551;     oVupJEqqwjUdWcTBnKeCouhBr40671551 = oVupJEqqwjUdWcTBnKeCouhBr79326185;     oVupJEqqwjUdWcTBnKeCouhBr79326185 = oVupJEqqwjUdWcTBnKeCouhBr1684865;     oVupJEqqwjUdWcTBnKeCouhBr1684865 = oVupJEqqwjUdWcTBnKeCouhBr56793911;     oVupJEqqwjUdWcTBnKeCouhBr56793911 = oVupJEqqwjUdWcTBnKeCouhBr80527596;     oVupJEqqwjUdWcTBnKeCouhBr80527596 = oVupJEqqwjUdWcTBnKeCouhBr21407505;     oVupJEqqwjUdWcTBnKeCouhBr21407505 = oVupJEqqwjUdWcTBnKeCouhBr57555168;     oVupJEqqwjUdWcTBnKeCouhBr57555168 = oVupJEqqwjUdWcTBnKeCouhBr44650779;     oVupJEqqwjUdWcTBnKeCouhBr44650779 = oVupJEqqwjUdWcTBnKeCouhBr65200877;     oVupJEqqwjUdWcTBnKeCouhBr65200877 = oVupJEqqwjUdWcTBnKeCouhBr82959449;     oVupJEqqwjUdWcTBnKeCouhBr82959449 = oVupJEqqwjUdWcTBnKeCouhBr18559130;     oVupJEqqwjUdWcTBnKeCouhBr18559130 = oVupJEqqwjUdWcTBnKeCouhBr36380084;     oVupJEqqwjUdWcTBnKeCouhBr36380084 = oVupJEqqwjUdWcTBnKeCouhBr61516395;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void OmdadhMuLxNjjApblltNTakOdKKijYqqLQQIrRkjhdsGXVqPMHqYjsInC90633455() {     long OwTXeLmGXYTkgjUBJfpidrHUu67633502 = -344537033;    long OwTXeLmGXYTkgjUBJfpidrHUu20206688 = -438886853;    long OwTXeLmGXYTkgjUBJfpidrHUu9792301 = -338025733;    long OwTXeLmGXYTkgjUBJfpidrHUu33239306 = -82713287;    long OwTXeLmGXYTkgjUBJfpidrHUu90831745 = -410031712;    long OwTXeLmGXYTkgjUBJfpidrHUu51454955 = -415110683;    long OwTXeLmGXYTkgjUBJfpidrHUu84974263 = -859207333;    long OwTXeLmGXYTkgjUBJfpidrHUu7175008 = -86031598;    long OwTXeLmGXYTkgjUBJfpidrHUu16934270 = -432339165;    long OwTXeLmGXYTkgjUBJfpidrHUu80018700 = -103843019;    long OwTXeLmGXYTkgjUBJfpidrHUu20733747 = -160907606;    long OwTXeLmGXYTkgjUBJfpidrHUu15785624 = -817058991;    long OwTXeLmGXYTkgjUBJfpidrHUu1973853 = -711483723;    long OwTXeLmGXYTkgjUBJfpidrHUu29539495 = -725120018;    long OwTXeLmGXYTkgjUBJfpidrHUu94052464 = -693562088;    long OwTXeLmGXYTkgjUBJfpidrHUu56603195 = -751209869;    long OwTXeLmGXYTkgjUBJfpidrHUu90140805 = -242552664;    long OwTXeLmGXYTkgjUBJfpidrHUu80351791 = -542737281;    long OwTXeLmGXYTkgjUBJfpidrHUu16572347 = -414033604;    long OwTXeLmGXYTkgjUBJfpidrHUu41962424 = -369602865;    long OwTXeLmGXYTkgjUBJfpidrHUu72018886 = 89833301;    long OwTXeLmGXYTkgjUBJfpidrHUu99217741 = 58531619;    long OwTXeLmGXYTkgjUBJfpidrHUu15698613 = -281185175;    long OwTXeLmGXYTkgjUBJfpidrHUu12007137 = -794143523;    long OwTXeLmGXYTkgjUBJfpidrHUu7206288 = -292834090;    long OwTXeLmGXYTkgjUBJfpidrHUu44168541 = -485134456;    long OwTXeLmGXYTkgjUBJfpidrHUu14468065 = -982153251;    long OwTXeLmGXYTkgjUBJfpidrHUu13210608 = -647992336;    long OwTXeLmGXYTkgjUBJfpidrHUu86025572 = -170752984;    long OwTXeLmGXYTkgjUBJfpidrHUu74850731 = -292453112;    long OwTXeLmGXYTkgjUBJfpidrHUu9176923 = -742357402;    long OwTXeLmGXYTkgjUBJfpidrHUu66115901 = -701514290;    long OwTXeLmGXYTkgjUBJfpidrHUu69210807 = -660129553;    long OwTXeLmGXYTkgjUBJfpidrHUu27620810 = -57041157;    long OwTXeLmGXYTkgjUBJfpidrHUu89620514 = -543979754;    long OwTXeLmGXYTkgjUBJfpidrHUu67136365 = -254255813;    long OwTXeLmGXYTkgjUBJfpidrHUu3791201 = -403908601;    long OwTXeLmGXYTkgjUBJfpidrHUu57275695 = -785333843;    long OwTXeLmGXYTkgjUBJfpidrHUu97507149 = -714587225;    long OwTXeLmGXYTkgjUBJfpidrHUu89086572 = -607936792;    long OwTXeLmGXYTkgjUBJfpidrHUu74701817 = -991930249;    long OwTXeLmGXYTkgjUBJfpidrHUu34873133 = -203005407;    long OwTXeLmGXYTkgjUBJfpidrHUu7083108 = 86130531;    long OwTXeLmGXYTkgjUBJfpidrHUu27821538 = -697088337;    long OwTXeLmGXYTkgjUBJfpidrHUu40450725 = -505840098;    long OwTXeLmGXYTkgjUBJfpidrHUu6162360 = -494029823;    long OwTXeLmGXYTkgjUBJfpidrHUu25363329 = -122449877;    long OwTXeLmGXYTkgjUBJfpidrHUu98459 = -931210528;    long OwTXeLmGXYTkgjUBJfpidrHUu10305801 = -747154517;    long OwTXeLmGXYTkgjUBJfpidrHUu6445476 = -675693634;    long OwTXeLmGXYTkgjUBJfpidrHUu86036865 = -625127552;    long OwTXeLmGXYTkgjUBJfpidrHUu95643975 = -206302036;    long OwTXeLmGXYTkgjUBJfpidrHUu10573811 = -870971136;    long OwTXeLmGXYTkgjUBJfpidrHUu18866138 = 96380231;    long OwTXeLmGXYTkgjUBJfpidrHUu18614570 = -45671620;    long OwTXeLmGXYTkgjUBJfpidrHUu68415760 = -303068653;    long OwTXeLmGXYTkgjUBJfpidrHUu4508075 = -57701678;    long OwTXeLmGXYTkgjUBJfpidrHUu97785163 = -543882211;    long OwTXeLmGXYTkgjUBJfpidrHUu26033018 = -789879197;    long OwTXeLmGXYTkgjUBJfpidrHUu46663204 = -924897257;    long OwTXeLmGXYTkgjUBJfpidrHUu36986891 = -432957432;    long OwTXeLmGXYTkgjUBJfpidrHUu71763655 = -111214998;    long OwTXeLmGXYTkgjUBJfpidrHUu21149435 = -915278614;    long OwTXeLmGXYTkgjUBJfpidrHUu42083538 = -39886054;    long OwTXeLmGXYTkgjUBJfpidrHUu70841777 = -361485618;    long OwTXeLmGXYTkgjUBJfpidrHUu54617845 = -459393317;    long OwTXeLmGXYTkgjUBJfpidrHUu46574817 = -56929439;    long OwTXeLmGXYTkgjUBJfpidrHUu74353043 = -554442567;    long OwTXeLmGXYTkgjUBJfpidrHUu39918980 = -81140264;    long OwTXeLmGXYTkgjUBJfpidrHUu26916100 = -339306276;    long OwTXeLmGXYTkgjUBJfpidrHUu52811995 = -247301269;    long OwTXeLmGXYTkgjUBJfpidrHUu32865110 = -457218822;    long OwTXeLmGXYTkgjUBJfpidrHUu82844642 = -828150057;    long OwTXeLmGXYTkgjUBJfpidrHUu27485774 = -806096812;    long OwTXeLmGXYTkgjUBJfpidrHUu67260607 = -377672616;    long OwTXeLmGXYTkgjUBJfpidrHUu37145753 = -707161292;    long OwTXeLmGXYTkgjUBJfpidrHUu92134633 = 72401087;    long OwTXeLmGXYTkgjUBJfpidrHUu87877074 = -584096839;    long OwTXeLmGXYTkgjUBJfpidrHUu71556411 = -188303426;    long OwTXeLmGXYTkgjUBJfpidrHUu1043929 = -798804268;    long OwTXeLmGXYTkgjUBJfpidrHUu18805213 = -262684579;    long OwTXeLmGXYTkgjUBJfpidrHUu14369606 = 49057276;    long OwTXeLmGXYTkgjUBJfpidrHUu2904807 = -900837820;    long OwTXeLmGXYTkgjUBJfpidrHUu79580096 = -495059351;    long OwTXeLmGXYTkgjUBJfpidrHUu88813866 = -667325561;    long OwTXeLmGXYTkgjUBJfpidrHUu13532947 = -436055366;    long OwTXeLmGXYTkgjUBJfpidrHUu55542091 = -830543154;    long OwTXeLmGXYTkgjUBJfpidrHUu50344670 = -656509785;    long OwTXeLmGXYTkgjUBJfpidrHUu9006241 = 88630462;    long OwTXeLmGXYTkgjUBJfpidrHUu21204755 = -140911102;    long OwTXeLmGXYTkgjUBJfpidrHUu62628290 = -96554135;    long OwTXeLmGXYTkgjUBJfpidrHUu6006037 = -860026391;    long OwTXeLmGXYTkgjUBJfpidrHUu31242678 = -995454647;    long OwTXeLmGXYTkgjUBJfpidrHUu50843945 = -789689969;    long OwTXeLmGXYTkgjUBJfpidrHUu52099682 = -74979360;    long OwTXeLmGXYTkgjUBJfpidrHUu2938163 = -780715252;    long OwTXeLmGXYTkgjUBJfpidrHUu13723699 = -287726794;    long OwTXeLmGXYTkgjUBJfpidrHUu64999569 = -873983416;    long OwTXeLmGXYTkgjUBJfpidrHUu56979761 = -235602719;    long OwTXeLmGXYTkgjUBJfpidrHUu85832880 = -344537033;     OwTXeLmGXYTkgjUBJfpidrHUu67633502 = OwTXeLmGXYTkgjUBJfpidrHUu20206688;     OwTXeLmGXYTkgjUBJfpidrHUu20206688 = OwTXeLmGXYTkgjUBJfpidrHUu9792301;     OwTXeLmGXYTkgjUBJfpidrHUu9792301 = OwTXeLmGXYTkgjUBJfpidrHUu33239306;     OwTXeLmGXYTkgjUBJfpidrHUu33239306 = OwTXeLmGXYTkgjUBJfpidrHUu90831745;     OwTXeLmGXYTkgjUBJfpidrHUu90831745 = OwTXeLmGXYTkgjUBJfpidrHUu51454955;     OwTXeLmGXYTkgjUBJfpidrHUu51454955 = OwTXeLmGXYTkgjUBJfpidrHUu84974263;     OwTXeLmGXYTkgjUBJfpidrHUu84974263 = OwTXeLmGXYTkgjUBJfpidrHUu7175008;     OwTXeLmGXYTkgjUBJfpidrHUu7175008 = OwTXeLmGXYTkgjUBJfpidrHUu16934270;     OwTXeLmGXYTkgjUBJfpidrHUu16934270 = OwTXeLmGXYTkgjUBJfpidrHUu80018700;     OwTXeLmGXYTkgjUBJfpidrHUu80018700 = OwTXeLmGXYTkgjUBJfpidrHUu20733747;     OwTXeLmGXYTkgjUBJfpidrHUu20733747 = OwTXeLmGXYTkgjUBJfpidrHUu15785624;     OwTXeLmGXYTkgjUBJfpidrHUu15785624 = OwTXeLmGXYTkgjUBJfpidrHUu1973853;     OwTXeLmGXYTkgjUBJfpidrHUu1973853 = OwTXeLmGXYTkgjUBJfpidrHUu29539495;     OwTXeLmGXYTkgjUBJfpidrHUu29539495 = OwTXeLmGXYTkgjUBJfpidrHUu94052464;     OwTXeLmGXYTkgjUBJfpidrHUu94052464 = OwTXeLmGXYTkgjUBJfpidrHUu56603195;     OwTXeLmGXYTkgjUBJfpidrHUu56603195 = OwTXeLmGXYTkgjUBJfpidrHUu90140805;     OwTXeLmGXYTkgjUBJfpidrHUu90140805 = OwTXeLmGXYTkgjUBJfpidrHUu80351791;     OwTXeLmGXYTkgjUBJfpidrHUu80351791 = OwTXeLmGXYTkgjUBJfpidrHUu16572347;     OwTXeLmGXYTkgjUBJfpidrHUu16572347 = OwTXeLmGXYTkgjUBJfpidrHUu41962424;     OwTXeLmGXYTkgjUBJfpidrHUu41962424 = OwTXeLmGXYTkgjUBJfpidrHUu72018886;     OwTXeLmGXYTkgjUBJfpidrHUu72018886 = OwTXeLmGXYTkgjUBJfpidrHUu99217741;     OwTXeLmGXYTkgjUBJfpidrHUu99217741 = OwTXeLmGXYTkgjUBJfpidrHUu15698613;     OwTXeLmGXYTkgjUBJfpidrHUu15698613 = OwTXeLmGXYTkgjUBJfpidrHUu12007137;     OwTXeLmGXYTkgjUBJfpidrHUu12007137 = OwTXeLmGXYTkgjUBJfpidrHUu7206288;     OwTXeLmGXYTkgjUBJfpidrHUu7206288 = OwTXeLmGXYTkgjUBJfpidrHUu44168541;     OwTXeLmGXYTkgjUBJfpidrHUu44168541 = OwTXeLmGXYTkgjUBJfpidrHUu14468065;     OwTXeLmGXYTkgjUBJfpidrHUu14468065 = OwTXeLmGXYTkgjUBJfpidrHUu13210608;     OwTXeLmGXYTkgjUBJfpidrHUu13210608 = OwTXeLmGXYTkgjUBJfpidrHUu86025572;     OwTXeLmGXYTkgjUBJfpidrHUu86025572 = OwTXeLmGXYTkgjUBJfpidrHUu74850731;     OwTXeLmGXYTkgjUBJfpidrHUu74850731 = OwTXeLmGXYTkgjUBJfpidrHUu9176923;     OwTXeLmGXYTkgjUBJfpidrHUu9176923 = OwTXeLmGXYTkgjUBJfpidrHUu66115901;     OwTXeLmGXYTkgjUBJfpidrHUu66115901 = OwTXeLmGXYTkgjUBJfpidrHUu69210807;     OwTXeLmGXYTkgjUBJfpidrHUu69210807 = OwTXeLmGXYTkgjUBJfpidrHUu27620810;     OwTXeLmGXYTkgjUBJfpidrHUu27620810 = OwTXeLmGXYTkgjUBJfpidrHUu89620514;     OwTXeLmGXYTkgjUBJfpidrHUu89620514 = OwTXeLmGXYTkgjUBJfpidrHUu67136365;     OwTXeLmGXYTkgjUBJfpidrHUu67136365 = OwTXeLmGXYTkgjUBJfpidrHUu3791201;     OwTXeLmGXYTkgjUBJfpidrHUu3791201 = OwTXeLmGXYTkgjUBJfpidrHUu57275695;     OwTXeLmGXYTkgjUBJfpidrHUu57275695 = OwTXeLmGXYTkgjUBJfpidrHUu97507149;     OwTXeLmGXYTkgjUBJfpidrHUu97507149 = OwTXeLmGXYTkgjUBJfpidrHUu89086572;     OwTXeLmGXYTkgjUBJfpidrHUu89086572 = OwTXeLmGXYTkgjUBJfpidrHUu74701817;     OwTXeLmGXYTkgjUBJfpidrHUu74701817 = OwTXeLmGXYTkgjUBJfpidrHUu34873133;     OwTXeLmGXYTkgjUBJfpidrHUu34873133 = OwTXeLmGXYTkgjUBJfpidrHUu7083108;     OwTXeLmGXYTkgjUBJfpidrHUu7083108 = OwTXeLmGXYTkgjUBJfpidrHUu27821538;     OwTXeLmGXYTkgjUBJfpidrHUu27821538 = OwTXeLmGXYTkgjUBJfpidrHUu40450725;     OwTXeLmGXYTkgjUBJfpidrHUu40450725 = OwTXeLmGXYTkgjUBJfpidrHUu6162360;     OwTXeLmGXYTkgjUBJfpidrHUu6162360 = OwTXeLmGXYTkgjUBJfpidrHUu25363329;     OwTXeLmGXYTkgjUBJfpidrHUu25363329 = OwTXeLmGXYTkgjUBJfpidrHUu98459;     OwTXeLmGXYTkgjUBJfpidrHUu98459 = OwTXeLmGXYTkgjUBJfpidrHUu10305801;     OwTXeLmGXYTkgjUBJfpidrHUu10305801 = OwTXeLmGXYTkgjUBJfpidrHUu6445476;     OwTXeLmGXYTkgjUBJfpidrHUu6445476 = OwTXeLmGXYTkgjUBJfpidrHUu86036865;     OwTXeLmGXYTkgjUBJfpidrHUu86036865 = OwTXeLmGXYTkgjUBJfpidrHUu95643975;     OwTXeLmGXYTkgjUBJfpidrHUu95643975 = OwTXeLmGXYTkgjUBJfpidrHUu10573811;     OwTXeLmGXYTkgjUBJfpidrHUu10573811 = OwTXeLmGXYTkgjUBJfpidrHUu18866138;     OwTXeLmGXYTkgjUBJfpidrHUu18866138 = OwTXeLmGXYTkgjUBJfpidrHUu18614570;     OwTXeLmGXYTkgjUBJfpidrHUu18614570 = OwTXeLmGXYTkgjUBJfpidrHUu68415760;     OwTXeLmGXYTkgjUBJfpidrHUu68415760 = OwTXeLmGXYTkgjUBJfpidrHUu4508075;     OwTXeLmGXYTkgjUBJfpidrHUu4508075 = OwTXeLmGXYTkgjUBJfpidrHUu97785163;     OwTXeLmGXYTkgjUBJfpidrHUu97785163 = OwTXeLmGXYTkgjUBJfpidrHUu26033018;     OwTXeLmGXYTkgjUBJfpidrHUu26033018 = OwTXeLmGXYTkgjUBJfpidrHUu46663204;     OwTXeLmGXYTkgjUBJfpidrHUu46663204 = OwTXeLmGXYTkgjUBJfpidrHUu36986891;     OwTXeLmGXYTkgjUBJfpidrHUu36986891 = OwTXeLmGXYTkgjUBJfpidrHUu71763655;     OwTXeLmGXYTkgjUBJfpidrHUu71763655 = OwTXeLmGXYTkgjUBJfpidrHUu21149435;     OwTXeLmGXYTkgjUBJfpidrHUu21149435 = OwTXeLmGXYTkgjUBJfpidrHUu42083538;     OwTXeLmGXYTkgjUBJfpidrHUu42083538 = OwTXeLmGXYTkgjUBJfpidrHUu70841777;     OwTXeLmGXYTkgjUBJfpidrHUu70841777 = OwTXeLmGXYTkgjUBJfpidrHUu54617845;     OwTXeLmGXYTkgjUBJfpidrHUu54617845 = OwTXeLmGXYTkgjUBJfpidrHUu46574817;     OwTXeLmGXYTkgjUBJfpidrHUu46574817 = OwTXeLmGXYTkgjUBJfpidrHUu74353043;     OwTXeLmGXYTkgjUBJfpidrHUu74353043 = OwTXeLmGXYTkgjUBJfpidrHUu39918980;     OwTXeLmGXYTkgjUBJfpidrHUu39918980 = OwTXeLmGXYTkgjUBJfpidrHUu26916100;     OwTXeLmGXYTkgjUBJfpidrHUu26916100 = OwTXeLmGXYTkgjUBJfpidrHUu52811995;     OwTXeLmGXYTkgjUBJfpidrHUu52811995 = OwTXeLmGXYTkgjUBJfpidrHUu32865110;     OwTXeLmGXYTkgjUBJfpidrHUu32865110 = OwTXeLmGXYTkgjUBJfpidrHUu82844642;     OwTXeLmGXYTkgjUBJfpidrHUu82844642 = OwTXeLmGXYTkgjUBJfpidrHUu27485774;     OwTXeLmGXYTkgjUBJfpidrHUu27485774 = OwTXeLmGXYTkgjUBJfpidrHUu67260607;     OwTXeLmGXYTkgjUBJfpidrHUu67260607 = OwTXeLmGXYTkgjUBJfpidrHUu37145753;     OwTXeLmGXYTkgjUBJfpidrHUu37145753 = OwTXeLmGXYTkgjUBJfpidrHUu92134633;     OwTXeLmGXYTkgjUBJfpidrHUu92134633 = OwTXeLmGXYTkgjUBJfpidrHUu87877074;     OwTXeLmGXYTkgjUBJfpidrHUu87877074 = OwTXeLmGXYTkgjUBJfpidrHUu71556411;     OwTXeLmGXYTkgjUBJfpidrHUu71556411 = OwTXeLmGXYTkgjUBJfpidrHUu1043929;     OwTXeLmGXYTkgjUBJfpidrHUu1043929 = OwTXeLmGXYTkgjUBJfpidrHUu18805213;     OwTXeLmGXYTkgjUBJfpidrHUu18805213 = OwTXeLmGXYTkgjUBJfpidrHUu14369606;     OwTXeLmGXYTkgjUBJfpidrHUu14369606 = OwTXeLmGXYTkgjUBJfpidrHUu2904807;     OwTXeLmGXYTkgjUBJfpidrHUu2904807 = OwTXeLmGXYTkgjUBJfpidrHUu79580096;     OwTXeLmGXYTkgjUBJfpidrHUu79580096 = OwTXeLmGXYTkgjUBJfpidrHUu88813866;     OwTXeLmGXYTkgjUBJfpidrHUu88813866 = OwTXeLmGXYTkgjUBJfpidrHUu13532947;     OwTXeLmGXYTkgjUBJfpidrHUu13532947 = OwTXeLmGXYTkgjUBJfpidrHUu55542091;     OwTXeLmGXYTkgjUBJfpidrHUu55542091 = OwTXeLmGXYTkgjUBJfpidrHUu50344670;     OwTXeLmGXYTkgjUBJfpidrHUu50344670 = OwTXeLmGXYTkgjUBJfpidrHUu9006241;     OwTXeLmGXYTkgjUBJfpidrHUu9006241 = OwTXeLmGXYTkgjUBJfpidrHUu21204755;     OwTXeLmGXYTkgjUBJfpidrHUu21204755 = OwTXeLmGXYTkgjUBJfpidrHUu62628290;     OwTXeLmGXYTkgjUBJfpidrHUu62628290 = OwTXeLmGXYTkgjUBJfpidrHUu6006037;     OwTXeLmGXYTkgjUBJfpidrHUu6006037 = OwTXeLmGXYTkgjUBJfpidrHUu31242678;     OwTXeLmGXYTkgjUBJfpidrHUu31242678 = OwTXeLmGXYTkgjUBJfpidrHUu50843945;     OwTXeLmGXYTkgjUBJfpidrHUu50843945 = OwTXeLmGXYTkgjUBJfpidrHUu52099682;     OwTXeLmGXYTkgjUBJfpidrHUu52099682 = OwTXeLmGXYTkgjUBJfpidrHUu2938163;     OwTXeLmGXYTkgjUBJfpidrHUu2938163 = OwTXeLmGXYTkgjUBJfpidrHUu13723699;     OwTXeLmGXYTkgjUBJfpidrHUu13723699 = OwTXeLmGXYTkgjUBJfpidrHUu64999569;     OwTXeLmGXYTkgjUBJfpidrHUu64999569 = OwTXeLmGXYTkgjUBJfpidrHUu56979761;     OwTXeLmGXYTkgjUBJfpidrHUu56979761 = OwTXeLmGXYTkgjUBJfpidrHUu85832880;     OwTXeLmGXYTkgjUBJfpidrHUu85832880 = OwTXeLmGXYTkgjUBJfpidrHUu67633502;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ZkXkTYqOHGGxBClLsEEbvRLAJABjiIFnuMNGWwToXkPEFwKgsujGYirHY57925055() {     long XbTXHfyBSDpoeovkQELCHuMqU3092471 = -810813933;    long XbTXHfyBSDpoeovkQELCHuMqU33478766 = -319438459;    long XbTXHfyBSDpoeovkQELCHuMqU47178777 = -3692808;    long XbTXHfyBSDpoeovkQELCHuMqU5462661 = 96135642;    long XbTXHfyBSDpoeovkQELCHuMqU47117015 = -515630558;    long XbTXHfyBSDpoeovkQELCHuMqU87677827 = -677458578;    long XbTXHfyBSDpoeovkQELCHuMqU95631669 = -703933068;    long XbTXHfyBSDpoeovkQELCHuMqU69306568 = -830265738;    long XbTXHfyBSDpoeovkQELCHuMqU18451875 = -920670572;    long XbTXHfyBSDpoeovkQELCHuMqU94921412 = -868530017;    long XbTXHfyBSDpoeovkQELCHuMqU58915481 = 37084665;    long XbTXHfyBSDpoeovkQELCHuMqU16353773 = -681179762;    long XbTXHfyBSDpoeovkQELCHuMqU40208498 = -163496228;    long XbTXHfyBSDpoeovkQELCHuMqU82680357 = -701483428;    long XbTXHfyBSDpoeovkQELCHuMqU52246981 = -96987103;    long XbTXHfyBSDpoeovkQELCHuMqU40144496 = -387021477;    long XbTXHfyBSDpoeovkQELCHuMqU45976741 = -769527217;    long XbTXHfyBSDpoeovkQELCHuMqU80111983 = -616165350;    long XbTXHfyBSDpoeovkQELCHuMqU17122677 = -730597025;    long XbTXHfyBSDpoeovkQELCHuMqU35799643 = -796163931;    long XbTXHfyBSDpoeovkQELCHuMqU85105749 = -667441388;    long XbTXHfyBSDpoeovkQELCHuMqU2639267 = -28104675;    long XbTXHfyBSDpoeovkQELCHuMqU86223992 = 81182641;    long XbTXHfyBSDpoeovkQELCHuMqU5800082 = -204968127;    long XbTXHfyBSDpoeovkQELCHuMqU15224239 = -316819289;    long XbTXHfyBSDpoeovkQELCHuMqU54866713 = -173711263;    long XbTXHfyBSDpoeovkQELCHuMqU74888638 = -788437392;    long XbTXHfyBSDpoeovkQELCHuMqU53939032 = -817764510;    long XbTXHfyBSDpoeovkQELCHuMqU32693787 = -744847787;    long XbTXHfyBSDpoeovkQELCHuMqU80384142 = -326960283;    long XbTXHfyBSDpoeovkQELCHuMqU27760154 = -194337889;    long XbTXHfyBSDpoeovkQELCHuMqU3938920 = -474485704;    long XbTXHfyBSDpoeovkQELCHuMqU81428817 = -807725530;    long XbTXHfyBSDpoeovkQELCHuMqU57369236 = -121734971;    long XbTXHfyBSDpoeovkQELCHuMqU55428968 = -495080005;    long XbTXHfyBSDpoeovkQELCHuMqU18697209 = -468821118;    long XbTXHfyBSDpoeovkQELCHuMqU53203017 = -268604641;    long XbTXHfyBSDpoeovkQELCHuMqU8491099 = -767989424;    long XbTXHfyBSDpoeovkQELCHuMqU27897711 = -365463502;    long XbTXHfyBSDpoeovkQELCHuMqU53358105 = -73199338;    long XbTXHfyBSDpoeovkQELCHuMqU8153426 = -761129164;    long XbTXHfyBSDpoeovkQELCHuMqU24238260 = -897550698;    long XbTXHfyBSDpoeovkQELCHuMqU96466485 = -567050255;    long XbTXHfyBSDpoeovkQELCHuMqU67952876 = -201420747;    long XbTXHfyBSDpoeovkQELCHuMqU40467184 = -332351259;    long XbTXHfyBSDpoeovkQELCHuMqU52123688 = -532953455;    long XbTXHfyBSDpoeovkQELCHuMqU44708493 = -606436238;    long XbTXHfyBSDpoeovkQELCHuMqU17824771 = 2262879;    long XbTXHfyBSDpoeovkQELCHuMqU33198467 = -410891397;    long XbTXHfyBSDpoeovkQELCHuMqU30975065 = -66720449;    long XbTXHfyBSDpoeovkQELCHuMqU66807589 = -499404109;    long XbTXHfyBSDpoeovkQELCHuMqU79129447 = -419954383;    long XbTXHfyBSDpoeovkQELCHuMqU79194959 = -627016690;    long XbTXHfyBSDpoeovkQELCHuMqU34857984 = -95128268;    long XbTXHfyBSDpoeovkQELCHuMqU72819305 = -392161766;    long XbTXHfyBSDpoeovkQELCHuMqU453205 = -682709259;    long XbTXHfyBSDpoeovkQELCHuMqU47254774 = -300621101;    long XbTXHfyBSDpoeovkQELCHuMqU41378695 = -798724681;    long XbTXHfyBSDpoeovkQELCHuMqU90238421 = -587045070;    long XbTXHfyBSDpoeovkQELCHuMqU92250301 = -241919296;    long XbTXHfyBSDpoeovkQELCHuMqU12789189 = -889021187;    long XbTXHfyBSDpoeovkQELCHuMqU41692637 = -886168558;    long XbTXHfyBSDpoeovkQELCHuMqU36612781 = 14582048;    long XbTXHfyBSDpoeovkQELCHuMqU38067733 = -493710290;    long XbTXHfyBSDpoeovkQELCHuMqU67161258 = -574192129;    long XbTXHfyBSDpoeovkQELCHuMqU54976562 = -488429632;    long XbTXHfyBSDpoeovkQELCHuMqU34924955 = -873454233;    long XbTXHfyBSDpoeovkQELCHuMqU82839261 = 58238742;    long XbTXHfyBSDpoeovkQELCHuMqU27251389 = -106403423;    long XbTXHfyBSDpoeovkQELCHuMqU33549772 = -628165985;    long XbTXHfyBSDpoeovkQELCHuMqU86941479 = -18416836;    long XbTXHfyBSDpoeovkQELCHuMqU37485642 = 98462207;    long XbTXHfyBSDpoeovkQELCHuMqU52214272 = -150701849;    long XbTXHfyBSDpoeovkQELCHuMqU63764572 = -557397687;    long XbTXHfyBSDpoeovkQELCHuMqU27646218 = 64965232;    long XbTXHfyBSDpoeovkQELCHuMqU60867489 = -769890690;    long XbTXHfyBSDpoeovkQELCHuMqU6172781 = -461054421;    long XbTXHfyBSDpoeovkQELCHuMqU18271116 = -717396613;    long XbTXHfyBSDpoeovkQELCHuMqU65332898 = -872616868;    long XbTXHfyBSDpoeovkQELCHuMqU63100551 = -783865834;    long XbTXHfyBSDpoeovkQELCHuMqU10158221 = -567275025;    long XbTXHfyBSDpoeovkQELCHuMqU57063868 = -690700271;    long XbTXHfyBSDpoeovkQELCHuMqU20740566 = -306873114;    long XbTXHfyBSDpoeovkQELCHuMqU1718722 = -578127338;    long XbTXHfyBSDpoeovkQELCHuMqU13576553 = -827556174;    long XbTXHfyBSDpoeovkQELCHuMqU48630706 = -774383507;    long XbTXHfyBSDpoeovkQELCHuMqU24743961 = -847469015;    long XbTXHfyBSDpoeovkQELCHuMqU46570834 = -612597262;    long XbTXHfyBSDpoeovkQELCHuMqU84549930 = -729573205;    long XbTXHfyBSDpoeovkQELCHuMqU54975764 = -812370747;    long XbTXHfyBSDpoeovkQELCHuMqU71442435 = -68200018;    long XbTXHfyBSDpoeovkQELCHuMqU11824322 = -469879960;    long XbTXHfyBSDpoeovkQELCHuMqU18252678 = -80944355;    long XbTXHfyBSDpoeovkQELCHuMqU35647409 = -23544206;    long XbTXHfyBSDpoeovkQELCHuMqU40568916 = -184178152;    long XbTXHfyBSDpoeovkQELCHuMqU66460788 = -874960606;    long XbTXHfyBSDpoeovkQELCHuMqU87625479 = -812132747;    long XbTXHfyBSDpoeovkQELCHuMqU58398753 = 26660035;    long XbTXHfyBSDpoeovkQELCHuMqU791619 = -627228618;    long XbTXHfyBSDpoeovkQELCHuMqU85490622 = -810813933;     XbTXHfyBSDpoeovkQELCHuMqU3092471 = XbTXHfyBSDpoeovkQELCHuMqU33478766;     XbTXHfyBSDpoeovkQELCHuMqU33478766 = XbTXHfyBSDpoeovkQELCHuMqU47178777;     XbTXHfyBSDpoeovkQELCHuMqU47178777 = XbTXHfyBSDpoeovkQELCHuMqU5462661;     XbTXHfyBSDpoeovkQELCHuMqU5462661 = XbTXHfyBSDpoeovkQELCHuMqU47117015;     XbTXHfyBSDpoeovkQELCHuMqU47117015 = XbTXHfyBSDpoeovkQELCHuMqU87677827;     XbTXHfyBSDpoeovkQELCHuMqU87677827 = XbTXHfyBSDpoeovkQELCHuMqU95631669;     XbTXHfyBSDpoeovkQELCHuMqU95631669 = XbTXHfyBSDpoeovkQELCHuMqU69306568;     XbTXHfyBSDpoeovkQELCHuMqU69306568 = XbTXHfyBSDpoeovkQELCHuMqU18451875;     XbTXHfyBSDpoeovkQELCHuMqU18451875 = XbTXHfyBSDpoeovkQELCHuMqU94921412;     XbTXHfyBSDpoeovkQELCHuMqU94921412 = XbTXHfyBSDpoeovkQELCHuMqU58915481;     XbTXHfyBSDpoeovkQELCHuMqU58915481 = XbTXHfyBSDpoeovkQELCHuMqU16353773;     XbTXHfyBSDpoeovkQELCHuMqU16353773 = XbTXHfyBSDpoeovkQELCHuMqU40208498;     XbTXHfyBSDpoeovkQELCHuMqU40208498 = XbTXHfyBSDpoeovkQELCHuMqU82680357;     XbTXHfyBSDpoeovkQELCHuMqU82680357 = XbTXHfyBSDpoeovkQELCHuMqU52246981;     XbTXHfyBSDpoeovkQELCHuMqU52246981 = XbTXHfyBSDpoeovkQELCHuMqU40144496;     XbTXHfyBSDpoeovkQELCHuMqU40144496 = XbTXHfyBSDpoeovkQELCHuMqU45976741;     XbTXHfyBSDpoeovkQELCHuMqU45976741 = XbTXHfyBSDpoeovkQELCHuMqU80111983;     XbTXHfyBSDpoeovkQELCHuMqU80111983 = XbTXHfyBSDpoeovkQELCHuMqU17122677;     XbTXHfyBSDpoeovkQELCHuMqU17122677 = XbTXHfyBSDpoeovkQELCHuMqU35799643;     XbTXHfyBSDpoeovkQELCHuMqU35799643 = XbTXHfyBSDpoeovkQELCHuMqU85105749;     XbTXHfyBSDpoeovkQELCHuMqU85105749 = XbTXHfyBSDpoeovkQELCHuMqU2639267;     XbTXHfyBSDpoeovkQELCHuMqU2639267 = XbTXHfyBSDpoeovkQELCHuMqU86223992;     XbTXHfyBSDpoeovkQELCHuMqU86223992 = XbTXHfyBSDpoeovkQELCHuMqU5800082;     XbTXHfyBSDpoeovkQELCHuMqU5800082 = XbTXHfyBSDpoeovkQELCHuMqU15224239;     XbTXHfyBSDpoeovkQELCHuMqU15224239 = XbTXHfyBSDpoeovkQELCHuMqU54866713;     XbTXHfyBSDpoeovkQELCHuMqU54866713 = XbTXHfyBSDpoeovkQELCHuMqU74888638;     XbTXHfyBSDpoeovkQELCHuMqU74888638 = XbTXHfyBSDpoeovkQELCHuMqU53939032;     XbTXHfyBSDpoeovkQELCHuMqU53939032 = XbTXHfyBSDpoeovkQELCHuMqU32693787;     XbTXHfyBSDpoeovkQELCHuMqU32693787 = XbTXHfyBSDpoeovkQELCHuMqU80384142;     XbTXHfyBSDpoeovkQELCHuMqU80384142 = XbTXHfyBSDpoeovkQELCHuMqU27760154;     XbTXHfyBSDpoeovkQELCHuMqU27760154 = XbTXHfyBSDpoeovkQELCHuMqU3938920;     XbTXHfyBSDpoeovkQELCHuMqU3938920 = XbTXHfyBSDpoeovkQELCHuMqU81428817;     XbTXHfyBSDpoeovkQELCHuMqU81428817 = XbTXHfyBSDpoeovkQELCHuMqU57369236;     XbTXHfyBSDpoeovkQELCHuMqU57369236 = XbTXHfyBSDpoeovkQELCHuMqU55428968;     XbTXHfyBSDpoeovkQELCHuMqU55428968 = XbTXHfyBSDpoeovkQELCHuMqU18697209;     XbTXHfyBSDpoeovkQELCHuMqU18697209 = XbTXHfyBSDpoeovkQELCHuMqU53203017;     XbTXHfyBSDpoeovkQELCHuMqU53203017 = XbTXHfyBSDpoeovkQELCHuMqU8491099;     XbTXHfyBSDpoeovkQELCHuMqU8491099 = XbTXHfyBSDpoeovkQELCHuMqU27897711;     XbTXHfyBSDpoeovkQELCHuMqU27897711 = XbTXHfyBSDpoeovkQELCHuMqU53358105;     XbTXHfyBSDpoeovkQELCHuMqU53358105 = XbTXHfyBSDpoeovkQELCHuMqU8153426;     XbTXHfyBSDpoeovkQELCHuMqU8153426 = XbTXHfyBSDpoeovkQELCHuMqU24238260;     XbTXHfyBSDpoeovkQELCHuMqU24238260 = XbTXHfyBSDpoeovkQELCHuMqU96466485;     XbTXHfyBSDpoeovkQELCHuMqU96466485 = XbTXHfyBSDpoeovkQELCHuMqU67952876;     XbTXHfyBSDpoeovkQELCHuMqU67952876 = XbTXHfyBSDpoeovkQELCHuMqU40467184;     XbTXHfyBSDpoeovkQELCHuMqU40467184 = XbTXHfyBSDpoeovkQELCHuMqU52123688;     XbTXHfyBSDpoeovkQELCHuMqU52123688 = XbTXHfyBSDpoeovkQELCHuMqU44708493;     XbTXHfyBSDpoeovkQELCHuMqU44708493 = XbTXHfyBSDpoeovkQELCHuMqU17824771;     XbTXHfyBSDpoeovkQELCHuMqU17824771 = XbTXHfyBSDpoeovkQELCHuMqU33198467;     XbTXHfyBSDpoeovkQELCHuMqU33198467 = XbTXHfyBSDpoeovkQELCHuMqU30975065;     XbTXHfyBSDpoeovkQELCHuMqU30975065 = XbTXHfyBSDpoeovkQELCHuMqU66807589;     XbTXHfyBSDpoeovkQELCHuMqU66807589 = XbTXHfyBSDpoeovkQELCHuMqU79129447;     XbTXHfyBSDpoeovkQELCHuMqU79129447 = XbTXHfyBSDpoeovkQELCHuMqU79194959;     XbTXHfyBSDpoeovkQELCHuMqU79194959 = XbTXHfyBSDpoeovkQELCHuMqU34857984;     XbTXHfyBSDpoeovkQELCHuMqU34857984 = XbTXHfyBSDpoeovkQELCHuMqU72819305;     XbTXHfyBSDpoeovkQELCHuMqU72819305 = XbTXHfyBSDpoeovkQELCHuMqU453205;     XbTXHfyBSDpoeovkQELCHuMqU453205 = XbTXHfyBSDpoeovkQELCHuMqU47254774;     XbTXHfyBSDpoeovkQELCHuMqU47254774 = XbTXHfyBSDpoeovkQELCHuMqU41378695;     XbTXHfyBSDpoeovkQELCHuMqU41378695 = XbTXHfyBSDpoeovkQELCHuMqU90238421;     XbTXHfyBSDpoeovkQELCHuMqU90238421 = XbTXHfyBSDpoeovkQELCHuMqU92250301;     XbTXHfyBSDpoeovkQELCHuMqU92250301 = XbTXHfyBSDpoeovkQELCHuMqU12789189;     XbTXHfyBSDpoeovkQELCHuMqU12789189 = XbTXHfyBSDpoeovkQELCHuMqU41692637;     XbTXHfyBSDpoeovkQELCHuMqU41692637 = XbTXHfyBSDpoeovkQELCHuMqU36612781;     XbTXHfyBSDpoeovkQELCHuMqU36612781 = XbTXHfyBSDpoeovkQELCHuMqU38067733;     XbTXHfyBSDpoeovkQELCHuMqU38067733 = XbTXHfyBSDpoeovkQELCHuMqU67161258;     XbTXHfyBSDpoeovkQELCHuMqU67161258 = XbTXHfyBSDpoeovkQELCHuMqU54976562;     XbTXHfyBSDpoeovkQELCHuMqU54976562 = XbTXHfyBSDpoeovkQELCHuMqU34924955;     XbTXHfyBSDpoeovkQELCHuMqU34924955 = XbTXHfyBSDpoeovkQELCHuMqU82839261;     XbTXHfyBSDpoeovkQELCHuMqU82839261 = XbTXHfyBSDpoeovkQELCHuMqU27251389;     XbTXHfyBSDpoeovkQELCHuMqU27251389 = XbTXHfyBSDpoeovkQELCHuMqU33549772;     XbTXHfyBSDpoeovkQELCHuMqU33549772 = XbTXHfyBSDpoeovkQELCHuMqU86941479;     XbTXHfyBSDpoeovkQELCHuMqU86941479 = XbTXHfyBSDpoeovkQELCHuMqU37485642;     XbTXHfyBSDpoeovkQELCHuMqU37485642 = XbTXHfyBSDpoeovkQELCHuMqU52214272;     XbTXHfyBSDpoeovkQELCHuMqU52214272 = XbTXHfyBSDpoeovkQELCHuMqU63764572;     XbTXHfyBSDpoeovkQELCHuMqU63764572 = XbTXHfyBSDpoeovkQELCHuMqU27646218;     XbTXHfyBSDpoeovkQELCHuMqU27646218 = XbTXHfyBSDpoeovkQELCHuMqU60867489;     XbTXHfyBSDpoeovkQELCHuMqU60867489 = XbTXHfyBSDpoeovkQELCHuMqU6172781;     XbTXHfyBSDpoeovkQELCHuMqU6172781 = XbTXHfyBSDpoeovkQELCHuMqU18271116;     XbTXHfyBSDpoeovkQELCHuMqU18271116 = XbTXHfyBSDpoeovkQELCHuMqU65332898;     XbTXHfyBSDpoeovkQELCHuMqU65332898 = XbTXHfyBSDpoeovkQELCHuMqU63100551;     XbTXHfyBSDpoeovkQELCHuMqU63100551 = XbTXHfyBSDpoeovkQELCHuMqU10158221;     XbTXHfyBSDpoeovkQELCHuMqU10158221 = XbTXHfyBSDpoeovkQELCHuMqU57063868;     XbTXHfyBSDpoeovkQELCHuMqU57063868 = XbTXHfyBSDpoeovkQELCHuMqU20740566;     XbTXHfyBSDpoeovkQELCHuMqU20740566 = XbTXHfyBSDpoeovkQELCHuMqU1718722;     XbTXHfyBSDpoeovkQELCHuMqU1718722 = XbTXHfyBSDpoeovkQELCHuMqU13576553;     XbTXHfyBSDpoeovkQELCHuMqU13576553 = XbTXHfyBSDpoeovkQELCHuMqU48630706;     XbTXHfyBSDpoeovkQELCHuMqU48630706 = XbTXHfyBSDpoeovkQELCHuMqU24743961;     XbTXHfyBSDpoeovkQELCHuMqU24743961 = XbTXHfyBSDpoeovkQELCHuMqU46570834;     XbTXHfyBSDpoeovkQELCHuMqU46570834 = XbTXHfyBSDpoeovkQELCHuMqU84549930;     XbTXHfyBSDpoeovkQELCHuMqU84549930 = XbTXHfyBSDpoeovkQELCHuMqU54975764;     XbTXHfyBSDpoeovkQELCHuMqU54975764 = XbTXHfyBSDpoeovkQELCHuMqU71442435;     XbTXHfyBSDpoeovkQELCHuMqU71442435 = XbTXHfyBSDpoeovkQELCHuMqU11824322;     XbTXHfyBSDpoeovkQELCHuMqU11824322 = XbTXHfyBSDpoeovkQELCHuMqU18252678;     XbTXHfyBSDpoeovkQELCHuMqU18252678 = XbTXHfyBSDpoeovkQELCHuMqU35647409;     XbTXHfyBSDpoeovkQELCHuMqU35647409 = XbTXHfyBSDpoeovkQELCHuMqU40568916;     XbTXHfyBSDpoeovkQELCHuMqU40568916 = XbTXHfyBSDpoeovkQELCHuMqU66460788;     XbTXHfyBSDpoeovkQELCHuMqU66460788 = XbTXHfyBSDpoeovkQELCHuMqU87625479;     XbTXHfyBSDpoeovkQELCHuMqU87625479 = XbTXHfyBSDpoeovkQELCHuMqU58398753;     XbTXHfyBSDpoeovkQELCHuMqU58398753 = XbTXHfyBSDpoeovkQELCHuMqU791619;     XbTXHfyBSDpoeovkQELCHuMqU791619 = XbTXHfyBSDpoeovkQELCHuMqU85490622;     XbTXHfyBSDpoeovkQELCHuMqU85490622 = XbTXHfyBSDpoeovkQELCHuMqU3092471;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void AJXtCjWkTFKjQJeLKuuPViuJigLkYqMFwjEDsfkNnsmnUkobNeXSeBdSP72974122() {     long OKWYmMdtEmgFaTfKhbdvGoysj9209577 = -922715822;    long OKWYmMdtEmgFaTfKhbdvGoysj76852045 = -29038240;    long OKWYmMdtEmgFaTfKhbdvGoysj63220961 = -154525729;    long OKWYmMdtEmgFaTfKhbdvGoysj32537441 = -94612988;    long OKWYmMdtEmgFaTfKhbdvGoysj16012504 = 63719571;    long OKWYmMdtEmgFaTfKhbdvGoysj79095029 = -941954813;    long OKWYmMdtEmgFaTfKhbdvGoysj56120635 = -842898045;    long OKWYmMdtEmgFaTfKhbdvGoysj19066459 = -17139651;    long OKWYmMdtEmgFaTfKhbdvGoysj83094370 = -688703238;    long OKWYmMdtEmgFaTfKhbdvGoysj36151072 = -97505495;    long OKWYmMdtEmgFaTfKhbdvGoysj19025772 = -940352922;    long OKWYmMdtEmgFaTfKhbdvGoysj48176815 = -25585964;    long OKWYmMdtEmgFaTfKhbdvGoysj26417617 = -603387317;    long OKWYmMdtEmgFaTfKhbdvGoysj65824034 = -133721995;    long OKWYmMdtEmgFaTfKhbdvGoysj47989408 = -787449269;    long OKWYmMdtEmgFaTfKhbdvGoysj81649890 = -360021020;    long OKWYmMdtEmgFaTfKhbdvGoysj39812744 = -286072329;    long OKWYmMdtEmgFaTfKhbdvGoysj77165136 = -281687993;    long OKWYmMdtEmgFaTfKhbdvGoysj78952518 = -36366122;    long OKWYmMdtEmgFaTfKhbdvGoysj16349808 = -53066850;    long OKWYmMdtEmgFaTfKhbdvGoysj73658942 = -522928843;    long OKWYmMdtEmgFaTfKhbdvGoysj89160289 = 63965609;    long OKWYmMdtEmgFaTfKhbdvGoysj21814784 = -765334846;    long OKWYmMdtEmgFaTfKhbdvGoysj89792455 = -427273115;    long OKWYmMdtEmgFaTfKhbdvGoysj58923889 = -690015322;    long OKWYmMdtEmgFaTfKhbdvGoysj79588388 = -52366586;    long OKWYmMdtEmgFaTfKhbdvGoysj73348417 = -689099595;    long OKWYmMdtEmgFaTfKhbdvGoysj67046158 = -883693464;    long OKWYmMdtEmgFaTfKhbdvGoysj98826042 = -967230491;    long OKWYmMdtEmgFaTfKhbdvGoysj48999779 = -144431150;    long OKWYmMdtEmgFaTfKhbdvGoysj20002704 = -107658827;    long OKWYmMdtEmgFaTfKhbdvGoysj1549542 = -183932520;    long OKWYmMdtEmgFaTfKhbdvGoysj91139766 = -700338901;    long OKWYmMdtEmgFaTfKhbdvGoysj52199801 = -973276736;    long OKWYmMdtEmgFaTfKhbdvGoysj16903621 = -33813111;    long OKWYmMdtEmgFaTfKhbdvGoysj87423121 = -682847226;    long OKWYmMdtEmgFaTfKhbdvGoysj34464952 = -222240511;    long OKWYmMdtEmgFaTfKhbdvGoysj42581311 = -539495433;    long OKWYmMdtEmgFaTfKhbdvGoysj1507965 = -359386998;    long OKWYmMdtEmgFaTfKhbdvGoysj40860042 = -546638561;    long OKWYmMdtEmgFaTfKhbdvGoysj13822650 = -826403058;    long OKWYmMdtEmgFaTfKhbdvGoysj56388717 = -67692976;    long OKWYmMdtEmgFaTfKhbdvGoysj74533464 = -647854839;    long OKWYmMdtEmgFaTfKhbdvGoysj55360617 = -220763685;    long OKWYmMdtEmgFaTfKhbdvGoysj52419649 = 5750587;    long OKWYmMdtEmgFaTfKhbdvGoysj64062883 = -518169571;    long OKWYmMdtEmgFaTfKhbdvGoysj62487067 = -725211776;    long OKWYmMdtEmgFaTfKhbdvGoysj25781711 = -7632654;    long OKWYmMdtEmgFaTfKhbdvGoysj42874196 = -496628385;    long OKWYmMdtEmgFaTfKhbdvGoysj43886718 = -153731257;    long OKWYmMdtEmgFaTfKhbdvGoysj2508268 = -341697780;    long OKWYmMdtEmgFaTfKhbdvGoysj89939167 = -220680703;    long OKWYmMdtEmgFaTfKhbdvGoysj27443417 = -418806278;    long OKWYmMdtEmgFaTfKhbdvGoysj30826864 = -415598414;    long OKWYmMdtEmgFaTfKhbdvGoysj99315180 = 7306451;    long OKWYmMdtEmgFaTfKhbdvGoysj20049288 = -886681431;    long OKWYmMdtEmgFaTfKhbdvGoysj55037261 = -263703395;    long OKWYmMdtEmgFaTfKhbdvGoysj73428505 = -727252615;    long OKWYmMdtEmgFaTfKhbdvGoysj73613552 = -404597667;    long OKWYmMdtEmgFaTfKhbdvGoysj36424115 = -883913844;    long OKWYmMdtEmgFaTfKhbdvGoysj5746613 = -152855219;    long OKWYmMdtEmgFaTfKhbdvGoysj89074477 = -959204581;    long OKWYmMdtEmgFaTfKhbdvGoysj20240417 = -49909160;    long OKWYmMdtEmgFaTfKhbdvGoysj34094592 = -444272088;    long OKWYmMdtEmgFaTfKhbdvGoysj16148368 = -989846668;    long OKWYmMdtEmgFaTfKhbdvGoysj17476230 = -656420403;    long OKWYmMdtEmgFaTfKhbdvGoysj57037048 = -325247064;    long OKWYmMdtEmgFaTfKhbdvGoysj74217816 = -630110581;    long OKWYmMdtEmgFaTfKhbdvGoysj48920414 = 91115;    long OKWYmMdtEmgFaTfKhbdvGoysj60566286 = -4602044;    long OKWYmMdtEmgFaTfKhbdvGoysj47184938 = -37780510;    long OKWYmMdtEmgFaTfKhbdvGoysj97231432 = -746576896;    long OKWYmMdtEmgFaTfKhbdvGoysj75657171 = -922300995;    long OKWYmMdtEmgFaTfKhbdvGoysj38092476 = -489727562;    long OKWYmMdtEmgFaTfKhbdvGoysj2527159 = -226663793;    long OKWYmMdtEmgFaTfKhbdvGoysj17270226 = -355235868;    long OKWYmMdtEmgFaTfKhbdvGoysj14626826 = -288179553;    long OKWYmMdtEmgFaTfKhbdvGoysj66454167 = -444571162;    long OKWYmMdtEmgFaTfKhbdvGoysj37372807 = -333023702;    long OKWYmMdtEmgFaTfKhbdvGoysj94861006 = -71845751;    long OKWYmMdtEmgFaTfKhbdvGoysj17101322 = -327154811;    long OKWYmMdtEmgFaTfKhbdvGoysj47566706 = -581466942;    long OKWYmMdtEmgFaTfKhbdvGoysj24171962 = -287065079;    long OKWYmMdtEmgFaTfKhbdvGoysj54939325 = -713499234;    long OKWYmMdtEmgFaTfKhbdvGoysj46491512 = -802733370;    long OKWYmMdtEmgFaTfKhbdvGoysj30063536 = -886978125;    long OKWYmMdtEmgFaTfKhbdvGoysj74106125 = -765126243;    long OKWYmMdtEmgFaTfKhbdvGoysj60312902 = -184740487;    long OKWYmMdtEmgFaTfKhbdvGoysj52884620 = -880583188;    long OKWYmMdtEmgFaTfKhbdvGoysj96854333 = -147131680;    long OKWYmMdtEmgFaTfKhbdvGoysj32385861 = -319143832;    long OKWYmMdtEmgFaTfKhbdvGoysj61036446 = -494987896;    long OKWYmMdtEmgFaTfKhbdvGoysj68967759 = -34897767;    long OKWYmMdtEmgFaTfKhbdvGoysj65083850 = -475473155;    long OKWYmMdtEmgFaTfKhbdvGoysj35113430 = -293783343;    long OKWYmMdtEmgFaTfKhbdvGoysj24748172 = -867198477;    long OKWYmMdtEmgFaTfKhbdvGoysj36148301 = 82216184;    long OKWYmMdtEmgFaTfKhbdvGoysj40438873 = -103582751;    long OKWYmMdtEmgFaTfKhbdvGoysj39212249 = -230917017;    long OKWYmMdtEmgFaTfKhbdvGoysj34943419 = -922715822;     OKWYmMdtEmgFaTfKhbdvGoysj9209577 = OKWYmMdtEmgFaTfKhbdvGoysj76852045;     OKWYmMdtEmgFaTfKhbdvGoysj76852045 = OKWYmMdtEmgFaTfKhbdvGoysj63220961;     OKWYmMdtEmgFaTfKhbdvGoysj63220961 = OKWYmMdtEmgFaTfKhbdvGoysj32537441;     OKWYmMdtEmgFaTfKhbdvGoysj32537441 = OKWYmMdtEmgFaTfKhbdvGoysj16012504;     OKWYmMdtEmgFaTfKhbdvGoysj16012504 = OKWYmMdtEmgFaTfKhbdvGoysj79095029;     OKWYmMdtEmgFaTfKhbdvGoysj79095029 = OKWYmMdtEmgFaTfKhbdvGoysj56120635;     OKWYmMdtEmgFaTfKhbdvGoysj56120635 = OKWYmMdtEmgFaTfKhbdvGoysj19066459;     OKWYmMdtEmgFaTfKhbdvGoysj19066459 = OKWYmMdtEmgFaTfKhbdvGoysj83094370;     OKWYmMdtEmgFaTfKhbdvGoysj83094370 = OKWYmMdtEmgFaTfKhbdvGoysj36151072;     OKWYmMdtEmgFaTfKhbdvGoysj36151072 = OKWYmMdtEmgFaTfKhbdvGoysj19025772;     OKWYmMdtEmgFaTfKhbdvGoysj19025772 = OKWYmMdtEmgFaTfKhbdvGoysj48176815;     OKWYmMdtEmgFaTfKhbdvGoysj48176815 = OKWYmMdtEmgFaTfKhbdvGoysj26417617;     OKWYmMdtEmgFaTfKhbdvGoysj26417617 = OKWYmMdtEmgFaTfKhbdvGoysj65824034;     OKWYmMdtEmgFaTfKhbdvGoysj65824034 = OKWYmMdtEmgFaTfKhbdvGoysj47989408;     OKWYmMdtEmgFaTfKhbdvGoysj47989408 = OKWYmMdtEmgFaTfKhbdvGoysj81649890;     OKWYmMdtEmgFaTfKhbdvGoysj81649890 = OKWYmMdtEmgFaTfKhbdvGoysj39812744;     OKWYmMdtEmgFaTfKhbdvGoysj39812744 = OKWYmMdtEmgFaTfKhbdvGoysj77165136;     OKWYmMdtEmgFaTfKhbdvGoysj77165136 = OKWYmMdtEmgFaTfKhbdvGoysj78952518;     OKWYmMdtEmgFaTfKhbdvGoysj78952518 = OKWYmMdtEmgFaTfKhbdvGoysj16349808;     OKWYmMdtEmgFaTfKhbdvGoysj16349808 = OKWYmMdtEmgFaTfKhbdvGoysj73658942;     OKWYmMdtEmgFaTfKhbdvGoysj73658942 = OKWYmMdtEmgFaTfKhbdvGoysj89160289;     OKWYmMdtEmgFaTfKhbdvGoysj89160289 = OKWYmMdtEmgFaTfKhbdvGoysj21814784;     OKWYmMdtEmgFaTfKhbdvGoysj21814784 = OKWYmMdtEmgFaTfKhbdvGoysj89792455;     OKWYmMdtEmgFaTfKhbdvGoysj89792455 = OKWYmMdtEmgFaTfKhbdvGoysj58923889;     OKWYmMdtEmgFaTfKhbdvGoysj58923889 = OKWYmMdtEmgFaTfKhbdvGoysj79588388;     OKWYmMdtEmgFaTfKhbdvGoysj79588388 = OKWYmMdtEmgFaTfKhbdvGoysj73348417;     OKWYmMdtEmgFaTfKhbdvGoysj73348417 = OKWYmMdtEmgFaTfKhbdvGoysj67046158;     OKWYmMdtEmgFaTfKhbdvGoysj67046158 = OKWYmMdtEmgFaTfKhbdvGoysj98826042;     OKWYmMdtEmgFaTfKhbdvGoysj98826042 = OKWYmMdtEmgFaTfKhbdvGoysj48999779;     OKWYmMdtEmgFaTfKhbdvGoysj48999779 = OKWYmMdtEmgFaTfKhbdvGoysj20002704;     OKWYmMdtEmgFaTfKhbdvGoysj20002704 = OKWYmMdtEmgFaTfKhbdvGoysj1549542;     OKWYmMdtEmgFaTfKhbdvGoysj1549542 = OKWYmMdtEmgFaTfKhbdvGoysj91139766;     OKWYmMdtEmgFaTfKhbdvGoysj91139766 = OKWYmMdtEmgFaTfKhbdvGoysj52199801;     OKWYmMdtEmgFaTfKhbdvGoysj52199801 = OKWYmMdtEmgFaTfKhbdvGoysj16903621;     OKWYmMdtEmgFaTfKhbdvGoysj16903621 = OKWYmMdtEmgFaTfKhbdvGoysj87423121;     OKWYmMdtEmgFaTfKhbdvGoysj87423121 = OKWYmMdtEmgFaTfKhbdvGoysj34464952;     OKWYmMdtEmgFaTfKhbdvGoysj34464952 = OKWYmMdtEmgFaTfKhbdvGoysj42581311;     OKWYmMdtEmgFaTfKhbdvGoysj42581311 = OKWYmMdtEmgFaTfKhbdvGoysj1507965;     OKWYmMdtEmgFaTfKhbdvGoysj1507965 = OKWYmMdtEmgFaTfKhbdvGoysj40860042;     OKWYmMdtEmgFaTfKhbdvGoysj40860042 = OKWYmMdtEmgFaTfKhbdvGoysj13822650;     OKWYmMdtEmgFaTfKhbdvGoysj13822650 = OKWYmMdtEmgFaTfKhbdvGoysj56388717;     OKWYmMdtEmgFaTfKhbdvGoysj56388717 = OKWYmMdtEmgFaTfKhbdvGoysj74533464;     OKWYmMdtEmgFaTfKhbdvGoysj74533464 = OKWYmMdtEmgFaTfKhbdvGoysj55360617;     OKWYmMdtEmgFaTfKhbdvGoysj55360617 = OKWYmMdtEmgFaTfKhbdvGoysj52419649;     OKWYmMdtEmgFaTfKhbdvGoysj52419649 = OKWYmMdtEmgFaTfKhbdvGoysj64062883;     OKWYmMdtEmgFaTfKhbdvGoysj64062883 = OKWYmMdtEmgFaTfKhbdvGoysj62487067;     OKWYmMdtEmgFaTfKhbdvGoysj62487067 = OKWYmMdtEmgFaTfKhbdvGoysj25781711;     OKWYmMdtEmgFaTfKhbdvGoysj25781711 = OKWYmMdtEmgFaTfKhbdvGoysj42874196;     OKWYmMdtEmgFaTfKhbdvGoysj42874196 = OKWYmMdtEmgFaTfKhbdvGoysj43886718;     OKWYmMdtEmgFaTfKhbdvGoysj43886718 = OKWYmMdtEmgFaTfKhbdvGoysj2508268;     OKWYmMdtEmgFaTfKhbdvGoysj2508268 = OKWYmMdtEmgFaTfKhbdvGoysj89939167;     OKWYmMdtEmgFaTfKhbdvGoysj89939167 = OKWYmMdtEmgFaTfKhbdvGoysj27443417;     OKWYmMdtEmgFaTfKhbdvGoysj27443417 = OKWYmMdtEmgFaTfKhbdvGoysj30826864;     OKWYmMdtEmgFaTfKhbdvGoysj30826864 = OKWYmMdtEmgFaTfKhbdvGoysj99315180;     OKWYmMdtEmgFaTfKhbdvGoysj99315180 = OKWYmMdtEmgFaTfKhbdvGoysj20049288;     OKWYmMdtEmgFaTfKhbdvGoysj20049288 = OKWYmMdtEmgFaTfKhbdvGoysj55037261;     OKWYmMdtEmgFaTfKhbdvGoysj55037261 = OKWYmMdtEmgFaTfKhbdvGoysj73428505;     OKWYmMdtEmgFaTfKhbdvGoysj73428505 = OKWYmMdtEmgFaTfKhbdvGoysj73613552;     OKWYmMdtEmgFaTfKhbdvGoysj73613552 = OKWYmMdtEmgFaTfKhbdvGoysj36424115;     OKWYmMdtEmgFaTfKhbdvGoysj36424115 = OKWYmMdtEmgFaTfKhbdvGoysj5746613;     OKWYmMdtEmgFaTfKhbdvGoysj5746613 = OKWYmMdtEmgFaTfKhbdvGoysj89074477;     OKWYmMdtEmgFaTfKhbdvGoysj89074477 = OKWYmMdtEmgFaTfKhbdvGoysj20240417;     OKWYmMdtEmgFaTfKhbdvGoysj20240417 = OKWYmMdtEmgFaTfKhbdvGoysj34094592;     OKWYmMdtEmgFaTfKhbdvGoysj34094592 = OKWYmMdtEmgFaTfKhbdvGoysj16148368;     OKWYmMdtEmgFaTfKhbdvGoysj16148368 = OKWYmMdtEmgFaTfKhbdvGoysj17476230;     OKWYmMdtEmgFaTfKhbdvGoysj17476230 = OKWYmMdtEmgFaTfKhbdvGoysj57037048;     OKWYmMdtEmgFaTfKhbdvGoysj57037048 = OKWYmMdtEmgFaTfKhbdvGoysj74217816;     OKWYmMdtEmgFaTfKhbdvGoysj74217816 = OKWYmMdtEmgFaTfKhbdvGoysj48920414;     OKWYmMdtEmgFaTfKhbdvGoysj48920414 = OKWYmMdtEmgFaTfKhbdvGoysj60566286;     OKWYmMdtEmgFaTfKhbdvGoysj60566286 = OKWYmMdtEmgFaTfKhbdvGoysj47184938;     OKWYmMdtEmgFaTfKhbdvGoysj47184938 = OKWYmMdtEmgFaTfKhbdvGoysj97231432;     OKWYmMdtEmgFaTfKhbdvGoysj97231432 = OKWYmMdtEmgFaTfKhbdvGoysj75657171;     OKWYmMdtEmgFaTfKhbdvGoysj75657171 = OKWYmMdtEmgFaTfKhbdvGoysj38092476;     OKWYmMdtEmgFaTfKhbdvGoysj38092476 = OKWYmMdtEmgFaTfKhbdvGoysj2527159;     OKWYmMdtEmgFaTfKhbdvGoysj2527159 = OKWYmMdtEmgFaTfKhbdvGoysj17270226;     OKWYmMdtEmgFaTfKhbdvGoysj17270226 = OKWYmMdtEmgFaTfKhbdvGoysj14626826;     OKWYmMdtEmgFaTfKhbdvGoysj14626826 = OKWYmMdtEmgFaTfKhbdvGoysj66454167;     OKWYmMdtEmgFaTfKhbdvGoysj66454167 = OKWYmMdtEmgFaTfKhbdvGoysj37372807;     OKWYmMdtEmgFaTfKhbdvGoysj37372807 = OKWYmMdtEmgFaTfKhbdvGoysj94861006;     OKWYmMdtEmgFaTfKhbdvGoysj94861006 = OKWYmMdtEmgFaTfKhbdvGoysj17101322;     OKWYmMdtEmgFaTfKhbdvGoysj17101322 = OKWYmMdtEmgFaTfKhbdvGoysj47566706;     OKWYmMdtEmgFaTfKhbdvGoysj47566706 = OKWYmMdtEmgFaTfKhbdvGoysj24171962;     OKWYmMdtEmgFaTfKhbdvGoysj24171962 = OKWYmMdtEmgFaTfKhbdvGoysj54939325;     OKWYmMdtEmgFaTfKhbdvGoysj54939325 = OKWYmMdtEmgFaTfKhbdvGoysj46491512;     OKWYmMdtEmgFaTfKhbdvGoysj46491512 = OKWYmMdtEmgFaTfKhbdvGoysj30063536;     OKWYmMdtEmgFaTfKhbdvGoysj30063536 = OKWYmMdtEmgFaTfKhbdvGoysj74106125;     OKWYmMdtEmgFaTfKhbdvGoysj74106125 = OKWYmMdtEmgFaTfKhbdvGoysj60312902;     OKWYmMdtEmgFaTfKhbdvGoysj60312902 = OKWYmMdtEmgFaTfKhbdvGoysj52884620;     OKWYmMdtEmgFaTfKhbdvGoysj52884620 = OKWYmMdtEmgFaTfKhbdvGoysj96854333;     OKWYmMdtEmgFaTfKhbdvGoysj96854333 = OKWYmMdtEmgFaTfKhbdvGoysj32385861;     OKWYmMdtEmgFaTfKhbdvGoysj32385861 = OKWYmMdtEmgFaTfKhbdvGoysj61036446;     OKWYmMdtEmgFaTfKhbdvGoysj61036446 = OKWYmMdtEmgFaTfKhbdvGoysj68967759;     OKWYmMdtEmgFaTfKhbdvGoysj68967759 = OKWYmMdtEmgFaTfKhbdvGoysj65083850;     OKWYmMdtEmgFaTfKhbdvGoysj65083850 = OKWYmMdtEmgFaTfKhbdvGoysj35113430;     OKWYmMdtEmgFaTfKhbdvGoysj35113430 = OKWYmMdtEmgFaTfKhbdvGoysj24748172;     OKWYmMdtEmgFaTfKhbdvGoysj24748172 = OKWYmMdtEmgFaTfKhbdvGoysj36148301;     OKWYmMdtEmgFaTfKhbdvGoysj36148301 = OKWYmMdtEmgFaTfKhbdvGoysj40438873;     OKWYmMdtEmgFaTfKhbdvGoysj40438873 = OKWYmMdtEmgFaTfKhbdvGoysj39212249;     OKWYmMdtEmgFaTfKhbdvGoysj39212249 = OKWYmMdtEmgFaTfKhbdvGoysj34943419;     OKWYmMdtEmgFaTfKhbdvGoysj34943419 = OKWYmMdtEmgFaTfKhbdvGoysj9209577;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void dgqClakDAsUjzWyJNGbMGQfqCYmkCgKlwwNRgDtrHGbkhmkObfSpExhNA40265722() {     long zAMnzBUhjnDJhdKMkFzpvIPoY44668546 = -288992722;    long zAMnzBUhjnDJhdKMkFzpvIPoY90124123 = 90410154;    long zAMnzBUhjnDJhdKMkFzpvIPoY607438 = -920192804;    long zAMnzBUhjnDJhdKMkFzpvIPoY4760797 = 84235941;    long zAMnzBUhjnDJhdKMkFzpvIPoY72297772 = -41879275;    long zAMnzBUhjnDJhdKMkFzpvIPoY15317902 = -104302709;    long zAMnzBUhjnDJhdKMkFzpvIPoY66778041 = -687623779;    long zAMnzBUhjnDJhdKMkFzpvIPoY81198020 = -761373792;    long zAMnzBUhjnDJhdKMkFzpvIPoY84611975 = -77034645;    long zAMnzBUhjnDJhdKMkFzpvIPoY51053784 = -862192493;    long zAMnzBUhjnDJhdKMkFzpvIPoY57207506 = -742360651;    long zAMnzBUhjnDJhdKMkFzpvIPoY48744963 = -989706736;    long zAMnzBUhjnDJhdKMkFzpvIPoY64652262 = -55399822;    long zAMnzBUhjnDJhdKMkFzpvIPoY18964898 = -110085405;    long zAMnzBUhjnDJhdKMkFzpvIPoY6183924 = -190874284;    long zAMnzBUhjnDJhdKMkFzpvIPoY65191191 = 4167373;    long zAMnzBUhjnDJhdKMkFzpvIPoY95648679 = -813046882;    long zAMnzBUhjnDJhdKMkFzpvIPoY76925327 = -355116061;    long zAMnzBUhjnDJhdKMkFzpvIPoY79502848 = -352929544;    long zAMnzBUhjnDJhdKMkFzpvIPoY10187027 = -479627916;    long zAMnzBUhjnDJhdKMkFzpvIPoY86745805 = -180203532;    long zAMnzBUhjnDJhdKMkFzpvIPoY92581814 = -22670685;    long zAMnzBUhjnDJhdKMkFzpvIPoY92340163 = -402967030;    long zAMnzBUhjnDJhdKMkFzpvIPoY83585401 = -938097719;    long zAMnzBUhjnDJhdKMkFzpvIPoY66941840 = -714000520;    long zAMnzBUhjnDJhdKMkFzpvIPoY90286560 = -840943393;    long zAMnzBUhjnDJhdKMkFzpvIPoY33768991 = -495383736;    long zAMnzBUhjnDJhdKMkFzpvIPoY7774583 = 46534362;    long zAMnzBUhjnDJhdKMkFzpvIPoY45494257 = -441325294;    long zAMnzBUhjnDJhdKMkFzpvIPoY54533190 = -178938321;    long zAMnzBUhjnDJhdKMkFzpvIPoY38585935 = -659639314;    long zAMnzBUhjnDJhdKMkFzpvIPoY39372560 = 43096066;    long zAMnzBUhjnDJhdKMkFzpvIPoY3357778 = -847934878;    long zAMnzBUhjnDJhdKMkFzpvIPoY81948227 = 62029450;    long zAMnzBUhjnDJhdKMkFzpvIPoY82712074 = 15086639;    long zAMnzBUhjnDJhdKMkFzpvIPoY38983966 = -897412532;    long zAMnzBUhjnDJhdKMkFzpvIPoY83876768 = -86936551;    long zAMnzBUhjnDJhdKMkFzpvIPoY93796714 = -522151015;    long zAMnzBUhjnDJhdKMkFzpvIPoY31898527 = -10263275;    long zAMnzBUhjnDJhdKMkFzpvIPoY5131575 = -11901107;    long zAMnzBUhjnDJhdKMkFzpvIPoY47274257 = -595601972;    long zAMnzBUhjnDJhdKMkFzpvIPoY45753844 = -762238267;    long zAMnzBUhjnDJhdKMkFzpvIPoY63916842 = -201035625;    long zAMnzBUhjnDJhdKMkFzpvIPoY95491955 = -825096095;    long zAMnzBUhjnDJhdKMkFzpvIPoY52436108 = -920760575;    long zAMnzBUhjnDJhdKMkFzpvIPoY10024212 = -557093204;    long zAMnzBUhjnDJhdKMkFzpvIPoY81832230 = -109198136;    long zAMnzBUhjnDJhdKMkFzpvIPoY43508023 = -174159247;    long zAMnzBUhjnDJhdKMkFzpvIPoY65766862 = -160365265;    long zAMnzBUhjnDJhdKMkFzpvIPoY68416307 = -644758073;    long zAMnzBUhjnDJhdKMkFzpvIPoY83278991 = -215974338;    long zAMnzBUhjnDJhdKMkFzpvIPoY73424639 = -434333049;    long zAMnzBUhjnDJhdKMkFzpvIPoY96064565 = -174851832;    long zAMnzBUhjnDJhdKMkFzpvIPoY46818711 = -607106913;    long zAMnzBUhjnDJhdKMkFzpvIPoY53519917 = -339183695;    long zAMnzBUhjnDJhdKMkFzpvIPoY52086731 = -166322037;    long zAMnzBUhjnDJhdKMkFzpvIPoY97783959 = -506622817;    long zAMnzBUhjnDJhdKMkFzpvIPoY17022037 = -982095086;    long zAMnzBUhjnDJhdKMkFzpvIPoY37818956 = -201763540;    long zAMnzBUhjnDJhdKMkFzpvIPoY82011212 = -200935882;    long zAMnzBUhjnDJhdKMkFzpvIPoY81548911 = -608918974;    long zAMnzBUhjnDJhdKMkFzpvIPoY59003459 = -634158141;    long zAMnzBUhjnDJhdKMkFzpvIPoY35703763 = -220048498;    long zAMnzBUhjnDJhdKMkFzpvIPoY30078786 = -898096325;    long zAMnzBUhjnDJhdKMkFzpvIPoY12467849 = -102553179;    long zAMnzBUhjnDJhdKMkFzpvIPoY17834947 = -685456717;    long zAMnzBUhjnDJhdKMkFzpvIPoY45387186 = -41771858;    long zAMnzBUhjnDJhdKMkFzpvIPoY82704035 = -17429273;    long zAMnzBUhjnDJhdKMkFzpvIPoY36252823 = -25172044;    long zAMnzBUhjnDJhdKMkFzpvIPoY67199958 = -293461753;    long zAMnzBUhjnDJhdKMkFzpvIPoY81314422 = -908896076;    long zAMnzBUhjnDJhdKMkFzpvIPoY1851965 = -190895868;    long zAMnzBUhjnDJhdKMkFzpvIPoY45026801 = -244852787;    long zAMnzBUhjnDJhdKMkFzpvIPoY74371273 = -241028437;    long zAMnzBUhjnDJhdKMkFzpvIPoY62912769 = -884025945;    long zAMnzBUhjnDJhdKMkFzpvIPoY40991962 = -417965265;    long zAMnzBUhjnDJhdKMkFzpvIPoY28664972 = -821635061;    long zAMnzBUhjnDJhdKMkFzpvIPoY96848208 = -577870936;    long zAMnzBUhjnDJhdKMkFzpvIPoY31149293 = 82662855;    long zAMnzBUhjnDJhdKMkFzpvIPoY56917629 = -56907317;    long zAMnzBUhjnDJhdKMkFzpvIPoY8454330 = -631745257;    long zAMnzBUhjnDJhdKMkFzpvIPoY90260967 = -221224489;    long zAMnzBUhjnDJhdKMkFzpvIPoY42007721 = -793100374;    long zAMnzBUhjnDJhdKMkFzpvIPoY77077950 = -796567221;    long zAMnzBUhjnDJhdKMkFzpvIPoY71254198 = -962963983;    long zAMnzBUhjnDJhdKMkFzpvIPoY65161295 = -125306266;    long zAMnzBUhjnDJhdKMkFzpvIPoY43307995 = -782052103;    long zAMnzBUhjnDJhdKMkFzpvIPoY56539066 = -140827965;    long zAMnzBUhjnDJhdKMkFzpvIPoY28428311 = -598786856;    long zAMnzBUhjnDJhdKMkFzpvIPoY30625343 = -818591325;    long zAMnzBUhjnDJhdKMkFzpvIPoY41200006 = -290789715;    long zAMnzBUhjnDJhdKMkFzpvIPoY66854731 = -104841466;    long zAMnzBUhjnDJhdKMkFzpvIPoY55977759 = -220387475;    long zAMnzBUhjnDJhdKMkFzpvIPoY49887314 = -809327393;    long zAMnzBUhjnDJhdKMkFzpvIPoY23582664 = -402982134;    long zAMnzBUhjnDJhdKMkFzpvIPoY88270798 = -961443832;    long zAMnzBUhjnDJhdKMkFzpvIPoY10050081 = -442189769;    long zAMnzBUhjnDJhdKMkFzpvIPoY33838057 = -302939301;    long zAMnzBUhjnDJhdKMkFzpvIPoY83024106 = -622542916;    long zAMnzBUhjnDJhdKMkFzpvIPoY34601161 = -288992722;     zAMnzBUhjnDJhdKMkFzpvIPoY44668546 = zAMnzBUhjnDJhdKMkFzpvIPoY90124123;     zAMnzBUhjnDJhdKMkFzpvIPoY90124123 = zAMnzBUhjnDJhdKMkFzpvIPoY607438;     zAMnzBUhjnDJhdKMkFzpvIPoY607438 = zAMnzBUhjnDJhdKMkFzpvIPoY4760797;     zAMnzBUhjnDJhdKMkFzpvIPoY4760797 = zAMnzBUhjnDJhdKMkFzpvIPoY72297772;     zAMnzBUhjnDJhdKMkFzpvIPoY72297772 = zAMnzBUhjnDJhdKMkFzpvIPoY15317902;     zAMnzBUhjnDJhdKMkFzpvIPoY15317902 = zAMnzBUhjnDJhdKMkFzpvIPoY66778041;     zAMnzBUhjnDJhdKMkFzpvIPoY66778041 = zAMnzBUhjnDJhdKMkFzpvIPoY81198020;     zAMnzBUhjnDJhdKMkFzpvIPoY81198020 = zAMnzBUhjnDJhdKMkFzpvIPoY84611975;     zAMnzBUhjnDJhdKMkFzpvIPoY84611975 = zAMnzBUhjnDJhdKMkFzpvIPoY51053784;     zAMnzBUhjnDJhdKMkFzpvIPoY51053784 = zAMnzBUhjnDJhdKMkFzpvIPoY57207506;     zAMnzBUhjnDJhdKMkFzpvIPoY57207506 = zAMnzBUhjnDJhdKMkFzpvIPoY48744963;     zAMnzBUhjnDJhdKMkFzpvIPoY48744963 = zAMnzBUhjnDJhdKMkFzpvIPoY64652262;     zAMnzBUhjnDJhdKMkFzpvIPoY64652262 = zAMnzBUhjnDJhdKMkFzpvIPoY18964898;     zAMnzBUhjnDJhdKMkFzpvIPoY18964898 = zAMnzBUhjnDJhdKMkFzpvIPoY6183924;     zAMnzBUhjnDJhdKMkFzpvIPoY6183924 = zAMnzBUhjnDJhdKMkFzpvIPoY65191191;     zAMnzBUhjnDJhdKMkFzpvIPoY65191191 = zAMnzBUhjnDJhdKMkFzpvIPoY95648679;     zAMnzBUhjnDJhdKMkFzpvIPoY95648679 = zAMnzBUhjnDJhdKMkFzpvIPoY76925327;     zAMnzBUhjnDJhdKMkFzpvIPoY76925327 = zAMnzBUhjnDJhdKMkFzpvIPoY79502848;     zAMnzBUhjnDJhdKMkFzpvIPoY79502848 = zAMnzBUhjnDJhdKMkFzpvIPoY10187027;     zAMnzBUhjnDJhdKMkFzpvIPoY10187027 = zAMnzBUhjnDJhdKMkFzpvIPoY86745805;     zAMnzBUhjnDJhdKMkFzpvIPoY86745805 = zAMnzBUhjnDJhdKMkFzpvIPoY92581814;     zAMnzBUhjnDJhdKMkFzpvIPoY92581814 = zAMnzBUhjnDJhdKMkFzpvIPoY92340163;     zAMnzBUhjnDJhdKMkFzpvIPoY92340163 = zAMnzBUhjnDJhdKMkFzpvIPoY83585401;     zAMnzBUhjnDJhdKMkFzpvIPoY83585401 = zAMnzBUhjnDJhdKMkFzpvIPoY66941840;     zAMnzBUhjnDJhdKMkFzpvIPoY66941840 = zAMnzBUhjnDJhdKMkFzpvIPoY90286560;     zAMnzBUhjnDJhdKMkFzpvIPoY90286560 = zAMnzBUhjnDJhdKMkFzpvIPoY33768991;     zAMnzBUhjnDJhdKMkFzpvIPoY33768991 = zAMnzBUhjnDJhdKMkFzpvIPoY7774583;     zAMnzBUhjnDJhdKMkFzpvIPoY7774583 = zAMnzBUhjnDJhdKMkFzpvIPoY45494257;     zAMnzBUhjnDJhdKMkFzpvIPoY45494257 = zAMnzBUhjnDJhdKMkFzpvIPoY54533190;     zAMnzBUhjnDJhdKMkFzpvIPoY54533190 = zAMnzBUhjnDJhdKMkFzpvIPoY38585935;     zAMnzBUhjnDJhdKMkFzpvIPoY38585935 = zAMnzBUhjnDJhdKMkFzpvIPoY39372560;     zAMnzBUhjnDJhdKMkFzpvIPoY39372560 = zAMnzBUhjnDJhdKMkFzpvIPoY3357778;     zAMnzBUhjnDJhdKMkFzpvIPoY3357778 = zAMnzBUhjnDJhdKMkFzpvIPoY81948227;     zAMnzBUhjnDJhdKMkFzpvIPoY81948227 = zAMnzBUhjnDJhdKMkFzpvIPoY82712074;     zAMnzBUhjnDJhdKMkFzpvIPoY82712074 = zAMnzBUhjnDJhdKMkFzpvIPoY38983966;     zAMnzBUhjnDJhdKMkFzpvIPoY38983966 = zAMnzBUhjnDJhdKMkFzpvIPoY83876768;     zAMnzBUhjnDJhdKMkFzpvIPoY83876768 = zAMnzBUhjnDJhdKMkFzpvIPoY93796714;     zAMnzBUhjnDJhdKMkFzpvIPoY93796714 = zAMnzBUhjnDJhdKMkFzpvIPoY31898527;     zAMnzBUhjnDJhdKMkFzpvIPoY31898527 = zAMnzBUhjnDJhdKMkFzpvIPoY5131575;     zAMnzBUhjnDJhdKMkFzpvIPoY5131575 = zAMnzBUhjnDJhdKMkFzpvIPoY47274257;     zAMnzBUhjnDJhdKMkFzpvIPoY47274257 = zAMnzBUhjnDJhdKMkFzpvIPoY45753844;     zAMnzBUhjnDJhdKMkFzpvIPoY45753844 = zAMnzBUhjnDJhdKMkFzpvIPoY63916842;     zAMnzBUhjnDJhdKMkFzpvIPoY63916842 = zAMnzBUhjnDJhdKMkFzpvIPoY95491955;     zAMnzBUhjnDJhdKMkFzpvIPoY95491955 = zAMnzBUhjnDJhdKMkFzpvIPoY52436108;     zAMnzBUhjnDJhdKMkFzpvIPoY52436108 = zAMnzBUhjnDJhdKMkFzpvIPoY10024212;     zAMnzBUhjnDJhdKMkFzpvIPoY10024212 = zAMnzBUhjnDJhdKMkFzpvIPoY81832230;     zAMnzBUhjnDJhdKMkFzpvIPoY81832230 = zAMnzBUhjnDJhdKMkFzpvIPoY43508023;     zAMnzBUhjnDJhdKMkFzpvIPoY43508023 = zAMnzBUhjnDJhdKMkFzpvIPoY65766862;     zAMnzBUhjnDJhdKMkFzpvIPoY65766862 = zAMnzBUhjnDJhdKMkFzpvIPoY68416307;     zAMnzBUhjnDJhdKMkFzpvIPoY68416307 = zAMnzBUhjnDJhdKMkFzpvIPoY83278991;     zAMnzBUhjnDJhdKMkFzpvIPoY83278991 = zAMnzBUhjnDJhdKMkFzpvIPoY73424639;     zAMnzBUhjnDJhdKMkFzpvIPoY73424639 = zAMnzBUhjnDJhdKMkFzpvIPoY96064565;     zAMnzBUhjnDJhdKMkFzpvIPoY96064565 = zAMnzBUhjnDJhdKMkFzpvIPoY46818711;     zAMnzBUhjnDJhdKMkFzpvIPoY46818711 = zAMnzBUhjnDJhdKMkFzpvIPoY53519917;     zAMnzBUhjnDJhdKMkFzpvIPoY53519917 = zAMnzBUhjnDJhdKMkFzpvIPoY52086731;     zAMnzBUhjnDJhdKMkFzpvIPoY52086731 = zAMnzBUhjnDJhdKMkFzpvIPoY97783959;     zAMnzBUhjnDJhdKMkFzpvIPoY97783959 = zAMnzBUhjnDJhdKMkFzpvIPoY17022037;     zAMnzBUhjnDJhdKMkFzpvIPoY17022037 = zAMnzBUhjnDJhdKMkFzpvIPoY37818956;     zAMnzBUhjnDJhdKMkFzpvIPoY37818956 = zAMnzBUhjnDJhdKMkFzpvIPoY82011212;     zAMnzBUhjnDJhdKMkFzpvIPoY82011212 = zAMnzBUhjnDJhdKMkFzpvIPoY81548911;     zAMnzBUhjnDJhdKMkFzpvIPoY81548911 = zAMnzBUhjnDJhdKMkFzpvIPoY59003459;     zAMnzBUhjnDJhdKMkFzpvIPoY59003459 = zAMnzBUhjnDJhdKMkFzpvIPoY35703763;     zAMnzBUhjnDJhdKMkFzpvIPoY35703763 = zAMnzBUhjnDJhdKMkFzpvIPoY30078786;     zAMnzBUhjnDJhdKMkFzpvIPoY30078786 = zAMnzBUhjnDJhdKMkFzpvIPoY12467849;     zAMnzBUhjnDJhdKMkFzpvIPoY12467849 = zAMnzBUhjnDJhdKMkFzpvIPoY17834947;     zAMnzBUhjnDJhdKMkFzpvIPoY17834947 = zAMnzBUhjnDJhdKMkFzpvIPoY45387186;     zAMnzBUhjnDJhdKMkFzpvIPoY45387186 = zAMnzBUhjnDJhdKMkFzpvIPoY82704035;     zAMnzBUhjnDJhdKMkFzpvIPoY82704035 = zAMnzBUhjnDJhdKMkFzpvIPoY36252823;     zAMnzBUhjnDJhdKMkFzpvIPoY36252823 = zAMnzBUhjnDJhdKMkFzpvIPoY67199958;     zAMnzBUhjnDJhdKMkFzpvIPoY67199958 = zAMnzBUhjnDJhdKMkFzpvIPoY81314422;     zAMnzBUhjnDJhdKMkFzpvIPoY81314422 = zAMnzBUhjnDJhdKMkFzpvIPoY1851965;     zAMnzBUhjnDJhdKMkFzpvIPoY1851965 = zAMnzBUhjnDJhdKMkFzpvIPoY45026801;     zAMnzBUhjnDJhdKMkFzpvIPoY45026801 = zAMnzBUhjnDJhdKMkFzpvIPoY74371273;     zAMnzBUhjnDJhdKMkFzpvIPoY74371273 = zAMnzBUhjnDJhdKMkFzpvIPoY62912769;     zAMnzBUhjnDJhdKMkFzpvIPoY62912769 = zAMnzBUhjnDJhdKMkFzpvIPoY40991962;     zAMnzBUhjnDJhdKMkFzpvIPoY40991962 = zAMnzBUhjnDJhdKMkFzpvIPoY28664972;     zAMnzBUhjnDJhdKMkFzpvIPoY28664972 = zAMnzBUhjnDJhdKMkFzpvIPoY96848208;     zAMnzBUhjnDJhdKMkFzpvIPoY96848208 = zAMnzBUhjnDJhdKMkFzpvIPoY31149293;     zAMnzBUhjnDJhdKMkFzpvIPoY31149293 = zAMnzBUhjnDJhdKMkFzpvIPoY56917629;     zAMnzBUhjnDJhdKMkFzpvIPoY56917629 = zAMnzBUhjnDJhdKMkFzpvIPoY8454330;     zAMnzBUhjnDJhdKMkFzpvIPoY8454330 = zAMnzBUhjnDJhdKMkFzpvIPoY90260967;     zAMnzBUhjnDJhdKMkFzpvIPoY90260967 = zAMnzBUhjnDJhdKMkFzpvIPoY42007721;     zAMnzBUhjnDJhdKMkFzpvIPoY42007721 = zAMnzBUhjnDJhdKMkFzpvIPoY77077950;     zAMnzBUhjnDJhdKMkFzpvIPoY77077950 = zAMnzBUhjnDJhdKMkFzpvIPoY71254198;     zAMnzBUhjnDJhdKMkFzpvIPoY71254198 = zAMnzBUhjnDJhdKMkFzpvIPoY65161295;     zAMnzBUhjnDJhdKMkFzpvIPoY65161295 = zAMnzBUhjnDJhdKMkFzpvIPoY43307995;     zAMnzBUhjnDJhdKMkFzpvIPoY43307995 = zAMnzBUhjnDJhdKMkFzpvIPoY56539066;     zAMnzBUhjnDJhdKMkFzpvIPoY56539066 = zAMnzBUhjnDJhdKMkFzpvIPoY28428311;     zAMnzBUhjnDJhdKMkFzpvIPoY28428311 = zAMnzBUhjnDJhdKMkFzpvIPoY30625343;     zAMnzBUhjnDJhdKMkFzpvIPoY30625343 = zAMnzBUhjnDJhdKMkFzpvIPoY41200006;     zAMnzBUhjnDJhdKMkFzpvIPoY41200006 = zAMnzBUhjnDJhdKMkFzpvIPoY66854731;     zAMnzBUhjnDJhdKMkFzpvIPoY66854731 = zAMnzBUhjnDJhdKMkFzpvIPoY55977759;     zAMnzBUhjnDJhdKMkFzpvIPoY55977759 = zAMnzBUhjnDJhdKMkFzpvIPoY49887314;     zAMnzBUhjnDJhdKMkFzpvIPoY49887314 = zAMnzBUhjnDJhdKMkFzpvIPoY23582664;     zAMnzBUhjnDJhdKMkFzpvIPoY23582664 = zAMnzBUhjnDJhdKMkFzpvIPoY88270798;     zAMnzBUhjnDJhdKMkFzpvIPoY88270798 = zAMnzBUhjnDJhdKMkFzpvIPoY10050081;     zAMnzBUhjnDJhdKMkFzpvIPoY10050081 = zAMnzBUhjnDJhdKMkFzpvIPoY33838057;     zAMnzBUhjnDJhdKMkFzpvIPoY33838057 = zAMnzBUhjnDJhdKMkFzpvIPoY83024106;     zAMnzBUhjnDJhdKMkFzpvIPoY83024106 = zAMnzBUhjnDJhdKMkFzpvIPoY34601161;     zAMnzBUhjnDJhdKMkFzpvIPoY34601161 = zAMnzBUhjnDJhdKMkFzpvIPoY44668546;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void KnRIduHkjrcyYhriGkbzZZeyMQleceeLlNwMcWKXGkPwuIySVuvzJItlI55314790() {     long SwNJdIENQNKkfFjZEtpJiEESS50785652 = -400894611;    long SwNJdIENQNKkfFjZEtpJiEESS33497403 = -719189627;    long SwNJdIENQNKkfFjZEtpJiEESS16649622 = 28974275;    long SwNJdIENQNKkfFjZEtpJiEESS31835577 = -106512690;    long SwNJdIENQNKkfFjZEtpJiEESS41193261 = -562529146;    long SwNJdIENQNKkfFjZEtpJiEESS6735105 = -368798944;    long SwNJdIENQNKkfFjZEtpJiEESS27267008 = -826588756;    long SwNJdIENQNKkfFjZEtpJiEESS30957911 = 51752295;    long SwNJdIENQNKkfFjZEtpJiEESS49254471 = -945067310;    long SwNJdIENQNKkfFjZEtpJiEESS92283442 = -91167970;    long SwNJdIENQNKkfFjZEtpJiEESS17317797 = -619798238;    long SwNJdIENQNKkfFjZEtpJiEESS80568005 = -334112938;    long SwNJdIENQNKkfFjZEtpJiEESS50861380 = -495290911;    long SwNJdIENQNKkfFjZEtpJiEESS2108575 = -642323973;    long SwNJdIENQNKkfFjZEtpJiEESS1926351 = -881336451;    long SwNJdIENQNKkfFjZEtpJiEESS6696585 = 31167830;    long SwNJdIENQNKkfFjZEtpJiEESS89484682 = -329591995;    long SwNJdIENQNKkfFjZEtpJiEESS73978480 = -20638704;    long SwNJdIENQNKkfFjZEtpJiEESS41332690 = -758698640;    long SwNJdIENQNKkfFjZEtpJiEESS90737190 = -836530836;    long SwNJdIENQNKkfFjZEtpJiEESS75298998 = -35690987;    long SwNJdIENQNKkfFjZEtpJiEESS79102838 = 69399598;    long SwNJdIENQNKkfFjZEtpJiEESS27930956 = -149484517;    long SwNJdIENQNKkfFjZEtpJiEESS67577775 = -60402707;    long SwNJdIENQNKkfFjZEtpJiEESS10641491 = 12803447;    long SwNJdIENQNKkfFjZEtpJiEESS15008236 = -719598716;    long SwNJdIENQNKkfFjZEtpJiEESS32228769 = -396045939;    long SwNJdIENQNKkfFjZEtpJiEESS20881708 = -19394592;    long SwNJdIENQNKkfFjZEtpJiEESS11626513 = -663707998;    long SwNJdIENQNKkfFjZEtpJiEESS23148827 = 3590812;    long SwNJdIENQNKkfFjZEtpJiEESS30828485 = -572960252;    long SwNJdIENQNKkfFjZEtpJiEESS36983182 = -766350750;    long SwNJdIENQNKkfFjZEtpJiEESS13068726 = -740548248;    long SwNJdIENQNKkfFjZEtpJiEESS76778791 = -789512315;    long SwNJdIENQNKkfFjZEtpJiEESS44186726 = -623646467;    long SwNJdIENQNKkfFjZEtpJiEESS7709879 = -11438640;    long SwNJdIENQNKkfFjZEtpJiEESS65138702 = -40572421;    long SwNJdIENQNKkfFjZEtpJiEESS27886928 = -293657024;    long SwNJdIENQNKkfFjZEtpJiEESS5508781 = -4186772;    long SwNJdIENQNKkfFjZEtpJiEESS92633512 = -485340330;    long SwNJdIENQNKkfFjZEtpJiEESS52943481 = -660875866;    long SwNJdIENQNKkfFjZEtpJiEESS77904300 = 67619455;    long SwNJdIENQNKkfFjZEtpJiEESS41983821 = -281840209;    long SwNJdIENQNKkfFjZEtpJiEESS82899695 = -844439033;    long SwNJdIENQNKkfFjZEtpJiEESS64388573 = -582658729;    long SwNJdIENQNKkfFjZEtpJiEESS21963407 = -542309320;    long SwNJdIENQNKkfFjZEtpJiEESS99610805 = -227973674;    long SwNJdIENQNKkfFjZEtpJiEESS51464964 = -184054779;    long SwNJdIENQNKkfFjZEtpJiEESS75442591 = -246102253;    long SwNJdIENQNKkfFjZEtpJiEESS81327959 = -731768881;    long SwNJdIENQNKkfFjZEtpJiEESS18979670 = -58268009;    long SwNJdIENQNKkfFjZEtpJiEESS84234359 = -235059369;    long SwNJdIENQNKkfFjZEtpJiEESS44313023 = 33358581;    long SwNJdIENQNKkfFjZEtpJiEESS42787591 = -927577058;    long SwNJdIENQNKkfFjZEtpJiEESS80015791 = 60284523;    long SwNJdIENQNKkfFjZEtpJiEESS71682814 = -370294209;    long SwNJdIENQNKkfFjZEtpJiEESS5566448 = -469705111;    long SwNJdIENQNKkfFjZEtpJiEESS49071847 = -910623019;    long SwNJdIENQNKkfFjZEtpJiEESS21194087 = -19316137;    long SwNJdIENQNKkfFjZEtpJiEESS26185026 = -842930430;    long SwNJdIENQNKkfFjZEtpJiEESS74506335 = -972753006;    long SwNJdIENQNKkfFjZEtpJiEESS6385300 = -707194165;    long SwNJdIENQNKkfFjZEtpJiEESS19331399 = -284539707;    long SwNJdIENQNKkfFjZEtpJiEESS26105645 = -848658123;    long SwNJdIENQNKkfFjZEtpJiEESS61454958 = -518207718;    long SwNJdIENQNKkfFjZEtpJiEESS80334615 = -853447488;    long SwNJdIENQNKkfFjZEtpJiEESS67499280 = -593564690;    long SwNJdIENQNKkfFjZEtpJiEESS74082589 = -705778596;    long SwNJdIENQNKkfFjZEtpJiEESS57921848 = 81322493;    long SwNJdIENQNKkfFjZEtpJiEESS94216471 = -769897812;    long SwNJdIENQNKkfFjZEtpJiEESS41557882 = -928259750;    long SwNJdIENQNKkfFjZEtpJiEESS61597755 = 64065029;    long SwNJdIENQNKkfFjZEtpJiEESS68469700 = 83548067;    long SwNJdIENQNKkfFjZEtpJiEESS48699177 = -173358311;    long SwNJdIENQNKkfFjZEtpJiEESS37793710 = -75654970;    long SwNJdIENQNKkfFjZEtpJiEESS97394697 = -3310443;    long SwNJdIENQNKkfFjZEtpJiEESS37119018 = -648760194;    long SwNJdIENQNKkfFjZEtpJiEESS45031260 = -305045484;    long SwNJdIENQNKkfFjZEtpJiEESS3189202 = -477743978;    long SwNJdIENQNKkfFjZEtpJiEESS88678084 = -444887234;    long SwNJdIENQNKkfFjZEtpJiEESS15397431 = -391625043;    long SwNJdIENQNKkfFjZEtpJiEESS80763805 = -111991160;    long SwNJdIENQNKkfFjZEtpJiEESS45439117 = -773292339;    long SwNJdIENQNKkfFjZEtpJiEESS30298553 = -931939117;    long SwNJdIENQNKkfFjZEtpJiEESS4169158 = -938141179;    long SwNJdIENQNKkfFjZEtpJiEESS46594125 = -237900883;    long SwNJdIENQNKkfFjZEtpJiEESS92670159 = -699709331;    long SwNJdIENQNKkfFjZEtpJiEESS70281135 = -812971190;    long SwNJdIENQNKkfFjZEtpJiEESS96762999 = -749796838;    long SwNJdIENQNKkfFjZEtpJiEESS72503912 = -153352258;    long SwNJdIENQNKkfFjZEtpJiEESS2143432 = -541733529;    long SwNJdIENQNKkfFjZEtpJiEESS16066856 = -129949402;    long SwNJdIENQNKkfFjZEtpJiEESS6692841 = -174340887;    long SwNJdIENQNKkfFjZEtpJiEESS79323754 = -161256342;    long SwNJdIENQNKkfFjZEtpJiEESS18127178 = -512587325;    long SwNJdIENQNKkfFjZEtpJiEESS46558182 = -953681702;    long SwNJdIENQNKkfFjZEtpJiEESS58572902 = -647840839;    long SwNJdIENQNKkfFjZEtpJiEESS15878177 = -433182086;    long SwNJdIENQNKkfFjZEtpJiEESS21444737 = -226231315;    long SwNJdIENQNKkfFjZEtpJiEESS84053958 = -400894611;     SwNJdIENQNKkfFjZEtpJiEESS50785652 = SwNJdIENQNKkfFjZEtpJiEESS33497403;     SwNJdIENQNKkfFjZEtpJiEESS33497403 = SwNJdIENQNKkfFjZEtpJiEESS16649622;     SwNJdIENQNKkfFjZEtpJiEESS16649622 = SwNJdIENQNKkfFjZEtpJiEESS31835577;     SwNJdIENQNKkfFjZEtpJiEESS31835577 = SwNJdIENQNKkfFjZEtpJiEESS41193261;     SwNJdIENQNKkfFjZEtpJiEESS41193261 = SwNJdIENQNKkfFjZEtpJiEESS6735105;     SwNJdIENQNKkfFjZEtpJiEESS6735105 = SwNJdIENQNKkfFjZEtpJiEESS27267008;     SwNJdIENQNKkfFjZEtpJiEESS27267008 = SwNJdIENQNKkfFjZEtpJiEESS30957911;     SwNJdIENQNKkfFjZEtpJiEESS30957911 = SwNJdIENQNKkfFjZEtpJiEESS49254471;     SwNJdIENQNKkfFjZEtpJiEESS49254471 = SwNJdIENQNKkfFjZEtpJiEESS92283442;     SwNJdIENQNKkfFjZEtpJiEESS92283442 = SwNJdIENQNKkfFjZEtpJiEESS17317797;     SwNJdIENQNKkfFjZEtpJiEESS17317797 = SwNJdIENQNKkfFjZEtpJiEESS80568005;     SwNJdIENQNKkfFjZEtpJiEESS80568005 = SwNJdIENQNKkfFjZEtpJiEESS50861380;     SwNJdIENQNKkfFjZEtpJiEESS50861380 = SwNJdIENQNKkfFjZEtpJiEESS2108575;     SwNJdIENQNKkfFjZEtpJiEESS2108575 = SwNJdIENQNKkfFjZEtpJiEESS1926351;     SwNJdIENQNKkfFjZEtpJiEESS1926351 = SwNJdIENQNKkfFjZEtpJiEESS6696585;     SwNJdIENQNKkfFjZEtpJiEESS6696585 = SwNJdIENQNKkfFjZEtpJiEESS89484682;     SwNJdIENQNKkfFjZEtpJiEESS89484682 = SwNJdIENQNKkfFjZEtpJiEESS73978480;     SwNJdIENQNKkfFjZEtpJiEESS73978480 = SwNJdIENQNKkfFjZEtpJiEESS41332690;     SwNJdIENQNKkfFjZEtpJiEESS41332690 = SwNJdIENQNKkfFjZEtpJiEESS90737190;     SwNJdIENQNKkfFjZEtpJiEESS90737190 = SwNJdIENQNKkfFjZEtpJiEESS75298998;     SwNJdIENQNKkfFjZEtpJiEESS75298998 = SwNJdIENQNKkfFjZEtpJiEESS79102838;     SwNJdIENQNKkfFjZEtpJiEESS79102838 = SwNJdIENQNKkfFjZEtpJiEESS27930956;     SwNJdIENQNKkfFjZEtpJiEESS27930956 = SwNJdIENQNKkfFjZEtpJiEESS67577775;     SwNJdIENQNKkfFjZEtpJiEESS67577775 = SwNJdIENQNKkfFjZEtpJiEESS10641491;     SwNJdIENQNKkfFjZEtpJiEESS10641491 = SwNJdIENQNKkfFjZEtpJiEESS15008236;     SwNJdIENQNKkfFjZEtpJiEESS15008236 = SwNJdIENQNKkfFjZEtpJiEESS32228769;     SwNJdIENQNKkfFjZEtpJiEESS32228769 = SwNJdIENQNKkfFjZEtpJiEESS20881708;     SwNJdIENQNKkfFjZEtpJiEESS20881708 = SwNJdIENQNKkfFjZEtpJiEESS11626513;     SwNJdIENQNKkfFjZEtpJiEESS11626513 = SwNJdIENQNKkfFjZEtpJiEESS23148827;     SwNJdIENQNKkfFjZEtpJiEESS23148827 = SwNJdIENQNKkfFjZEtpJiEESS30828485;     SwNJdIENQNKkfFjZEtpJiEESS30828485 = SwNJdIENQNKkfFjZEtpJiEESS36983182;     SwNJdIENQNKkfFjZEtpJiEESS36983182 = SwNJdIENQNKkfFjZEtpJiEESS13068726;     SwNJdIENQNKkfFjZEtpJiEESS13068726 = SwNJdIENQNKkfFjZEtpJiEESS76778791;     SwNJdIENQNKkfFjZEtpJiEESS76778791 = SwNJdIENQNKkfFjZEtpJiEESS44186726;     SwNJdIENQNKkfFjZEtpJiEESS44186726 = SwNJdIENQNKkfFjZEtpJiEESS7709879;     SwNJdIENQNKkfFjZEtpJiEESS7709879 = SwNJdIENQNKkfFjZEtpJiEESS65138702;     SwNJdIENQNKkfFjZEtpJiEESS65138702 = SwNJdIENQNKkfFjZEtpJiEESS27886928;     SwNJdIENQNKkfFjZEtpJiEESS27886928 = SwNJdIENQNKkfFjZEtpJiEESS5508781;     SwNJdIENQNKkfFjZEtpJiEESS5508781 = SwNJdIENQNKkfFjZEtpJiEESS92633512;     SwNJdIENQNKkfFjZEtpJiEESS92633512 = SwNJdIENQNKkfFjZEtpJiEESS52943481;     SwNJdIENQNKkfFjZEtpJiEESS52943481 = SwNJdIENQNKkfFjZEtpJiEESS77904300;     SwNJdIENQNKkfFjZEtpJiEESS77904300 = SwNJdIENQNKkfFjZEtpJiEESS41983821;     SwNJdIENQNKkfFjZEtpJiEESS41983821 = SwNJdIENQNKkfFjZEtpJiEESS82899695;     SwNJdIENQNKkfFjZEtpJiEESS82899695 = SwNJdIENQNKkfFjZEtpJiEESS64388573;     SwNJdIENQNKkfFjZEtpJiEESS64388573 = SwNJdIENQNKkfFjZEtpJiEESS21963407;     SwNJdIENQNKkfFjZEtpJiEESS21963407 = SwNJdIENQNKkfFjZEtpJiEESS99610805;     SwNJdIENQNKkfFjZEtpJiEESS99610805 = SwNJdIENQNKkfFjZEtpJiEESS51464964;     SwNJdIENQNKkfFjZEtpJiEESS51464964 = SwNJdIENQNKkfFjZEtpJiEESS75442591;     SwNJdIENQNKkfFjZEtpJiEESS75442591 = SwNJdIENQNKkfFjZEtpJiEESS81327959;     SwNJdIENQNKkfFjZEtpJiEESS81327959 = SwNJdIENQNKkfFjZEtpJiEESS18979670;     SwNJdIENQNKkfFjZEtpJiEESS18979670 = SwNJdIENQNKkfFjZEtpJiEESS84234359;     SwNJdIENQNKkfFjZEtpJiEESS84234359 = SwNJdIENQNKkfFjZEtpJiEESS44313023;     SwNJdIENQNKkfFjZEtpJiEESS44313023 = SwNJdIENQNKkfFjZEtpJiEESS42787591;     SwNJdIENQNKkfFjZEtpJiEESS42787591 = SwNJdIENQNKkfFjZEtpJiEESS80015791;     SwNJdIENQNKkfFjZEtpJiEESS80015791 = SwNJdIENQNKkfFjZEtpJiEESS71682814;     SwNJdIENQNKkfFjZEtpJiEESS71682814 = SwNJdIENQNKkfFjZEtpJiEESS5566448;     SwNJdIENQNKkfFjZEtpJiEESS5566448 = SwNJdIENQNKkfFjZEtpJiEESS49071847;     SwNJdIENQNKkfFjZEtpJiEESS49071847 = SwNJdIENQNKkfFjZEtpJiEESS21194087;     SwNJdIENQNKkfFjZEtpJiEESS21194087 = SwNJdIENQNKkfFjZEtpJiEESS26185026;     SwNJdIENQNKkfFjZEtpJiEESS26185026 = SwNJdIENQNKkfFjZEtpJiEESS74506335;     SwNJdIENQNKkfFjZEtpJiEESS74506335 = SwNJdIENQNKkfFjZEtpJiEESS6385300;     SwNJdIENQNKkfFjZEtpJiEESS6385300 = SwNJdIENQNKkfFjZEtpJiEESS19331399;     SwNJdIENQNKkfFjZEtpJiEESS19331399 = SwNJdIENQNKkfFjZEtpJiEESS26105645;     SwNJdIENQNKkfFjZEtpJiEESS26105645 = SwNJdIENQNKkfFjZEtpJiEESS61454958;     SwNJdIENQNKkfFjZEtpJiEESS61454958 = SwNJdIENQNKkfFjZEtpJiEESS80334615;     SwNJdIENQNKkfFjZEtpJiEESS80334615 = SwNJdIENQNKkfFjZEtpJiEESS67499280;     SwNJdIENQNKkfFjZEtpJiEESS67499280 = SwNJdIENQNKkfFjZEtpJiEESS74082589;     SwNJdIENQNKkfFjZEtpJiEESS74082589 = SwNJdIENQNKkfFjZEtpJiEESS57921848;     SwNJdIENQNKkfFjZEtpJiEESS57921848 = SwNJdIENQNKkfFjZEtpJiEESS94216471;     SwNJdIENQNKkfFjZEtpJiEESS94216471 = SwNJdIENQNKkfFjZEtpJiEESS41557882;     SwNJdIENQNKkfFjZEtpJiEESS41557882 = SwNJdIENQNKkfFjZEtpJiEESS61597755;     SwNJdIENQNKkfFjZEtpJiEESS61597755 = SwNJdIENQNKkfFjZEtpJiEESS68469700;     SwNJdIENQNKkfFjZEtpJiEESS68469700 = SwNJdIENQNKkfFjZEtpJiEESS48699177;     SwNJdIENQNKkfFjZEtpJiEESS48699177 = SwNJdIENQNKkfFjZEtpJiEESS37793710;     SwNJdIENQNKkfFjZEtpJiEESS37793710 = SwNJdIENQNKkfFjZEtpJiEESS97394697;     SwNJdIENQNKkfFjZEtpJiEESS97394697 = SwNJdIENQNKkfFjZEtpJiEESS37119018;     SwNJdIENQNKkfFjZEtpJiEESS37119018 = SwNJdIENQNKkfFjZEtpJiEESS45031260;     SwNJdIENQNKkfFjZEtpJiEESS45031260 = SwNJdIENQNKkfFjZEtpJiEESS3189202;     SwNJdIENQNKkfFjZEtpJiEESS3189202 = SwNJdIENQNKkfFjZEtpJiEESS88678084;     SwNJdIENQNKkfFjZEtpJiEESS88678084 = SwNJdIENQNKkfFjZEtpJiEESS15397431;     SwNJdIENQNKkfFjZEtpJiEESS15397431 = SwNJdIENQNKkfFjZEtpJiEESS80763805;     SwNJdIENQNKkfFjZEtpJiEESS80763805 = SwNJdIENQNKkfFjZEtpJiEESS45439117;     SwNJdIENQNKkfFjZEtpJiEESS45439117 = SwNJdIENQNKkfFjZEtpJiEESS30298553;     SwNJdIENQNKkfFjZEtpJiEESS30298553 = SwNJdIENQNKkfFjZEtpJiEESS4169158;     SwNJdIENQNKkfFjZEtpJiEESS4169158 = SwNJdIENQNKkfFjZEtpJiEESS46594125;     SwNJdIENQNKkfFjZEtpJiEESS46594125 = SwNJdIENQNKkfFjZEtpJiEESS92670159;     SwNJdIENQNKkfFjZEtpJiEESS92670159 = SwNJdIENQNKkfFjZEtpJiEESS70281135;     SwNJdIENQNKkfFjZEtpJiEESS70281135 = SwNJdIENQNKkfFjZEtpJiEESS96762999;     SwNJdIENQNKkfFjZEtpJiEESS96762999 = SwNJdIENQNKkfFjZEtpJiEESS72503912;     SwNJdIENQNKkfFjZEtpJiEESS72503912 = SwNJdIENQNKkfFjZEtpJiEESS2143432;     SwNJdIENQNKkfFjZEtpJiEESS2143432 = SwNJdIENQNKkfFjZEtpJiEESS16066856;     SwNJdIENQNKkfFjZEtpJiEESS16066856 = SwNJdIENQNKkfFjZEtpJiEESS6692841;     SwNJdIENQNKkfFjZEtpJiEESS6692841 = SwNJdIENQNKkfFjZEtpJiEESS79323754;     SwNJdIENQNKkfFjZEtpJiEESS79323754 = SwNJdIENQNKkfFjZEtpJiEESS18127178;     SwNJdIENQNKkfFjZEtpJiEESS18127178 = SwNJdIENQNKkfFjZEtpJiEESS46558182;     SwNJdIENQNKkfFjZEtpJiEESS46558182 = SwNJdIENQNKkfFjZEtpJiEESS58572902;     SwNJdIENQNKkfFjZEtpJiEESS58572902 = SwNJdIENQNKkfFjZEtpJiEESS15878177;     SwNJdIENQNKkfFjZEtpJiEESS15878177 = SwNJdIENQNKkfFjZEtpJiEESS21444737;     SwNJdIENQNKkfFjZEtpJiEESS21444737 = SwNJdIENQNKkfFjZEtpJiEESS84053958;     SwNJdIENQNKkfFjZEtpJiEESS84053958 = SwNJdIENQNKkfFjZEtpJiEESS50785652;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void tBfHDScKbccZKGUcYitFhvqnEWEWImsaBnPmyGFmTncXpcDLGpsOuZtxK22606390() {     long sChNFCojBYWqhdRcGmuTTxcTt86244620 = -867171510;    long sChNFCojBYWqhdRcGmuTTxcTt46769481 = -599741234;    long sChNFCojBYWqhdRcGmuTTxcTt54036098 = -736692800;    long sChNFCojBYWqhdRcGmuTTxcTt4058932 = 72336239;    long sChNFCojBYWqhdRcGmuTTxcTt97478530 = -668127991;    long sChNFCojBYWqhdRcGmuTTxcTt42957976 = -631146839;    long sChNFCojBYWqhdRcGmuTTxcTt37924414 = -671314490;    long sChNFCojBYWqhdRcGmuTTxcTt93089471 = -692481845;    long sChNFCojBYWqhdRcGmuTTxcTt50772076 = -333398717;    long sChNFCojBYWqhdRcGmuTTxcTt7186155 = -855854968;    long sChNFCojBYWqhdRcGmuTTxcTt55499531 = -421805967;    long sChNFCojBYWqhdRcGmuTTxcTt81136154 = -198233709;    long sChNFCojBYWqhdRcGmuTTxcTt89096025 = 52696584;    long sChNFCojBYWqhdRcGmuTTxcTt55249437 = -618687382;    long sChNFCojBYWqhdRcGmuTTxcTt60120867 = -284761466;    long sChNFCojBYWqhdRcGmuTTxcTt90237885 = -704643777;    long sChNFCojBYWqhdRcGmuTTxcTt45320619 = -856566548;    long sChNFCojBYWqhdRcGmuTTxcTt73738672 = -94066772;    long sChNFCojBYWqhdRcGmuTTxcTt41883020 = 24737938;    long sChNFCojBYWqhdRcGmuTTxcTt84574409 = -163091902;    long sChNFCojBYWqhdRcGmuTTxcTt88385861 = -792965676;    long sChNFCojBYWqhdRcGmuTTxcTt82524363 = -17236696;    long sChNFCojBYWqhdRcGmuTTxcTt98456335 = -887116701;    long sChNFCojBYWqhdRcGmuTTxcTt61370720 = -571227311;    long sChNFCojBYWqhdRcGmuTTxcTt18659442 = -11181751;    long sChNFCojBYWqhdRcGmuTTxcTt25706407 = -408175523;    long sChNFCojBYWqhdRcGmuTTxcTt92649343 = -202330079;    long sChNFCojBYWqhdRcGmuTTxcTt61610133 = -189166766;    long sChNFCojBYWqhdRcGmuTTxcTt58294727 = -137802801;    long sChNFCojBYWqhdRcGmuTTxcTt28682238 = -30916358;    long sChNFCojBYWqhdRcGmuTTxcTt49411716 = -24940740;    long sChNFCojBYWqhdRcGmuTTxcTt74806200 = -539322164;    long sChNFCojBYWqhdRcGmuTTxcTt25286737 = -888144226;    long sChNFCojBYWqhdRcGmuTTxcTt6527218 = -854206128;    long sChNFCojBYWqhdRcGmuTTxcTt9995180 = -574746717;    long sChNFCojBYWqhdRcGmuTTxcTt59270722 = -226003945;    long sChNFCojBYWqhdRcGmuTTxcTt14550519 = 94731539;    long sChNFCojBYWqhdRcGmuTTxcTt79102330 = -276312605;    long sChNFCojBYWqhdRcGmuTTxcTt35899342 = -755063048;    long sChNFCojBYWqhdRcGmuTTxcTt56905045 = 49397124;    long sChNFCojBYWqhdRcGmuTTxcTt86395088 = -430074780;    long sChNFCojBYWqhdRcGmuTTxcTt67269427 = -626925836;    long sChNFCojBYWqhdRcGmuTTxcTt31367199 = -935020995;    long sChNFCojBYWqhdRcGmuTTxcTt23031034 = -348771443;    long sChNFCojBYWqhdRcGmuTTxcTt64405031 = -409169890;    long sChNFCojBYWqhdRcGmuTTxcTt67924735 = -581232952;    long sChNFCojBYWqhdRcGmuTTxcTt18955969 = -711960034;    long sChNFCojBYWqhdRcGmuTTxcTt69191276 = -350581373;    long sChNFCojBYWqhdRcGmuTTxcTt98335257 = 90160866;    long sChNFCojBYWqhdRcGmuTTxcTt5857549 = -122795697;    long sChNFCojBYWqhdRcGmuTTxcTt99750393 = 67455433;    long sChNFCojBYWqhdRcGmuTTxcTt67719831 = -448711716;    long sChNFCojBYWqhdRcGmuTTxcTt12934171 = -822686973;    long sChNFCojBYWqhdRcGmuTTxcTt58779437 = -19085558;    long sChNFCojBYWqhdRcGmuTTxcTt34220528 = -286205623;    long sChNFCojBYWqhdRcGmuTTxcTt3720258 = -749934815;    long sChNFCojBYWqhdRcGmuTTxcTt48313146 = -712624533;    long sChNFCojBYWqhdRcGmuTTxcTt92665378 = -65465490;    long sChNFCojBYWqhdRcGmuTTxcTt85399490 = -916482010;    long sChNFCojBYWqhdRcGmuTTxcTt71772123 = -159952469;    long sChNFCojBYWqhdRcGmuTTxcTt50308633 = -328816760;    long sChNFCojBYWqhdRcGmuTTxcTt76314280 = -382147724;    long sChNFCojBYWqhdRcGmuTTxcTt34794745 = -454679045;    long sChNFCojBYWqhdRcGmuTTxcTt22089839 = -202482359;    long sChNFCojBYWqhdRcGmuTTxcTt57774439 = -730914229;    long sChNFCojBYWqhdRcGmuTTxcTt80693331 = -882483803;    long sChNFCojBYWqhdRcGmuTTxcTt55849418 = -310089484;    long sChNFCojBYWqhdRcGmuTTxcTt82568808 = -93097288;    long sChNFCojBYWqhdRcGmuTTxcTt45254258 = 56059335;    long sChNFCojBYWqhdRcGmuTTxcTt850145 = 41242479;    long sChNFCojBYWqhdRcGmuTTxcTt75687366 = -699375317;    long sChNFCojBYWqhdRcGmuTTxcTt66218288 = -480253943;    long sChNFCojBYWqhdRcGmuTTxcTt37839331 = -339003725;    long sChNFCojBYWqhdRcGmuTTxcTt84977975 = 75340813;    long sChNFCojBYWqhdRcGmuTTxcTt98179320 = -733017122;    long sChNFCojBYWqhdRcGmuTTxcTt21116434 = -66039841;    long sChNFCojBYWqhdRcGmuTTxcTt51157164 = -82215702;    long sChNFCojBYWqhdRcGmuTTxcTt75425301 = -438345259;    long sChNFCojBYWqhdRcGmuTTxcTt96965688 = -62057421;    long sChNFCojBYWqhdRcGmuTTxcTt50734707 = -429948800;    long sChNFCojBYWqhdRcGmuTTxcTt6750439 = -696215489;    long sChNFCojBYWqhdRcGmuTTxcTt23458068 = -851748707;    long sChNFCojBYWqhdRcGmuTTxcTt63274876 = -179327633;    long sChNFCojBYWqhdRcGmuTTxcTt52437178 = 84992896;    long sChNFCojBYWqhdRcGmuTTxcTt28931844 = 1628208;    long sChNFCojBYWqhdRcGmuTTxcTt81691884 = -576229024;    long sChNFCojBYWqhdRcGmuTTxcTt61872029 = -716635191;    long sChNFCojBYWqhdRcGmuTTxcTt66507299 = -769058668;    long sChNFCojBYWqhdRcGmuTTxcTt72306690 = -468000506;    long sChNFCojBYWqhdRcGmuTTxcTt6274923 = -824811903;    long sChNFCojBYWqhdRcGmuTTxcTt10957577 = -513379413;    long sChNFCojBYWqhdRcGmuTTxcTt21885141 = -839802972;    long sChNFCojBYWqhdRcGmuTTxcTt93702840 = -359830596;    long sChNFCojBYWqhdRcGmuTTxcTt64127218 = -495110580;    long sChNFCojBYWqhdRcGmuTTxcTt6596412 = -621786116;    long sChNFCojBYWqhdRcGmuTTxcTt10080808 = 52072943;    long sChNFCojBYWqhdRcGmuTTxcTt32474683 = -72246792;    long sChNFCojBYWqhdRcGmuTTxcTt9277361 = -632538636;    long sChNFCojBYWqhdRcGmuTTxcTt65256595 = -617857214;    long sChNFCojBYWqhdRcGmuTTxcTt83711700 = -867171510;     sChNFCojBYWqhdRcGmuTTxcTt86244620 = sChNFCojBYWqhdRcGmuTTxcTt46769481;     sChNFCojBYWqhdRcGmuTTxcTt46769481 = sChNFCojBYWqhdRcGmuTTxcTt54036098;     sChNFCojBYWqhdRcGmuTTxcTt54036098 = sChNFCojBYWqhdRcGmuTTxcTt4058932;     sChNFCojBYWqhdRcGmuTTxcTt4058932 = sChNFCojBYWqhdRcGmuTTxcTt97478530;     sChNFCojBYWqhdRcGmuTTxcTt97478530 = sChNFCojBYWqhdRcGmuTTxcTt42957976;     sChNFCojBYWqhdRcGmuTTxcTt42957976 = sChNFCojBYWqhdRcGmuTTxcTt37924414;     sChNFCojBYWqhdRcGmuTTxcTt37924414 = sChNFCojBYWqhdRcGmuTTxcTt93089471;     sChNFCojBYWqhdRcGmuTTxcTt93089471 = sChNFCojBYWqhdRcGmuTTxcTt50772076;     sChNFCojBYWqhdRcGmuTTxcTt50772076 = sChNFCojBYWqhdRcGmuTTxcTt7186155;     sChNFCojBYWqhdRcGmuTTxcTt7186155 = sChNFCojBYWqhdRcGmuTTxcTt55499531;     sChNFCojBYWqhdRcGmuTTxcTt55499531 = sChNFCojBYWqhdRcGmuTTxcTt81136154;     sChNFCojBYWqhdRcGmuTTxcTt81136154 = sChNFCojBYWqhdRcGmuTTxcTt89096025;     sChNFCojBYWqhdRcGmuTTxcTt89096025 = sChNFCojBYWqhdRcGmuTTxcTt55249437;     sChNFCojBYWqhdRcGmuTTxcTt55249437 = sChNFCojBYWqhdRcGmuTTxcTt60120867;     sChNFCojBYWqhdRcGmuTTxcTt60120867 = sChNFCojBYWqhdRcGmuTTxcTt90237885;     sChNFCojBYWqhdRcGmuTTxcTt90237885 = sChNFCojBYWqhdRcGmuTTxcTt45320619;     sChNFCojBYWqhdRcGmuTTxcTt45320619 = sChNFCojBYWqhdRcGmuTTxcTt73738672;     sChNFCojBYWqhdRcGmuTTxcTt73738672 = sChNFCojBYWqhdRcGmuTTxcTt41883020;     sChNFCojBYWqhdRcGmuTTxcTt41883020 = sChNFCojBYWqhdRcGmuTTxcTt84574409;     sChNFCojBYWqhdRcGmuTTxcTt84574409 = sChNFCojBYWqhdRcGmuTTxcTt88385861;     sChNFCojBYWqhdRcGmuTTxcTt88385861 = sChNFCojBYWqhdRcGmuTTxcTt82524363;     sChNFCojBYWqhdRcGmuTTxcTt82524363 = sChNFCojBYWqhdRcGmuTTxcTt98456335;     sChNFCojBYWqhdRcGmuTTxcTt98456335 = sChNFCojBYWqhdRcGmuTTxcTt61370720;     sChNFCojBYWqhdRcGmuTTxcTt61370720 = sChNFCojBYWqhdRcGmuTTxcTt18659442;     sChNFCojBYWqhdRcGmuTTxcTt18659442 = sChNFCojBYWqhdRcGmuTTxcTt25706407;     sChNFCojBYWqhdRcGmuTTxcTt25706407 = sChNFCojBYWqhdRcGmuTTxcTt92649343;     sChNFCojBYWqhdRcGmuTTxcTt92649343 = sChNFCojBYWqhdRcGmuTTxcTt61610133;     sChNFCojBYWqhdRcGmuTTxcTt61610133 = sChNFCojBYWqhdRcGmuTTxcTt58294727;     sChNFCojBYWqhdRcGmuTTxcTt58294727 = sChNFCojBYWqhdRcGmuTTxcTt28682238;     sChNFCojBYWqhdRcGmuTTxcTt28682238 = sChNFCojBYWqhdRcGmuTTxcTt49411716;     sChNFCojBYWqhdRcGmuTTxcTt49411716 = sChNFCojBYWqhdRcGmuTTxcTt74806200;     sChNFCojBYWqhdRcGmuTTxcTt74806200 = sChNFCojBYWqhdRcGmuTTxcTt25286737;     sChNFCojBYWqhdRcGmuTTxcTt25286737 = sChNFCojBYWqhdRcGmuTTxcTt6527218;     sChNFCojBYWqhdRcGmuTTxcTt6527218 = sChNFCojBYWqhdRcGmuTTxcTt9995180;     sChNFCojBYWqhdRcGmuTTxcTt9995180 = sChNFCojBYWqhdRcGmuTTxcTt59270722;     sChNFCojBYWqhdRcGmuTTxcTt59270722 = sChNFCojBYWqhdRcGmuTTxcTt14550519;     sChNFCojBYWqhdRcGmuTTxcTt14550519 = sChNFCojBYWqhdRcGmuTTxcTt79102330;     sChNFCojBYWqhdRcGmuTTxcTt79102330 = sChNFCojBYWqhdRcGmuTTxcTt35899342;     sChNFCojBYWqhdRcGmuTTxcTt35899342 = sChNFCojBYWqhdRcGmuTTxcTt56905045;     sChNFCojBYWqhdRcGmuTTxcTt56905045 = sChNFCojBYWqhdRcGmuTTxcTt86395088;     sChNFCojBYWqhdRcGmuTTxcTt86395088 = sChNFCojBYWqhdRcGmuTTxcTt67269427;     sChNFCojBYWqhdRcGmuTTxcTt67269427 = sChNFCojBYWqhdRcGmuTTxcTt31367199;     sChNFCojBYWqhdRcGmuTTxcTt31367199 = sChNFCojBYWqhdRcGmuTTxcTt23031034;     sChNFCojBYWqhdRcGmuTTxcTt23031034 = sChNFCojBYWqhdRcGmuTTxcTt64405031;     sChNFCojBYWqhdRcGmuTTxcTt64405031 = sChNFCojBYWqhdRcGmuTTxcTt67924735;     sChNFCojBYWqhdRcGmuTTxcTt67924735 = sChNFCojBYWqhdRcGmuTTxcTt18955969;     sChNFCojBYWqhdRcGmuTTxcTt18955969 = sChNFCojBYWqhdRcGmuTTxcTt69191276;     sChNFCojBYWqhdRcGmuTTxcTt69191276 = sChNFCojBYWqhdRcGmuTTxcTt98335257;     sChNFCojBYWqhdRcGmuTTxcTt98335257 = sChNFCojBYWqhdRcGmuTTxcTt5857549;     sChNFCojBYWqhdRcGmuTTxcTt5857549 = sChNFCojBYWqhdRcGmuTTxcTt99750393;     sChNFCojBYWqhdRcGmuTTxcTt99750393 = sChNFCojBYWqhdRcGmuTTxcTt67719831;     sChNFCojBYWqhdRcGmuTTxcTt67719831 = sChNFCojBYWqhdRcGmuTTxcTt12934171;     sChNFCojBYWqhdRcGmuTTxcTt12934171 = sChNFCojBYWqhdRcGmuTTxcTt58779437;     sChNFCojBYWqhdRcGmuTTxcTt58779437 = sChNFCojBYWqhdRcGmuTTxcTt34220528;     sChNFCojBYWqhdRcGmuTTxcTt34220528 = sChNFCojBYWqhdRcGmuTTxcTt3720258;     sChNFCojBYWqhdRcGmuTTxcTt3720258 = sChNFCojBYWqhdRcGmuTTxcTt48313146;     sChNFCojBYWqhdRcGmuTTxcTt48313146 = sChNFCojBYWqhdRcGmuTTxcTt92665378;     sChNFCojBYWqhdRcGmuTTxcTt92665378 = sChNFCojBYWqhdRcGmuTTxcTt85399490;     sChNFCojBYWqhdRcGmuTTxcTt85399490 = sChNFCojBYWqhdRcGmuTTxcTt71772123;     sChNFCojBYWqhdRcGmuTTxcTt71772123 = sChNFCojBYWqhdRcGmuTTxcTt50308633;     sChNFCojBYWqhdRcGmuTTxcTt50308633 = sChNFCojBYWqhdRcGmuTTxcTt76314280;     sChNFCojBYWqhdRcGmuTTxcTt76314280 = sChNFCojBYWqhdRcGmuTTxcTt34794745;     sChNFCojBYWqhdRcGmuTTxcTt34794745 = sChNFCojBYWqhdRcGmuTTxcTt22089839;     sChNFCojBYWqhdRcGmuTTxcTt22089839 = sChNFCojBYWqhdRcGmuTTxcTt57774439;     sChNFCojBYWqhdRcGmuTTxcTt57774439 = sChNFCojBYWqhdRcGmuTTxcTt80693331;     sChNFCojBYWqhdRcGmuTTxcTt80693331 = sChNFCojBYWqhdRcGmuTTxcTt55849418;     sChNFCojBYWqhdRcGmuTTxcTt55849418 = sChNFCojBYWqhdRcGmuTTxcTt82568808;     sChNFCojBYWqhdRcGmuTTxcTt82568808 = sChNFCojBYWqhdRcGmuTTxcTt45254258;     sChNFCojBYWqhdRcGmuTTxcTt45254258 = sChNFCojBYWqhdRcGmuTTxcTt850145;     sChNFCojBYWqhdRcGmuTTxcTt850145 = sChNFCojBYWqhdRcGmuTTxcTt75687366;     sChNFCojBYWqhdRcGmuTTxcTt75687366 = sChNFCojBYWqhdRcGmuTTxcTt66218288;     sChNFCojBYWqhdRcGmuTTxcTt66218288 = sChNFCojBYWqhdRcGmuTTxcTt37839331;     sChNFCojBYWqhdRcGmuTTxcTt37839331 = sChNFCojBYWqhdRcGmuTTxcTt84977975;     sChNFCojBYWqhdRcGmuTTxcTt84977975 = sChNFCojBYWqhdRcGmuTTxcTt98179320;     sChNFCojBYWqhdRcGmuTTxcTt98179320 = sChNFCojBYWqhdRcGmuTTxcTt21116434;     sChNFCojBYWqhdRcGmuTTxcTt21116434 = sChNFCojBYWqhdRcGmuTTxcTt51157164;     sChNFCojBYWqhdRcGmuTTxcTt51157164 = sChNFCojBYWqhdRcGmuTTxcTt75425301;     sChNFCojBYWqhdRcGmuTTxcTt75425301 = sChNFCojBYWqhdRcGmuTTxcTt96965688;     sChNFCojBYWqhdRcGmuTTxcTt96965688 = sChNFCojBYWqhdRcGmuTTxcTt50734707;     sChNFCojBYWqhdRcGmuTTxcTt50734707 = sChNFCojBYWqhdRcGmuTTxcTt6750439;     sChNFCojBYWqhdRcGmuTTxcTt6750439 = sChNFCojBYWqhdRcGmuTTxcTt23458068;     sChNFCojBYWqhdRcGmuTTxcTt23458068 = sChNFCojBYWqhdRcGmuTTxcTt63274876;     sChNFCojBYWqhdRcGmuTTxcTt63274876 = sChNFCojBYWqhdRcGmuTTxcTt52437178;     sChNFCojBYWqhdRcGmuTTxcTt52437178 = sChNFCojBYWqhdRcGmuTTxcTt28931844;     sChNFCojBYWqhdRcGmuTTxcTt28931844 = sChNFCojBYWqhdRcGmuTTxcTt81691884;     sChNFCojBYWqhdRcGmuTTxcTt81691884 = sChNFCojBYWqhdRcGmuTTxcTt61872029;     sChNFCojBYWqhdRcGmuTTxcTt61872029 = sChNFCojBYWqhdRcGmuTTxcTt66507299;     sChNFCojBYWqhdRcGmuTTxcTt66507299 = sChNFCojBYWqhdRcGmuTTxcTt72306690;     sChNFCojBYWqhdRcGmuTTxcTt72306690 = sChNFCojBYWqhdRcGmuTTxcTt6274923;     sChNFCojBYWqhdRcGmuTTxcTt6274923 = sChNFCojBYWqhdRcGmuTTxcTt10957577;     sChNFCojBYWqhdRcGmuTTxcTt10957577 = sChNFCojBYWqhdRcGmuTTxcTt21885141;     sChNFCojBYWqhdRcGmuTTxcTt21885141 = sChNFCojBYWqhdRcGmuTTxcTt93702840;     sChNFCojBYWqhdRcGmuTTxcTt93702840 = sChNFCojBYWqhdRcGmuTTxcTt64127218;     sChNFCojBYWqhdRcGmuTTxcTt64127218 = sChNFCojBYWqhdRcGmuTTxcTt6596412;     sChNFCojBYWqhdRcGmuTTxcTt6596412 = sChNFCojBYWqhdRcGmuTTxcTt10080808;     sChNFCojBYWqhdRcGmuTTxcTt10080808 = sChNFCojBYWqhdRcGmuTTxcTt32474683;     sChNFCojBYWqhdRcGmuTTxcTt32474683 = sChNFCojBYWqhdRcGmuTTxcTt9277361;     sChNFCojBYWqhdRcGmuTTxcTt9277361 = sChNFCojBYWqhdRcGmuTTxcTt65256595;     sChNFCojBYWqhdRcGmuTTxcTt65256595 = sChNFCojBYWqhdRcGmuTTxcTt83711700;     sChNFCojBYWqhdRcGmuTTxcTt83711700 = sChNFCojBYWqhdRcGmuTTxcTt86244620;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void VGVWVBwNrVgmnAFzfOYRjdgbingavkhuQTHcgJSgatOrnEIdbQozmgBsa37655457() {     long uoiVWSHomVTscSVvrqpOoodeC92361727 = -979073399;    long uoiVWSHomVTscSVvrqpOoodeC90142760 = -309341014;    long uoiVWSHomVTscSVvrqpOoodeC70078282 = -887525721;    long uoiVWSHomVTscSVvrqpOoodeC31133713 = -118412391;    long uoiVWSHomVTscSVvrqpOoodeC66374019 = -88777862;    long uoiVWSHomVTscSVvrqpOoodeC34375179 = -895643074;    long uoiVWSHomVTscSVvrqpOoodeC98413379 = -810279467;    long uoiVWSHomVTscSVvrqpOoodeC42849363 = -979355758;    long uoiVWSHomVTscSVvrqpOoodeC15414572 = -101431383;    long uoiVWSHomVTscSVvrqpOoodeC48415814 = -84830446;    long uoiVWSHomVTscSVvrqpOoodeC15609822 = -299243554;    long uoiVWSHomVTscSVvrqpOoodeC12959197 = -642639911;    long uoiVWSHomVTscSVvrqpOoodeC75305144 = -387194504;    long uoiVWSHomVTscSVvrqpOoodeC38393114 = -50925950;    long uoiVWSHomVTscSVvrqpOoodeC55863294 = -975223632;    long uoiVWSHomVTscSVvrqpOoodeC31743279 = -677643320;    long uoiVWSHomVTscSVvrqpOoodeC39156622 = -373111660;    long uoiVWSHomVTscSVvrqpOoodeC70791825 = -859589415;    long uoiVWSHomVTscSVvrqpOoodeC3712862 = -381031159;    long uoiVWSHomVTscSVvrqpOoodeC65124574 = -519994821;    long uoiVWSHomVTscSVvrqpOoodeC76939054 = -648453132;    long uoiVWSHomVTscSVvrqpOoodeC69045386 = 74833588;    long uoiVWSHomVTscSVvrqpOoodeC34047127 = -633634188;    long uoiVWSHomVTscSVvrqpOoodeC45363094 = -793532299;    long uoiVWSHomVTscSVvrqpOoodeC62359092 = -384377784;    long uoiVWSHomVTscSVvrqpOoodeC50428082 = -286830846;    long uoiVWSHomVTscSVvrqpOoodeC91109121 = -102992282;    long uoiVWSHomVTscSVvrqpOoodeC74717258 = -255095720;    long uoiVWSHomVTscSVvrqpOoodeC24426983 = -360185505;    long uoiVWSHomVTscSVvrqpOoodeC97297874 = -948387226;    long uoiVWSHomVTscSVvrqpOoodeC41654265 = 61738322;    long uoiVWSHomVTscSVvrqpOoodeC72416822 = -248768980;    long uoiVWSHomVTscSVvrqpOoodeC34997685 = -780757596;    long uoiVWSHomVTscSVvrqpOoodeC1357782 = -605747894;    long uoiVWSHomVTscSVvrqpOoodeC71469832 = -113479823;    long uoiVWSHomVTscSVvrqpOoodeC27996636 = -440030053;    long uoiVWSHomVTscSVvrqpOoodeC95812453 = -958904330;    long uoiVWSHomVTscSVvrqpOoodeC13192544 = -47818615;    long uoiVWSHomVTscSVvrqpOoodeC9509596 = -748986545;    long uoiVWSHomVTscSVvrqpOoodeC44406982 = -424042098;    long uoiVWSHomVTscSVvrqpOoodeC92064312 = -495348675;    long uoiVWSHomVTscSVvrqpOoodeC99419884 = -897068114;    long uoiVWSHomVTscSVvrqpOoodeC9434178 = 84174422;    long uoiVWSHomVTscSVvrqpOoodeC10438775 = -368114381;    long uoiVWSHomVTscSVvrqpOoodeC76357496 = -71068045;    long uoiVWSHomVTscSVvrqpOoodeC79863930 = -566449069;    long uoiVWSHomVTscSVvrqpOoodeC36734543 = -830735572;    long uoiVWSHomVTscSVvrqpOoodeC77148216 = -360476905;    long uoiVWSHomVTscSVvrqpOoodeC8010986 = 4423878;    long uoiVWSHomVTscSVvrqpOoodeC18769202 = -209806505;    long uoiVWSHomVTscSVvrqpOoodeC35451072 = -874838238;    long uoiVWSHomVTscSVvrqpOoodeC78529551 = -249438036;    long uoiVWSHomVTscSVvrqpOoodeC61182628 = -614476561;    long uoiVWSHomVTscSVvrqpOoodeC54748318 = -339555703;    long uoiVWSHomVTscSVvrqpOoodeC60716402 = -986737405;    long uoiVWSHomVTscSVvrqpOoodeC23316341 = -953906987;    long uoiVWSHomVTscSVvrqpOoodeC56095634 = -675706827;    long uoiVWSHomVTscSVvrqpOoodeC24715188 = 6006577;    long uoiVWSHomVTscSVvrqpOoodeC68774621 = -734034608;    long uoiVWSHomVTscSVvrqpOoodeC15945937 = -801947017;    long uoiVWSHomVTscSVvrqpOoodeC43266057 = -692650792;    long uoiVWSHomVTscSVvrqpOoodeC23696122 = -455183748;    long uoiVWSHomVTscSVvrqpOoodeC18422380 = -519170254;    long uoiVWSHomVTscSVvrqpOoodeC18116698 = -153044158;    long uoiVWSHomVTscSVvrqpOoodeC6761549 = -46568769;    long uoiVWSHomVTscSVvrqpOoodeC43193000 = 49525426;    long uoiVWSHomVTscSVvrqpOoodeC77961511 = -861882316;    long uoiVWSHomVTscSVvrqpOoodeC73947362 = -781446611;    long uoiVWSHomVTscSVvrqpOoodeC66923282 = -937446128;    long uoiVWSHomVTscSVvrqpOoodeC27866658 = -435193580;    long uoiVWSHomVTscSVvrqpOoodeC35930826 = -718738990;    long uoiVWSHomVTscSVvrqpOoodeC25964079 = -225293046;    long uoiVWSHomVTscSVvrqpOoodeC61282230 = -10602871;    long uoiVWSHomVTscSVvrqpOoodeC59305879 = -956989061;    long uoiVWSHomVTscSVvrqpOoodeC73060261 = 75353853;    long uoiVWSHomVTscSVvrqpOoodeC77519170 = -751385018;    long uoiVWSHomVTscSVvrqpOoodeC59611209 = 90659166;    long uoiVWSHomVTscSVvrqpOoodeC23608353 = -165519807;    long uoiVWSHomVTscSVvrqpOoodeC69005597 = -622464254;    long uoiVWSHomVTscSVvrqpOoodeC82495161 = -817928716;    long uoiVWSHomVTscSVvrqpOoodeC13693540 = -456095274;    long uoiVWSHomVTscSVvrqpOoodeC13960905 = -742515378;    long uoiVWSHomVTscSVvrqpOoodeC66706272 = -159519599;    long uoiVWSHomVTscSVvrqpOoodeC5657782 = -50379001;    long uoiVWSHomVTscSVvrqpOoodeC61846802 = 26451011;    long uoiVWSHomVTscSVvrqpOoodeC63124714 = -688823642;    long uoiVWSHomVTscSVvrqpOoodeC11234194 = -634292419;    long uoiVWSHomVTscSVvrqpOoodeC80249367 = -341201893;    long uoiVWSHomVTscSVvrqpOoodeC40641380 = -619010489;    long uoiVWSHomVTscSVvrqpOoodeC48153491 = -159572836;    long uoiVWSHomVTscSVvrqpOoodeC71901002 = -764323226;    long uoiVWSHomVTscSVvrqpOoodeC71097266 = -864910908;    long uoiVWSHomVTscSVvrqpOoodeC44417922 = -313784008;    long uoiVWSHomVTscSVvrqpOoodeC93563658 = -947039528;    long uoiVWSHomVTscSVvrqpOoodeC1140926 = -731391307;    long uoiVWSHomVTscSVvrqpOoodeC68368191 = 59835073;    long uoiVWSHomVTscSVvrqpOoodeC80997504 = -277897861;    long uoiVWSHomVTscSVvrqpOoodeC91317480 = -762781421;    long uoiVWSHomVTscSVvrqpOoodeC3677226 = -221545613;    long uoiVWSHomVTscSVvrqpOoodeC33164497 = -979073399;     uoiVWSHomVTscSVvrqpOoodeC92361727 = uoiVWSHomVTscSVvrqpOoodeC90142760;     uoiVWSHomVTscSVvrqpOoodeC90142760 = uoiVWSHomVTscSVvrqpOoodeC70078282;     uoiVWSHomVTscSVvrqpOoodeC70078282 = uoiVWSHomVTscSVvrqpOoodeC31133713;     uoiVWSHomVTscSVvrqpOoodeC31133713 = uoiVWSHomVTscSVvrqpOoodeC66374019;     uoiVWSHomVTscSVvrqpOoodeC66374019 = uoiVWSHomVTscSVvrqpOoodeC34375179;     uoiVWSHomVTscSVvrqpOoodeC34375179 = uoiVWSHomVTscSVvrqpOoodeC98413379;     uoiVWSHomVTscSVvrqpOoodeC98413379 = uoiVWSHomVTscSVvrqpOoodeC42849363;     uoiVWSHomVTscSVvrqpOoodeC42849363 = uoiVWSHomVTscSVvrqpOoodeC15414572;     uoiVWSHomVTscSVvrqpOoodeC15414572 = uoiVWSHomVTscSVvrqpOoodeC48415814;     uoiVWSHomVTscSVvrqpOoodeC48415814 = uoiVWSHomVTscSVvrqpOoodeC15609822;     uoiVWSHomVTscSVvrqpOoodeC15609822 = uoiVWSHomVTscSVvrqpOoodeC12959197;     uoiVWSHomVTscSVvrqpOoodeC12959197 = uoiVWSHomVTscSVvrqpOoodeC75305144;     uoiVWSHomVTscSVvrqpOoodeC75305144 = uoiVWSHomVTscSVvrqpOoodeC38393114;     uoiVWSHomVTscSVvrqpOoodeC38393114 = uoiVWSHomVTscSVvrqpOoodeC55863294;     uoiVWSHomVTscSVvrqpOoodeC55863294 = uoiVWSHomVTscSVvrqpOoodeC31743279;     uoiVWSHomVTscSVvrqpOoodeC31743279 = uoiVWSHomVTscSVvrqpOoodeC39156622;     uoiVWSHomVTscSVvrqpOoodeC39156622 = uoiVWSHomVTscSVvrqpOoodeC70791825;     uoiVWSHomVTscSVvrqpOoodeC70791825 = uoiVWSHomVTscSVvrqpOoodeC3712862;     uoiVWSHomVTscSVvrqpOoodeC3712862 = uoiVWSHomVTscSVvrqpOoodeC65124574;     uoiVWSHomVTscSVvrqpOoodeC65124574 = uoiVWSHomVTscSVvrqpOoodeC76939054;     uoiVWSHomVTscSVvrqpOoodeC76939054 = uoiVWSHomVTscSVvrqpOoodeC69045386;     uoiVWSHomVTscSVvrqpOoodeC69045386 = uoiVWSHomVTscSVvrqpOoodeC34047127;     uoiVWSHomVTscSVvrqpOoodeC34047127 = uoiVWSHomVTscSVvrqpOoodeC45363094;     uoiVWSHomVTscSVvrqpOoodeC45363094 = uoiVWSHomVTscSVvrqpOoodeC62359092;     uoiVWSHomVTscSVvrqpOoodeC62359092 = uoiVWSHomVTscSVvrqpOoodeC50428082;     uoiVWSHomVTscSVvrqpOoodeC50428082 = uoiVWSHomVTscSVvrqpOoodeC91109121;     uoiVWSHomVTscSVvrqpOoodeC91109121 = uoiVWSHomVTscSVvrqpOoodeC74717258;     uoiVWSHomVTscSVvrqpOoodeC74717258 = uoiVWSHomVTscSVvrqpOoodeC24426983;     uoiVWSHomVTscSVvrqpOoodeC24426983 = uoiVWSHomVTscSVvrqpOoodeC97297874;     uoiVWSHomVTscSVvrqpOoodeC97297874 = uoiVWSHomVTscSVvrqpOoodeC41654265;     uoiVWSHomVTscSVvrqpOoodeC41654265 = uoiVWSHomVTscSVvrqpOoodeC72416822;     uoiVWSHomVTscSVvrqpOoodeC72416822 = uoiVWSHomVTscSVvrqpOoodeC34997685;     uoiVWSHomVTscSVvrqpOoodeC34997685 = uoiVWSHomVTscSVvrqpOoodeC1357782;     uoiVWSHomVTscSVvrqpOoodeC1357782 = uoiVWSHomVTscSVvrqpOoodeC71469832;     uoiVWSHomVTscSVvrqpOoodeC71469832 = uoiVWSHomVTscSVvrqpOoodeC27996636;     uoiVWSHomVTscSVvrqpOoodeC27996636 = uoiVWSHomVTscSVvrqpOoodeC95812453;     uoiVWSHomVTscSVvrqpOoodeC95812453 = uoiVWSHomVTscSVvrqpOoodeC13192544;     uoiVWSHomVTscSVvrqpOoodeC13192544 = uoiVWSHomVTscSVvrqpOoodeC9509596;     uoiVWSHomVTscSVvrqpOoodeC9509596 = uoiVWSHomVTscSVvrqpOoodeC44406982;     uoiVWSHomVTscSVvrqpOoodeC44406982 = uoiVWSHomVTscSVvrqpOoodeC92064312;     uoiVWSHomVTscSVvrqpOoodeC92064312 = uoiVWSHomVTscSVvrqpOoodeC99419884;     uoiVWSHomVTscSVvrqpOoodeC99419884 = uoiVWSHomVTscSVvrqpOoodeC9434178;     uoiVWSHomVTscSVvrqpOoodeC9434178 = uoiVWSHomVTscSVvrqpOoodeC10438775;     uoiVWSHomVTscSVvrqpOoodeC10438775 = uoiVWSHomVTscSVvrqpOoodeC76357496;     uoiVWSHomVTscSVvrqpOoodeC76357496 = uoiVWSHomVTscSVvrqpOoodeC79863930;     uoiVWSHomVTscSVvrqpOoodeC79863930 = uoiVWSHomVTscSVvrqpOoodeC36734543;     uoiVWSHomVTscSVvrqpOoodeC36734543 = uoiVWSHomVTscSVvrqpOoodeC77148216;     uoiVWSHomVTscSVvrqpOoodeC77148216 = uoiVWSHomVTscSVvrqpOoodeC8010986;     uoiVWSHomVTscSVvrqpOoodeC8010986 = uoiVWSHomVTscSVvrqpOoodeC18769202;     uoiVWSHomVTscSVvrqpOoodeC18769202 = uoiVWSHomVTscSVvrqpOoodeC35451072;     uoiVWSHomVTscSVvrqpOoodeC35451072 = uoiVWSHomVTscSVvrqpOoodeC78529551;     uoiVWSHomVTscSVvrqpOoodeC78529551 = uoiVWSHomVTscSVvrqpOoodeC61182628;     uoiVWSHomVTscSVvrqpOoodeC61182628 = uoiVWSHomVTscSVvrqpOoodeC54748318;     uoiVWSHomVTscSVvrqpOoodeC54748318 = uoiVWSHomVTscSVvrqpOoodeC60716402;     uoiVWSHomVTscSVvrqpOoodeC60716402 = uoiVWSHomVTscSVvrqpOoodeC23316341;     uoiVWSHomVTscSVvrqpOoodeC23316341 = uoiVWSHomVTscSVvrqpOoodeC56095634;     uoiVWSHomVTscSVvrqpOoodeC56095634 = uoiVWSHomVTscSVvrqpOoodeC24715188;     uoiVWSHomVTscSVvrqpOoodeC24715188 = uoiVWSHomVTscSVvrqpOoodeC68774621;     uoiVWSHomVTscSVvrqpOoodeC68774621 = uoiVWSHomVTscSVvrqpOoodeC15945937;     uoiVWSHomVTscSVvrqpOoodeC15945937 = uoiVWSHomVTscSVvrqpOoodeC43266057;     uoiVWSHomVTscSVvrqpOoodeC43266057 = uoiVWSHomVTscSVvrqpOoodeC23696122;     uoiVWSHomVTscSVvrqpOoodeC23696122 = uoiVWSHomVTscSVvrqpOoodeC18422380;     uoiVWSHomVTscSVvrqpOoodeC18422380 = uoiVWSHomVTscSVvrqpOoodeC18116698;     uoiVWSHomVTscSVvrqpOoodeC18116698 = uoiVWSHomVTscSVvrqpOoodeC6761549;     uoiVWSHomVTscSVvrqpOoodeC6761549 = uoiVWSHomVTscSVvrqpOoodeC43193000;     uoiVWSHomVTscSVvrqpOoodeC43193000 = uoiVWSHomVTscSVvrqpOoodeC77961511;     uoiVWSHomVTscSVvrqpOoodeC77961511 = uoiVWSHomVTscSVvrqpOoodeC73947362;     uoiVWSHomVTscSVvrqpOoodeC73947362 = uoiVWSHomVTscSVvrqpOoodeC66923282;     uoiVWSHomVTscSVvrqpOoodeC66923282 = uoiVWSHomVTscSVvrqpOoodeC27866658;     uoiVWSHomVTscSVvrqpOoodeC27866658 = uoiVWSHomVTscSVvrqpOoodeC35930826;     uoiVWSHomVTscSVvrqpOoodeC35930826 = uoiVWSHomVTscSVvrqpOoodeC25964079;     uoiVWSHomVTscSVvrqpOoodeC25964079 = uoiVWSHomVTscSVvrqpOoodeC61282230;     uoiVWSHomVTscSVvrqpOoodeC61282230 = uoiVWSHomVTscSVvrqpOoodeC59305879;     uoiVWSHomVTscSVvrqpOoodeC59305879 = uoiVWSHomVTscSVvrqpOoodeC73060261;     uoiVWSHomVTscSVvrqpOoodeC73060261 = uoiVWSHomVTscSVvrqpOoodeC77519170;     uoiVWSHomVTscSVvrqpOoodeC77519170 = uoiVWSHomVTscSVvrqpOoodeC59611209;     uoiVWSHomVTscSVvrqpOoodeC59611209 = uoiVWSHomVTscSVvrqpOoodeC23608353;     uoiVWSHomVTscSVvrqpOoodeC23608353 = uoiVWSHomVTscSVvrqpOoodeC69005597;     uoiVWSHomVTscSVvrqpOoodeC69005597 = uoiVWSHomVTscSVvrqpOoodeC82495161;     uoiVWSHomVTscSVvrqpOoodeC82495161 = uoiVWSHomVTscSVvrqpOoodeC13693540;     uoiVWSHomVTscSVvrqpOoodeC13693540 = uoiVWSHomVTscSVvrqpOoodeC13960905;     uoiVWSHomVTscSVvrqpOoodeC13960905 = uoiVWSHomVTscSVvrqpOoodeC66706272;     uoiVWSHomVTscSVvrqpOoodeC66706272 = uoiVWSHomVTscSVvrqpOoodeC5657782;     uoiVWSHomVTscSVvrqpOoodeC5657782 = uoiVWSHomVTscSVvrqpOoodeC61846802;     uoiVWSHomVTscSVvrqpOoodeC61846802 = uoiVWSHomVTscSVvrqpOoodeC63124714;     uoiVWSHomVTscSVvrqpOoodeC63124714 = uoiVWSHomVTscSVvrqpOoodeC11234194;     uoiVWSHomVTscSVvrqpOoodeC11234194 = uoiVWSHomVTscSVvrqpOoodeC80249367;     uoiVWSHomVTscSVvrqpOoodeC80249367 = uoiVWSHomVTscSVvrqpOoodeC40641380;     uoiVWSHomVTscSVvrqpOoodeC40641380 = uoiVWSHomVTscSVvrqpOoodeC48153491;     uoiVWSHomVTscSVvrqpOoodeC48153491 = uoiVWSHomVTscSVvrqpOoodeC71901002;     uoiVWSHomVTscSVvrqpOoodeC71901002 = uoiVWSHomVTscSVvrqpOoodeC71097266;     uoiVWSHomVTscSVvrqpOoodeC71097266 = uoiVWSHomVTscSVvrqpOoodeC44417922;     uoiVWSHomVTscSVvrqpOoodeC44417922 = uoiVWSHomVTscSVvrqpOoodeC93563658;     uoiVWSHomVTscSVvrqpOoodeC93563658 = uoiVWSHomVTscSVvrqpOoodeC1140926;     uoiVWSHomVTscSVvrqpOoodeC1140926 = uoiVWSHomVTscSVvrqpOoodeC68368191;     uoiVWSHomVTscSVvrqpOoodeC68368191 = uoiVWSHomVTscSVvrqpOoodeC80997504;     uoiVWSHomVTscSVvrqpOoodeC80997504 = uoiVWSHomVTscSVvrqpOoodeC91317480;     uoiVWSHomVTscSVvrqpOoodeC91317480 = uoiVWSHomVTscSVvrqpOoodeC3677226;     uoiVWSHomVTscSVvrqpOoodeC3677226 = uoiVWSHomVTscSVvrqpOoodeC33164497;     uoiVWSHomVTscSVvrqpOoodeC33164497 = uoiVWSHomVTscSVvrqpOoodeC92361727;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void kJgZJcTmUlCSsHRBiMyZxMWAodfEAHonhXouKJgGxREPKwCYsmwcUtpXn79864507() {     long gkgwOmNxPkVTXrYgscfIHpsbH16485913 = -486601160;    long gkgwOmNxPkVTXrYgscfIHpsbH55521165 = -324135043;    long gkgwOmNxPkVTXrYgscfIHpsbH72319617 = -110256796;    long gkgwOmNxPkVTXrYgscfIHpsbH24945838 = -810953858;    long gkgwOmNxPkVTXrYgscfIHpsbH39062180 = -820396687;    long gkgwOmNxPkVTXrYgscfIHpsbH65440292 = -990420475;    long gkgwOmNxPkVTXrYgscfIHpsbH22209128 = -804344253;    long gkgwOmNxPkVTXrYgscfIHpsbH69971187 = 2312372;    long gkgwOmNxPkVTXrYgscfIHpsbH93190738 = -673064615;    long gkgwOmNxPkVTXrYgscfIHpsbH9816645 = -735016044;    long gkgwOmNxPkVTXrYgscfIHpsbH43364229 = -817722408;    long gkgwOmNxPkVTXrYgscfIHpsbH75645604 = -344497114;    long gkgwOmNxPkVTXrYgscfIHpsbH71530890 = -884677467;    long gkgwOmNxPkVTXrYgscfIHpsbH51314530 = -669026991;    long gkgwOmNxPkVTXrYgscfIHpsbH85320801 = -89750842;    long gkgwOmNxPkVTXrYgscfIHpsbH94085327 = -412795906;    long gkgwOmNxPkVTXrYgscfIHpsbH30987309 = -513582528;    long gkgwOmNxPkVTXrYgscfIHpsbH81701030 = -849640695;    long gkgwOmNxPkVTXrYgscfIHpsbH24461274 = -339551900;    long gkgwOmNxPkVTXrYgscfIHpsbH95351990 = -879891311;    long gkgwOmNxPkVTXrYgscfIHpsbH3652159 = -245132015;    long gkgwOmNxPkVTXrYgscfIHpsbH90705992 = -750915762;    long gkgwOmNxPkVTXrYgscfIHpsbH29470366 = -578212767;    long gkgwOmNxPkVTXrYgscfIHpsbH3600605 = -708886976;    long gkgwOmNxPkVTXrYgscfIHpsbH87204524 = -669917882;    long gkgwOmNxPkVTXrYgscfIHpsbH67292972 = -549283367;    long gkgwOmNxPkVTXrYgscfIHpsbH84471781 = -247787565;    long gkgwOmNxPkVTXrYgscfIHpsbH69907052 = -824639113;    long gkgwOmNxPkVTXrYgscfIHpsbH52900005 = -867823948;    long gkgwOmNxPkVTXrYgscfIHpsbH82417670 = -311726045;    long gkgwOmNxPkVTXrYgscfIHpsbH14810710 = -805686988;    long gkgwOmNxPkVTXrYgscfIHpsbH46806779 = -576659086;    long gkgwOmNxPkVTXrYgscfIHpsbH42766559 = 83003077;    long gkgwOmNxPkVTXrYgscfIHpsbH54699472 = -896301476;    long gkgwOmNxPkVTXrYgscfIHpsbH75314815 = -329217407;    long gkgwOmNxPkVTXrYgscfIHpsbH40682068 = -696652821;    long gkgwOmNxPkVTXrYgscfIHpsbH60915050 = -486293681;    long gkgwOmNxPkVTXrYgscfIHpsbH172837 = -140782;    long gkgwOmNxPkVTXrYgscfIHpsbH68764170 = -42179618;    long gkgwOmNxPkVTXrYgscfIHpsbH96706890 = -451523873;    long gkgwOmNxPkVTXrYgscfIHpsbH92541853 = -270699154;    long gkgwOmNxPkVTXrYgscfIHpsbH51529261 = -595048406;    long gkgwOmNxPkVTXrYgscfIHpsbH81496761 = -114350130;    long gkgwOmNxPkVTXrYgscfIHpsbH63010737 = -401625596;    long gkgwOmNxPkVTXrYgscfIHpsbH45365458 = -637393755;    long gkgwOmNxPkVTXrYgscfIHpsbH79551666 = -394558937;    long gkgwOmNxPkVTXrYgscfIHpsbH78273686 = -101166123;    long gkgwOmNxPkVTXrYgscfIHpsbH56885461 = -644226253;    long gkgwOmNxPkVTXrYgscfIHpsbH61824746 = -843304584;    long gkgwOmNxPkVTXrYgscfIHpsbH49497851 = -314081923;    long gkgwOmNxPkVTXrYgscfIHpsbH31685338 = 56220081;    long gkgwOmNxPkVTXrYgscfIHpsbH30723747 = -771320441;    long gkgwOmNxPkVTXrYgscfIHpsbH18873691 = -882487477;    long gkgwOmNxPkVTXrYgscfIHpsbH32531536 = -372055861;    long gkgwOmNxPkVTXrYgscfIHpsbH76212348 = -117979902;    long gkgwOmNxPkVTXrYgscfIHpsbH25779921 = -735685398;    long gkgwOmNxPkVTXrYgscfIHpsbH26050800 = -745922277;    long gkgwOmNxPkVTXrYgscfIHpsbH68719013 = -401369820;    long gkgwOmNxPkVTXrYgscfIHpsbH37741313 = -41035976;    long gkgwOmNxPkVTXrYgscfIHpsbH71769208 = -171113321;    long gkgwOmNxPkVTXrYgscfIHpsbH80968510 = -642632911;    long gkgwOmNxPkVTXrYgscfIHpsbH52302076 = -979705141;    long gkgwOmNxPkVTXrYgscfIHpsbH17071182 = -129863680;    long gkgwOmNxPkVTXrYgscfIHpsbH10773069 = -261338571;    long gkgwOmNxPkVTXrYgscfIHpsbH95005934 = -929329056;    long gkgwOmNxPkVTXrYgscfIHpsbH96557450 = -141063322;    long gkgwOmNxPkVTXrYgscfIHpsbH32879045 = -327500192;    long gkgwOmNxPkVTXrYgscfIHpsbH16831418 = -988375991;    long gkgwOmNxPkVTXrYgscfIHpsbH75999714 = -239809584;    long gkgwOmNxPkVTXrYgscfIHpsbH44638734 = -393098021;    long gkgwOmNxPkVTXrYgscfIHpsbH33170277 = -926502225;    long gkgwOmNxPkVTXrYgscfIHpsbH30814472 = -413441747;    long gkgwOmNxPkVTXrYgscfIHpsbH12936861 = -707461078;    long gkgwOmNxPkVTXrYgscfIHpsbH27754384 = -888028028;    long gkgwOmNxPkVTXrYgscfIHpsbH2810138 = -509192157;    long gkgwOmNxPkVTXrYgscfIHpsbH52122898 = -650083609;    long gkgwOmNxPkVTXrYgscfIHpsbH9209231 = -536565632;    long gkgwOmNxPkVTXrYgscfIHpsbH66459628 = -76587171;    long gkgwOmNxPkVTXrYgscfIHpsbH58235146 = 28506778;    long gkgwOmNxPkVTXrYgscfIHpsbH7652858 = -175358946;    long gkgwOmNxPkVTXrYgscfIHpsbH89019285 = -348117244;    long gkgwOmNxPkVTXrYgscfIHpsbH27586321 = -603561313;    long gkgwOmNxPkVTXrYgscfIHpsbH8082306 = -981334529;    long gkgwOmNxPkVTXrYgscfIHpsbH3402155 = -453742025;    long gkgwOmNxPkVTXrYgscfIHpsbH50732332 = -267946127;    long gkgwOmNxPkVTXrYgscfIHpsbH84086963 = 65633453;    long gkgwOmNxPkVTXrYgscfIHpsbH27933088 = -694171609;    long gkgwOmNxPkVTXrYgscfIHpsbH10235024 = -544941062;    long gkgwOmNxPkVTXrYgscfIHpsbH78487123 = -678321575;    long gkgwOmNxPkVTXrYgscfIHpsbH49534894 = -593532010;    long gkgwOmNxPkVTXrYgscfIHpsbH14631269 = -950730545;    long gkgwOmNxPkVTXrYgscfIHpsbH92196037 = 15076139;    long gkgwOmNxPkVTXrYgscfIHpsbH62431523 = -959104806;    long gkgwOmNxPkVTXrYgscfIHpsbH96994961 = -871066297;    long gkgwOmNxPkVTXrYgscfIHpsbH15738380 = -808890962;    long gkgwOmNxPkVTXrYgscfIHpsbH40239778 = -290994013;    long gkgwOmNxPkVTXrYgscfIHpsbH34458079 = -365184726;    long gkgwOmNxPkVTXrYgscfIHpsbH70723693 = -853011560;    long gkgwOmNxPkVTXrYgscfIHpsbH68004802 = -472296541;    long gkgwOmNxPkVTXrYgscfIHpsbH48808008 = -486601160;     gkgwOmNxPkVTXrYgscfIHpsbH16485913 = gkgwOmNxPkVTXrYgscfIHpsbH55521165;     gkgwOmNxPkVTXrYgscfIHpsbH55521165 = gkgwOmNxPkVTXrYgscfIHpsbH72319617;     gkgwOmNxPkVTXrYgscfIHpsbH72319617 = gkgwOmNxPkVTXrYgscfIHpsbH24945838;     gkgwOmNxPkVTXrYgscfIHpsbH24945838 = gkgwOmNxPkVTXrYgscfIHpsbH39062180;     gkgwOmNxPkVTXrYgscfIHpsbH39062180 = gkgwOmNxPkVTXrYgscfIHpsbH65440292;     gkgwOmNxPkVTXrYgscfIHpsbH65440292 = gkgwOmNxPkVTXrYgscfIHpsbH22209128;     gkgwOmNxPkVTXrYgscfIHpsbH22209128 = gkgwOmNxPkVTXrYgscfIHpsbH69971187;     gkgwOmNxPkVTXrYgscfIHpsbH69971187 = gkgwOmNxPkVTXrYgscfIHpsbH93190738;     gkgwOmNxPkVTXrYgscfIHpsbH93190738 = gkgwOmNxPkVTXrYgscfIHpsbH9816645;     gkgwOmNxPkVTXrYgscfIHpsbH9816645 = gkgwOmNxPkVTXrYgscfIHpsbH43364229;     gkgwOmNxPkVTXrYgscfIHpsbH43364229 = gkgwOmNxPkVTXrYgscfIHpsbH75645604;     gkgwOmNxPkVTXrYgscfIHpsbH75645604 = gkgwOmNxPkVTXrYgscfIHpsbH71530890;     gkgwOmNxPkVTXrYgscfIHpsbH71530890 = gkgwOmNxPkVTXrYgscfIHpsbH51314530;     gkgwOmNxPkVTXrYgscfIHpsbH51314530 = gkgwOmNxPkVTXrYgscfIHpsbH85320801;     gkgwOmNxPkVTXrYgscfIHpsbH85320801 = gkgwOmNxPkVTXrYgscfIHpsbH94085327;     gkgwOmNxPkVTXrYgscfIHpsbH94085327 = gkgwOmNxPkVTXrYgscfIHpsbH30987309;     gkgwOmNxPkVTXrYgscfIHpsbH30987309 = gkgwOmNxPkVTXrYgscfIHpsbH81701030;     gkgwOmNxPkVTXrYgscfIHpsbH81701030 = gkgwOmNxPkVTXrYgscfIHpsbH24461274;     gkgwOmNxPkVTXrYgscfIHpsbH24461274 = gkgwOmNxPkVTXrYgscfIHpsbH95351990;     gkgwOmNxPkVTXrYgscfIHpsbH95351990 = gkgwOmNxPkVTXrYgscfIHpsbH3652159;     gkgwOmNxPkVTXrYgscfIHpsbH3652159 = gkgwOmNxPkVTXrYgscfIHpsbH90705992;     gkgwOmNxPkVTXrYgscfIHpsbH90705992 = gkgwOmNxPkVTXrYgscfIHpsbH29470366;     gkgwOmNxPkVTXrYgscfIHpsbH29470366 = gkgwOmNxPkVTXrYgscfIHpsbH3600605;     gkgwOmNxPkVTXrYgscfIHpsbH3600605 = gkgwOmNxPkVTXrYgscfIHpsbH87204524;     gkgwOmNxPkVTXrYgscfIHpsbH87204524 = gkgwOmNxPkVTXrYgscfIHpsbH67292972;     gkgwOmNxPkVTXrYgscfIHpsbH67292972 = gkgwOmNxPkVTXrYgscfIHpsbH84471781;     gkgwOmNxPkVTXrYgscfIHpsbH84471781 = gkgwOmNxPkVTXrYgscfIHpsbH69907052;     gkgwOmNxPkVTXrYgscfIHpsbH69907052 = gkgwOmNxPkVTXrYgscfIHpsbH52900005;     gkgwOmNxPkVTXrYgscfIHpsbH52900005 = gkgwOmNxPkVTXrYgscfIHpsbH82417670;     gkgwOmNxPkVTXrYgscfIHpsbH82417670 = gkgwOmNxPkVTXrYgscfIHpsbH14810710;     gkgwOmNxPkVTXrYgscfIHpsbH14810710 = gkgwOmNxPkVTXrYgscfIHpsbH46806779;     gkgwOmNxPkVTXrYgscfIHpsbH46806779 = gkgwOmNxPkVTXrYgscfIHpsbH42766559;     gkgwOmNxPkVTXrYgscfIHpsbH42766559 = gkgwOmNxPkVTXrYgscfIHpsbH54699472;     gkgwOmNxPkVTXrYgscfIHpsbH54699472 = gkgwOmNxPkVTXrYgscfIHpsbH75314815;     gkgwOmNxPkVTXrYgscfIHpsbH75314815 = gkgwOmNxPkVTXrYgscfIHpsbH40682068;     gkgwOmNxPkVTXrYgscfIHpsbH40682068 = gkgwOmNxPkVTXrYgscfIHpsbH60915050;     gkgwOmNxPkVTXrYgscfIHpsbH60915050 = gkgwOmNxPkVTXrYgscfIHpsbH172837;     gkgwOmNxPkVTXrYgscfIHpsbH172837 = gkgwOmNxPkVTXrYgscfIHpsbH68764170;     gkgwOmNxPkVTXrYgscfIHpsbH68764170 = gkgwOmNxPkVTXrYgscfIHpsbH96706890;     gkgwOmNxPkVTXrYgscfIHpsbH96706890 = gkgwOmNxPkVTXrYgscfIHpsbH92541853;     gkgwOmNxPkVTXrYgscfIHpsbH92541853 = gkgwOmNxPkVTXrYgscfIHpsbH51529261;     gkgwOmNxPkVTXrYgscfIHpsbH51529261 = gkgwOmNxPkVTXrYgscfIHpsbH81496761;     gkgwOmNxPkVTXrYgscfIHpsbH81496761 = gkgwOmNxPkVTXrYgscfIHpsbH63010737;     gkgwOmNxPkVTXrYgscfIHpsbH63010737 = gkgwOmNxPkVTXrYgscfIHpsbH45365458;     gkgwOmNxPkVTXrYgscfIHpsbH45365458 = gkgwOmNxPkVTXrYgscfIHpsbH79551666;     gkgwOmNxPkVTXrYgscfIHpsbH79551666 = gkgwOmNxPkVTXrYgscfIHpsbH78273686;     gkgwOmNxPkVTXrYgscfIHpsbH78273686 = gkgwOmNxPkVTXrYgscfIHpsbH56885461;     gkgwOmNxPkVTXrYgscfIHpsbH56885461 = gkgwOmNxPkVTXrYgscfIHpsbH61824746;     gkgwOmNxPkVTXrYgscfIHpsbH61824746 = gkgwOmNxPkVTXrYgscfIHpsbH49497851;     gkgwOmNxPkVTXrYgscfIHpsbH49497851 = gkgwOmNxPkVTXrYgscfIHpsbH31685338;     gkgwOmNxPkVTXrYgscfIHpsbH31685338 = gkgwOmNxPkVTXrYgscfIHpsbH30723747;     gkgwOmNxPkVTXrYgscfIHpsbH30723747 = gkgwOmNxPkVTXrYgscfIHpsbH18873691;     gkgwOmNxPkVTXrYgscfIHpsbH18873691 = gkgwOmNxPkVTXrYgscfIHpsbH32531536;     gkgwOmNxPkVTXrYgscfIHpsbH32531536 = gkgwOmNxPkVTXrYgscfIHpsbH76212348;     gkgwOmNxPkVTXrYgscfIHpsbH76212348 = gkgwOmNxPkVTXrYgscfIHpsbH25779921;     gkgwOmNxPkVTXrYgscfIHpsbH25779921 = gkgwOmNxPkVTXrYgscfIHpsbH26050800;     gkgwOmNxPkVTXrYgscfIHpsbH26050800 = gkgwOmNxPkVTXrYgscfIHpsbH68719013;     gkgwOmNxPkVTXrYgscfIHpsbH68719013 = gkgwOmNxPkVTXrYgscfIHpsbH37741313;     gkgwOmNxPkVTXrYgscfIHpsbH37741313 = gkgwOmNxPkVTXrYgscfIHpsbH71769208;     gkgwOmNxPkVTXrYgscfIHpsbH71769208 = gkgwOmNxPkVTXrYgscfIHpsbH80968510;     gkgwOmNxPkVTXrYgscfIHpsbH80968510 = gkgwOmNxPkVTXrYgscfIHpsbH52302076;     gkgwOmNxPkVTXrYgscfIHpsbH52302076 = gkgwOmNxPkVTXrYgscfIHpsbH17071182;     gkgwOmNxPkVTXrYgscfIHpsbH17071182 = gkgwOmNxPkVTXrYgscfIHpsbH10773069;     gkgwOmNxPkVTXrYgscfIHpsbH10773069 = gkgwOmNxPkVTXrYgscfIHpsbH95005934;     gkgwOmNxPkVTXrYgscfIHpsbH95005934 = gkgwOmNxPkVTXrYgscfIHpsbH96557450;     gkgwOmNxPkVTXrYgscfIHpsbH96557450 = gkgwOmNxPkVTXrYgscfIHpsbH32879045;     gkgwOmNxPkVTXrYgscfIHpsbH32879045 = gkgwOmNxPkVTXrYgscfIHpsbH16831418;     gkgwOmNxPkVTXrYgscfIHpsbH16831418 = gkgwOmNxPkVTXrYgscfIHpsbH75999714;     gkgwOmNxPkVTXrYgscfIHpsbH75999714 = gkgwOmNxPkVTXrYgscfIHpsbH44638734;     gkgwOmNxPkVTXrYgscfIHpsbH44638734 = gkgwOmNxPkVTXrYgscfIHpsbH33170277;     gkgwOmNxPkVTXrYgscfIHpsbH33170277 = gkgwOmNxPkVTXrYgscfIHpsbH30814472;     gkgwOmNxPkVTXrYgscfIHpsbH30814472 = gkgwOmNxPkVTXrYgscfIHpsbH12936861;     gkgwOmNxPkVTXrYgscfIHpsbH12936861 = gkgwOmNxPkVTXrYgscfIHpsbH27754384;     gkgwOmNxPkVTXrYgscfIHpsbH27754384 = gkgwOmNxPkVTXrYgscfIHpsbH2810138;     gkgwOmNxPkVTXrYgscfIHpsbH2810138 = gkgwOmNxPkVTXrYgscfIHpsbH52122898;     gkgwOmNxPkVTXrYgscfIHpsbH52122898 = gkgwOmNxPkVTXrYgscfIHpsbH9209231;     gkgwOmNxPkVTXrYgscfIHpsbH9209231 = gkgwOmNxPkVTXrYgscfIHpsbH66459628;     gkgwOmNxPkVTXrYgscfIHpsbH66459628 = gkgwOmNxPkVTXrYgscfIHpsbH58235146;     gkgwOmNxPkVTXrYgscfIHpsbH58235146 = gkgwOmNxPkVTXrYgscfIHpsbH7652858;     gkgwOmNxPkVTXrYgscfIHpsbH7652858 = gkgwOmNxPkVTXrYgscfIHpsbH89019285;     gkgwOmNxPkVTXrYgscfIHpsbH89019285 = gkgwOmNxPkVTXrYgscfIHpsbH27586321;     gkgwOmNxPkVTXrYgscfIHpsbH27586321 = gkgwOmNxPkVTXrYgscfIHpsbH8082306;     gkgwOmNxPkVTXrYgscfIHpsbH8082306 = gkgwOmNxPkVTXrYgscfIHpsbH3402155;     gkgwOmNxPkVTXrYgscfIHpsbH3402155 = gkgwOmNxPkVTXrYgscfIHpsbH50732332;     gkgwOmNxPkVTXrYgscfIHpsbH50732332 = gkgwOmNxPkVTXrYgscfIHpsbH84086963;     gkgwOmNxPkVTXrYgscfIHpsbH84086963 = gkgwOmNxPkVTXrYgscfIHpsbH27933088;     gkgwOmNxPkVTXrYgscfIHpsbH27933088 = gkgwOmNxPkVTXrYgscfIHpsbH10235024;     gkgwOmNxPkVTXrYgscfIHpsbH10235024 = gkgwOmNxPkVTXrYgscfIHpsbH78487123;     gkgwOmNxPkVTXrYgscfIHpsbH78487123 = gkgwOmNxPkVTXrYgscfIHpsbH49534894;     gkgwOmNxPkVTXrYgscfIHpsbH49534894 = gkgwOmNxPkVTXrYgscfIHpsbH14631269;     gkgwOmNxPkVTXrYgscfIHpsbH14631269 = gkgwOmNxPkVTXrYgscfIHpsbH92196037;     gkgwOmNxPkVTXrYgscfIHpsbH92196037 = gkgwOmNxPkVTXrYgscfIHpsbH62431523;     gkgwOmNxPkVTXrYgscfIHpsbH62431523 = gkgwOmNxPkVTXrYgscfIHpsbH96994961;     gkgwOmNxPkVTXrYgscfIHpsbH96994961 = gkgwOmNxPkVTXrYgscfIHpsbH15738380;     gkgwOmNxPkVTXrYgscfIHpsbH15738380 = gkgwOmNxPkVTXrYgscfIHpsbH40239778;     gkgwOmNxPkVTXrYgscfIHpsbH40239778 = gkgwOmNxPkVTXrYgscfIHpsbH34458079;     gkgwOmNxPkVTXrYgscfIHpsbH34458079 = gkgwOmNxPkVTXrYgscfIHpsbH70723693;     gkgwOmNxPkVTXrYgscfIHpsbH70723693 = gkgwOmNxPkVTXrYgscfIHpsbH68004802;     gkgwOmNxPkVTXrYgscfIHpsbH68004802 = gkgwOmNxPkVTXrYgscfIHpsbH48808008;     gkgwOmNxPkVTXrYgscfIHpsbH48808008 = gkgwOmNxPkVTXrYgscfIHpsbH16485913;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void jUvRQRNTdlTEcQoXxyZazaNHRqTmdjgEHddZTCjIesfIhTwJXlzFlpKIH94913575() {     long ozZyapuEPwymPDvPQwHvEZxuJ22603020 = -598503048;    long ozZyapuEPwymPDvPQwHvEZxuJ98894444 = -33734824;    long ozZyapuEPwymPDvPQwHvEZxuJ88361800 = -261089717;    long ozZyapuEPwymPDvPQwHvEZxuJ52020618 = 98297512;    long ozZyapuEPwymPDvPQwHvEZxuJ7957669 = -241046559;    long ozZyapuEPwymPDvPQwHvEZxuJ56857494 = -154916711;    long ozZyapuEPwymPDvPQwHvEZxuJ82698094 = -943309230;    long ozZyapuEPwymPDvPQwHvEZxuJ19731078 = -284561541;    long ozZyapuEPwymPDvPQwHvEZxuJ57833234 = -441097281;    long ozZyapuEPwymPDvPQwHvEZxuJ51046304 = 36008479;    long ozZyapuEPwymPDvPQwHvEZxuJ3474520 = -695159995;    long ozZyapuEPwymPDvPQwHvEZxuJ7468647 = -788903316;    long ozZyapuEPwymPDvPQwHvEZxuJ57740008 = -224568556;    long ozZyapuEPwymPDvPQwHvEZxuJ34458207 = -101265559;    long ozZyapuEPwymPDvPQwHvEZxuJ81063228 = -780213008;    long ozZyapuEPwymPDvPQwHvEZxuJ35590721 = -385795449;    long ozZyapuEPwymPDvPQwHvEZxuJ24823312 = -30127640;    long ozZyapuEPwymPDvPQwHvEZxuJ78754183 = -515163338;    long ozZyapuEPwymPDvPQwHvEZxuJ86291116 = -745320997;    long ozZyapuEPwymPDvPQwHvEZxuJ75902155 = -136794230;    long ozZyapuEPwymPDvPQwHvEZxuJ92205351 = -100619470;    long ozZyapuEPwymPDvPQwHvEZxuJ77227016 = -658845479;    long ozZyapuEPwymPDvPQwHvEZxuJ65061157 = -324730253;    long ozZyapuEPwymPDvPQwHvEZxuJ87592978 = -931191964;    long ozZyapuEPwymPDvPQwHvEZxuJ30904175 = 56886085;    long ozZyapuEPwymPDvPQwHvEZxuJ92014647 = -427938690;    long ozZyapuEPwymPDvPQwHvEZxuJ82931559 = -148449768;    long ozZyapuEPwymPDvPQwHvEZxuJ83014177 = -890568066;    long ozZyapuEPwymPDvPQwHvEZxuJ19032261 = 9793348;    long ozZyapuEPwymPDvPQwHvEZxuJ51033307 = -129196912;    long ozZyapuEPwymPDvPQwHvEZxuJ7053259 = -719007926;    long ozZyapuEPwymPDvPQwHvEZxuJ44417401 = -286105902;    long ozZyapuEPwymPDvPQwHvEZxuJ52477508 = -909610293;    long ozZyapuEPwymPDvPQwHvEZxuJ49530036 = -647843242;    long ozZyapuEPwymPDvPQwHvEZxuJ36789467 = -967950512;    long ozZyapuEPwymPDvPQwHvEZxuJ9407981 = -910678929;    long ozZyapuEPwymPDvPQwHvEZxuJ42176985 = -439929551;    long ozZyapuEPwymPDvPQwHvEZxuJ34263049 = -871646791;    long ozZyapuEPwymPDvPQwHvEZxuJ42374424 = -36103114;    long ozZyapuEPwymPDvPQwHvEZxuJ84208827 = -924963095;    long ozZyapuEPwymPDvPQwHvEZxuJ98211077 = -335973048;    long ozZyapuEPwymPDvPQwHvEZxuJ83679717 = -865190684;    long ozZyapuEPwymPDvPQwHvEZxuJ59563740 = -195154714;    long ozZyapuEPwymPDvPQwHvEZxuJ50418478 = -420968535;    long ozZyapuEPwymPDvPQwHvEZxuJ57317923 = -299291909;    long ozZyapuEPwymPDvPQwHvEZxuJ91490861 = -379775053;    long ozZyapuEPwymPDvPQwHvEZxuJ96052260 = -219941661;    long ozZyapuEPwymPDvPQwHvEZxuJ64842401 = -654121785;    long ozZyapuEPwymPDvPQwHvEZxuJ71500475 = -929041572;    long ozZyapuEPwymPDvPQwHvEZxuJ62409503 = -401092731;    long ozZyapuEPwymPDvPQwHvEZxuJ67386016 = -886073590;    long ozZyapuEPwymPDvPQwHvEZxuJ41533466 = -572046761;    long ozZyapuEPwymPDvPQwHvEZxuJ67122148 = -674277065;    long ozZyapuEPwymPDvPQwHvEZxuJ28500416 = -692526006;    long ozZyapuEPwymPDvPQwHvEZxuJ2708224 = -818511684;    long ozZyapuEPwymPDvPQwHvEZxuJ45376004 = -939657570;    long ozZyapuEPwymPDvPQwHvEZxuJ33833287 = -709004571;    long ozZyapuEPwymPDvPQwHvEZxuJ768823 = -329897754;    long ozZyapuEPwymPDvPQwHvEZxuJ21116444 = -958588573;    long ozZyapuEPwymPDvPQwHvEZxuJ15943022 = -813107869;    long ozZyapuEPwymPDvPQwHvEZxuJ73925935 = 93533057;    long ozZyapuEPwymPDvPQwHvEZxuJ99683916 = 47258836;    long ozZyapuEPwymPDvPQwHvEZxuJ698818 = -194354889;    long ozZyapuEPwymPDvPQwHvEZxuJ6799928 = -211900369;    long ozZyapuEPwymPDvPQwHvEZxuJ43993045 = -244983596;    long ozZyapuEPwymPDvPQwHvEZxuJ59057119 = -309054093;    long ozZyapuEPwymPDvPQwHvEZxuJ54991139 = -879293023;    long ozZyapuEPwymPDvPQwHvEZxuJ8209972 = -576725315;    long ozZyapuEPwymPDvPQwHvEZxuJ97668739 = -133315047;    long ozZyapuEPwymPDvPQwHvEZxuJ71655247 = -869534080;    long ozZyapuEPwymPDvPQwHvEZxuJ93413735 = -945865899;    long ozZyapuEPwymPDvPQwHvEZxuJ90560262 = -158480850;    long ozZyapuEPwymPDvPQwHvEZxuJ36379760 = -379060224;    long ozZyapuEPwymPDvPQwHvEZxuJ2082289 = -820357902;    long ozZyapuEPwymPDvPQwHvEZxuJ77691078 = -800821183;    long ozZyapuEPwymPDvPQwHvEZxuJ8525635 = -235428786;    long ozZyapuEPwymPDvPQwHvEZxuJ17663276 = -363690765;    long ozZyapuEPwymPDvPQwHvEZxuJ14642680 = -903761719;    long ozZyapuEPwymPDvPQwHvEZxuJ30275055 = -531900055;    long ozZyapuEPwymPDvPQwHvEZxuJ39413313 = -563338863;    long ozZyapuEPwymPDvPQwHvEZxuJ95962386 = -107997030;    long ozZyapuEPwymPDvPQwHvEZxuJ18089158 = -494327983;    long ozZyapuEPwymPDvPQwHvEZxuJ11513702 = -961526495;    long ozZyapuEPwymPDvPQwHvEZxuJ56622757 = -589113922;    long ozZyapuEPwymPDvPQwHvEZxuJ83647290 = -243123323;    long ozZyapuEPwymPDvPQwHvEZxuJ65519793 = -46961165;    long ozZyapuEPwymPDvPQwHvEZxuJ77295252 = -611828837;    long ozZyapuEPwymPDvPQwHvEZxuJ23977092 = -117084287;    long ozZyapuEPwymPDvPQwHvEZxuJ46821813 = -829331558;    long ozZyapuEPwymPDvPQwHvEZxuJ91413463 = 71707057;    long ozZyapuEPwymPDvPQwHvEZxuJ75574694 = -101674359;    long ozZyapuEPwymPDvPQwHvEZxuJ41408162 = -10031798;    long ozZyapuEPwymPDvPQwHvEZxuJ13146606 = -913058218;    long ozZyapuEPwymPDvPQwHvEZxuJ26431402 = -222995246;    long ozZyapuEPwymPDvPQwHvEZxuJ10282893 = -918496152;    long ozZyapuEPwymPDvPQwHvEZxuJ98527160 = -283231884;    long ozZyapuEPwymPDvPQwHvEZxuJ82980900 = -570835796;    long ozZyapuEPwymPDvPQwHvEZxuJ52763813 = -983254346;    long ozZyapuEPwymPDvPQwHvEZxuJ6425434 = -75984939;    long ozZyapuEPwymPDvPQwHvEZxuJ98260804 = -598503048;     ozZyapuEPwymPDvPQwHvEZxuJ22603020 = ozZyapuEPwymPDvPQwHvEZxuJ98894444;     ozZyapuEPwymPDvPQwHvEZxuJ98894444 = ozZyapuEPwymPDvPQwHvEZxuJ88361800;     ozZyapuEPwymPDvPQwHvEZxuJ88361800 = ozZyapuEPwymPDvPQwHvEZxuJ52020618;     ozZyapuEPwymPDvPQwHvEZxuJ52020618 = ozZyapuEPwymPDvPQwHvEZxuJ7957669;     ozZyapuEPwymPDvPQwHvEZxuJ7957669 = ozZyapuEPwymPDvPQwHvEZxuJ56857494;     ozZyapuEPwymPDvPQwHvEZxuJ56857494 = ozZyapuEPwymPDvPQwHvEZxuJ82698094;     ozZyapuEPwymPDvPQwHvEZxuJ82698094 = ozZyapuEPwymPDvPQwHvEZxuJ19731078;     ozZyapuEPwymPDvPQwHvEZxuJ19731078 = ozZyapuEPwymPDvPQwHvEZxuJ57833234;     ozZyapuEPwymPDvPQwHvEZxuJ57833234 = ozZyapuEPwymPDvPQwHvEZxuJ51046304;     ozZyapuEPwymPDvPQwHvEZxuJ51046304 = ozZyapuEPwymPDvPQwHvEZxuJ3474520;     ozZyapuEPwymPDvPQwHvEZxuJ3474520 = ozZyapuEPwymPDvPQwHvEZxuJ7468647;     ozZyapuEPwymPDvPQwHvEZxuJ7468647 = ozZyapuEPwymPDvPQwHvEZxuJ57740008;     ozZyapuEPwymPDvPQwHvEZxuJ57740008 = ozZyapuEPwymPDvPQwHvEZxuJ34458207;     ozZyapuEPwymPDvPQwHvEZxuJ34458207 = ozZyapuEPwymPDvPQwHvEZxuJ81063228;     ozZyapuEPwymPDvPQwHvEZxuJ81063228 = ozZyapuEPwymPDvPQwHvEZxuJ35590721;     ozZyapuEPwymPDvPQwHvEZxuJ35590721 = ozZyapuEPwymPDvPQwHvEZxuJ24823312;     ozZyapuEPwymPDvPQwHvEZxuJ24823312 = ozZyapuEPwymPDvPQwHvEZxuJ78754183;     ozZyapuEPwymPDvPQwHvEZxuJ78754183 = ozZyapuEPwymPDvPQwHvEZxuJ86291116;     ozZyapuEPwymPDvPQwHvEZxuJ86291116 = ozZyapuEPwymPDvPQwHvEZxuJ75902155;     ozZyapuEPwymPDvPQwHvEZxuJ75902155 = ozZyapuEPwymPDvPQwHvEZxuJ92205351;     ozZyapuEPwymPDvPQwHvEZxuJ92205351 = ozZyapuEPwymPDvPQwHvEZxuJ77227016;     ozZyapuEPwymPDvPQwHvEZxuJ77227016 = ozZyapuEPwymPDvPQwHvEZxuJ65061157;     ozZyapuEPwymPDvPQwHvEZxuJ65061157 = ozZyapuEPwymPDvPQwHvEZxuJ87592978;     ozZyapuEPwymPDvPQwHvEZxuJ87592978 = ozZyapuEPwymPDvPQwHvEZxuJ30904175;     ozZyapuEPwymPDvPQwHvEZxuJ30904175 = ozZyapuEPwymPDvPQwHvEZxuJ92014647;     ozZyapuEPwymPDvPQwHvEZxuJ92014647 = ozZyapuEPwymPDvPQwHvEZxuJ82931559;     ozZyapuEPwymPDvPQwHvEZxuJ82931559 = ozZyapuEPwymPDvPQwHvEZxuJ83014177;     ozZyapuEPwymPDvPQwHvEZxuJ83014177 = ozZyapuEPwymPDvPQwHvEZxuJ19032261;     ozZyapuEPwymPDvPQwHvEZxuJ19032261 = ozZyapuEPwymPDvPQwHvEZxuJ51033307;     ozZyapuEPwymPDvPQwHvEZxuJ51033307 = ozZyapuEPwymPDvPQwHvEZxuJ7053259;     ozZyapuEPwymPDvPQwHvEZxuJ7053259 = ozZyapuEPwymPDvPQwHvEZxuJ44417401;     ozZyapuEPwymPDvPQwHvEZxuJ44417401 = ozZyapuEPwymPDvPQwHvEZxuJ52477508;     ozZyapuEPwymPDvPQwHvEZxuJ52477508 = ozZyapuEPwymPDvPQwHvEZxuJ49530036;     ozZyapuEPwymPDvPQwHvEZxuJ49530036 = ozZyapuEPwymPDvPQwHvEZxuJ36789467;     ozZyapuEPwymPDvPQwHvEZxuJ36789467 = ozZyapuEPwymPDvPQwHvEZxuJ9407981;     ozZyapuEPwymPDvPQwHvEZxuJ9407981 = ozZyapuEPwymPDvPQwHvEZxuJ42176985;     ozZyapuEPwymPDvPQwHvEZxuJ42176985 = ozZyapuEPwymPDvPQwHvEZxuJ34263049;     ozZyapuEPwymPDvPQwHvEZxuJ34263049 = ozZyapuEPwymPDvPQwHvEZxuJ42374424;     ozZyapuEPwymPDvPQwHvEZxuJ42374424 = ozZyapuEPwymPDvPQwHvEZxuJ84208827;     ozZyapuEPwymPDvPQwHvEZxuJ84208827 = ozZyapuEPwymPDvPQwHvEZxuJ98211077;     ozZyapuEPwymPDvPQwHvEZxuJ98211077 = ozZyapuEPwymPDvPQwHvEZxuJ83679717;     ozZyapuEPwymPDvPQwHvEZxuJ83679717 = ozZyapuEPwymPDvPQwHvEZxuJ59563740;     ozZyapuEPwymPDvPQwHvEZxuJ59563740 = ozZyapuEPwymPDvPQwHvEZxuJ50418478;     ozZyapuEPwymPDvPQwHvEZxuJ50418478 = ozZyapuEPwymPDvPQwHvEZxuJ57317923;     ozZyapuEPwymPDvPQwHvEZxuJ57317923 = ozZyapuEPwymPDvPQwHvEZxuJ91490861;     ozZyapuEPwymPDvPQwHvEZxuJ91490861 = ozZyapuEPwymPDvPQwHvEZxuJ96052260;     ozZyapuEPwymPDvPQwHvEZxuJ96052260 = ozZyapuEPwymPDvPQwHvEZxuJ64842401;     ozZyapuEPwymPDvPQwHvEZxuJ64842401 = ozZyapuEPwymPDvPQwHvEZxuJ71500475;     ozZyapuEPwymPDvPQwHvEZxuJ71500475 = ozZyapuEPwymPDvPQwHvEZxuJ62409503;     ozZyapuEPwymPDvPQwHvEZxuJ62409503 = ozZyapuEPwymPDvPQwHvEZxuJ67386016;     ozZyapuEPwymPDvPQwHvEZxuJ67386016 = ozZyapuEPwymPDvPQwHvEZxuJ41533466;     ozZyapuEPwymPDvPQwHvEZxuJ41533466 = ozZyapuEPwymPDvPQwHvEZxuJ67122148;     ozZyapuEPwymPDvPQwHvEZxuJ67122148 = ozZyapuEPwymPDvPQwHvEZxuJ28500416;     ozZyapuEPwymPDvPQwHvEZxuJ28500416 = ozZyapuEPwymPDvPQwHvEZxuJ2708224;     ozZyapuEPwymPDvPQwHvEZxuJ2708224 = ozZyapuEPwymPDvPQwHvEZxuJ45376004;     ozZyapuEPwymPDvPQwHvEZxuJ45376004 = ozZyapuEPwymPDvPQwHvEZxuJ33833287;     ozZyapuEPwymPDvPQwHvEZxuJ33833287 = ozZyapuEPwymPDvPQwHvEZxuJ768823;     ozZyapuEPwymPDvPQwHvEZxuJ768823 = ozZyapuEPwymPDvPQwHvEZxuJ21116444;     ozZyapuEPwymPDvPQwHvEZxuJ21116444 = ozZyapuEPwymPDvPQwHvEZxuJ15943022;     ozZyapuEPwymPDvPQwHvEZxuJ15943022 = ozZyapuEPwymPDvPQwHvEZxuJ73925935;     ozZyapuEPwymPDvPQwHvEZxuJ73925935 = ozZyapuEPwymPDvPQwHvEZxuJ99683916;     ozZyapuEPwymPDvPQwHvEZxuJ99683916 = ozZyapuEPwymPDvPQwHvEZxuJ698818;     ozZyapuEPwymPDvPQwHvEZxuJ698818 = ozZyapuEPwymPDvPQwHvEZxuJ6799928;     ozZyapuEPwymPDvPQwHvEZxuJ6799928 = ozZyapuEPwymPDvPQwHvEZxuJ43993045;     ozZyapuEPwymPDvPQwHvEZxuJ43993045 = ozZyapuEPwymPDvPQwHvEZxuJ59057119;     ozZyapuEPwymPDvPQwHvEZxuJ59057119 = ozZyapuEPwymPDvPQwHvEZxuJ54991139;     ozZyapuEPwymPDvPQwHvEZxuJ54991139 = ozZyapuEPwymPDvPQwHvEZxuJ8209972;     ozZyapuEPwymPDvPQwHvEZxuJ8209972 = ozZyapuEPwymPDvPQwHvEZxuJ97668739;     ozZyapuEPwymPDvPQwHvEZxuJ97668739 = ozZyapuEPwymPDvPQwHvEZxuJ71655247;     ozZyapuEPwymPDvPQwHvEZxuJ71655247 = ozZyapuEPwymPDvPQwHvEZxuJ93413735;     ozZyapuEPwymPDvPQwHvEZxuJ93413735 = ozZyapuEPwymPDvPQwHvEZxuJ90560262;     ozZyapuEPwymPDvPQwHvEZxuJ90560262 = ozZyapuEPwymPDvPQwHvEZxuJ36379760;     ozZyapuEPwymPDvPQwHvEZxuJ36379760 = ozZyapuEPwymPDvPQwHvEZxuJ2082289;     ozZyapuEPwymPDvPQwHvEZxuJ2082289 = ozZyapuEPwymPDvPQwHvEZxuJ77691078;     ozZyapuEPwymPDvPQwHvEZxuJ77691078 = ozZyapuEPwymPDvPQwHvEZxuJ8525635;     ozZyapuEPwymPDvPQwHvEZxuJ8525635 = ozZyapuEPwymPDvPQwHvEZxuJ17663276;     ozZyapuEPwymPDvPQwHvEZxuJ17663276 = ozZyapuEPwymPDvPQwHvEZxuJ14642680;     ozZyapuEPwymPDvPQwHvEZxuJ14642680 = ozZyapuEPwymPDvPQwHvEZxuJ30275055;     ozZyapuEPwymPDvPQwHvEZxuJ30275055 = ozZyapuEPwymPDvPQwHvEZxuJ39413313;     ozZyapuEPwymPDvPQwHvEZxuJ39413313 = ozZyapuEPwymPDvPQwHvEZxuJ95962386;     ozZyapuEPwymPDvPQwHvEZxuJ95962386 = ozZyapuEPwymPDvPQwHvEZxuJ18089158;     ozZyapuEPwymPDvPQwHvEZxuJ18089158 = ozZyapuEPwymPDvPQwHvEZxuJ11513702;     ozZyapuEPwymPDvPQwHvEZxuJ11513702 = ozZyapuEPwymPDvPQwHvEZxuJ56622757;     ozZyapuEPwymPDvPQwHvEZxuJ56622757 = ozZyapuEPwymPDvPQwHvEZxuJ83647290;     ozZyapuEPwymPDvPQwHvEZxuJ83647290 = ozZyapuEPwymPDvPQwHvEZxuJ65519793;     ozZyapuEPwymPDvPQwHvEZxuJ65519793 = ozZyapuEPwymPDvPQwHvEZxuJ77295252;     ozZyapuEPwymPDvPQwHvEZxuJ77295252 = ozZyapuEPwymPDvPQwHvEZxuJ23977092;     ozZyapuEPwymPDvPQwHvEZxuJ23977092 = ozZyapuEPwymPDvPQwHvEZxuJ46821813;     ozZyapuEPwymPDvPQwHvEZxuJ46821813 = ozZyapuEPwymPDvPQwHvEZxuJ91413463;     ozZyapuEPwymPDvPQwHvEZxuJ91413463 = ozZyapuEPwymPDvPQwHvEZxuJ75574694;     ozZyapuEPwymPDvPQwHvEZxuJ75574694 = ozZyapuEPwymPDvPQwHvEZxuJ41408162;     ozZyapuEPwymPDvPQwHvEZxuJ41408162 = ozZyapuEPwymPDvPQwHvEZxuJ13146606;     ozZyapuEPwymPDvPQwHvEZxuJ13146606 = ozZyapuEPwymPDvPQwHvEZxuJ26431402;     ozZyapuEPwymPDvPQwHvEZxuJ26431402 = ozZyapuEPwymPDvPQwHvEZxuJ10282893;     ozZyapuEPwymPDvPQwHvEZxuJ10282893 = ozZyapuEPwymPDvPQwHvEZxuJ98527160;     ozZyapuEPwymPDvPQwHvEZxuJ98527160 = ozZyapuEPwymPDvPQwHvEZxuJ82980900;     ozZyapuEPwymPDvPQwHvEZxuJ82980900 = ozZyapuEPwymPDvPQwHvEZxuJ52763813;     ozZyapuEPwymPDvPQwHvEZxuJ52763813 = ozZyapuEPwymPDvPQwHvEZxuJ6425434;     ozZyapuEPwymPDvPQwHvEZxuJ6425434 = ozZyapuEPwymPDvPQwHvEZxuJ98260804;     ozZyapuEPwymPDvPQwHvEZxuJ98260804 = ozZyapuEPwymPDvPQwHvEZxuJ22603020;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void gSJeQAcFqkAItLoKJQxTFEWgqsUtpyxkoDJgZMbWkjRUxrXkGetHplSbv62205174() {     long dnXfjPsmPUpBIkxoaiVnBjzUk58061988 = 35220052;    long dnXfjPsmPUpBIkxoaiVnBjzUk12166523 = 85713570;    long dnXfjPsmPUpBIkxoaiVnBjzUk25748278 = 73243208;    long dnXfjPsmPUpBIkxoaiVnBjzUk24243973 = -822853559;    long dnXfjPsmPUpBIkxoaiVnBjzUk64242938 = -346645404;    long dnXfjPsmPUpBIkxoaiVnBjzUk93080366 = -417264606;    long dnXfjPsmPUpBIkxoaiVnBjzUk93355500 = -788034964;    long dnXfjPsmPUpBIkxoaiVnBjzUk81862638 = 71204319;    long dnXfjPsmPUpBIkxoaiVnBjzUk59350839 = -929428688;    long dnXfjPsmPUpBIkxoaiVnBjzUk65949016 = -728678519;    long dnXfjPsmPUpBIkxoaiVnBjzUk41656254 = -497167724;    long dnXfjPsmPUpBIkxoaiVnBjzUk8036795 = -653024087;    long dnXfjPsmPUpBIkxoaiVnBjzUk95974653 = -776581060;    long dnXfjPsmPUpBIkxoaiVnBjzUk87599070 = -77628968;    long dnXfjPsmPUpBIkxoaiVnBjzUk39257744 = -183638023;    long dnXfjPsmPUpBIkxoaiVnBjzUk19132022 = -21607056;    long dnXfjPsmPUpBIkxoaiVnBjzUk80659247 = -557102193;    long dnXfjPsmPUpBIkxoaiVnBjzUk78514375 = -588591406;    long dnXfjPsmPUpBIkxoaiVnBjzUk86841446 = 38115581;    long dnXfjPsmPUpBIkxoaiVnBjzUk69739374 = -563355296;    long dnXfjPsmPUpBIkxoaiVnBjzUk5292215 = -857894159;    long dnXfjPsmPUpBIkxoaiVnBjzUk80648540 = -745481773;    long dnXfjPsmPUpBIkxoaiVnBjzUk35586537 = 37637562;    long dnXfjPsmPUpBIkxoaiVnBjzUk81385923 = -342016568;    long dnXfjPsmPUpBIkxoaiVnBjzUk38922126 = 32900886;    long dnXfjPsmPUpBIkxoaiVnBjzUk2712819 = -116515497;    long dnXfjPsmPUpBIkxoaiVnBjzUk43352133 = 45266092;    long dnXfjPsmPUpBIkxoaiVnBjzUk23742603 = 39659759;    long dnXfjPsmPUpBIkxoaiVnBjzUk65700475 = -564301455;    long dnXfjPsmPUpBIkxoaiVnBjzUk56566718 = -163704083;    long dnXfjPsmPUpBIkxoaiVnBjzUk25636491 = -170988413;    long dnXfjPsmPUpBIkxoaiVnBjzUk82240419 = -59077316;    long dnXfjPsmPUpBIkxoaiVnBjzUk64695518 = 42793730;    long dnXfjPsmPUpBIkxoaiVnBjzUk79278463 = -712537055;    long dnXfjPsmPUpBIkxoaiVnBjzUk2597921 = -919050763;    long dnXfjPsmPUpBIkxoaiVnBjzUk60968824 = -25244235;    long dnXfjPsmPUpBIkxoaiVnBjzUk91588801 = -304625591;    long dnXfjPsmPUpBIkxoaiVnBjzUk85478452 = -854302372;    long dnXfjPsmPUpBIkxoaiVnBjzUk72764985 = -786979391;    long dnXfjPsmPUpBIkxoaiVnBjzUk48480360 = -390225641;    long dnXfjPsmPUpBIkxoaiVnBjzUk31662685 = -105171962;    long dnXfjPsmPUpBIkxoaiVnBjzUk73044844 = -459735975;    long dnXfjPsmPUpBIkxoaiVnBjzUk48947118 = -848335500;    long dnXfjPsmPUpBIkxoaiVnBjzUk90549816 = 74699055;    long dnXfjPsmPUpBIkxoaiVnBjzUk57334382 = -125803071;    long dnXfjPsmPUpBIkxoaiVnBjzUk37452190 = -418698685;    long dnXfjPsmPUpBIkxoaiVnBjzUk15397425 = -703928021;    long dnXfjPsmPUpBIkxoaiVnBjzUk82568713 = -820648378;    long dnXfjPsmPUpBIkxoaiVnBjzUk94393141 = -592778452;    long dnXfjPsmPUpBIkxoaiVnBjzUk86939092 = -892119547;    long dnXfjPsmPUpBIkxoaiVnBjzUk48156740 = -760350148;    long dnXfjPsmPUpBIkxoaiVnBjzUk25018939 = -785699108;    long dnXfjPsmPUpBIkxoaiVnBjzUk35743297 = -430322619;    long dnXfjPsmPUpBIkxoaiVnBjzUk44492263 = -884034506;    long dnXfjPsmPUpBIkxoaiVnBjzUk56912960 = -65001830;    long dnXfjPsmPUpBIkxoaiVnBjzUk77413447 = -219298176;    long dnXfjPsmPUpBIkxoaiVnBjzUk76579985 = -951923993;    long dnXfjPsmPUpBIkxoaiVnBjzUk44362354 = -584740225;    long dnXfjPsmPUpBIkxoaiVnBjzUk85321847 = -755754446;    long dnXfjPsmPUpBIkxoaiVnBjzUk61530119 = -130129908;    long dnXfjPsmPUpBIkxoaiVnBjzUk49728233 = -362530698;    long dnXfjPsmPUpBIkxoaiVnBjzUk69612898 = -727694724;    long dnXfjPsmPUpBIkxoaiVnBjzUk16162164 = -364494227;    long dnXfjPsmPUpBIkxoaiVnBjzUk2784122 = -665724605;    long dnXfjPsmPUpBIkxoaiVnBjzUk40312525 = -457690107;    long dnXfjPsmPUpBIkxoaiVnBjzUk59415835 = -338090408;    long dnXfjPsmPUpBIkxoaiVnBjzUk43341277 = -595817818;    long dnXfjPsmPUpBIkxoaiVnBjzUk16696191 = 35955994;    long dnXfjPsmPUpBIkxoaiVnBjzUk85001149 = -158578205;    long dnXfjPsmPUpBIkxoaiVnBjzUk78288919 = -58393789;    long dnXfjPsmPUpBIkxoaiVnBjzUk27543220 = -716981465;    long dnXfjPsmPUpBIkxoaiVnBjzUk95180795 = -702799821;    long dnXfjPsmPUpBIkxoaiVnBjzUk5749390 = -801612016;    long dnXfjPsmPUpBIkxoaiVnBjzUk38361086 = -571658778;    long dnXfjPsmPUpBIkxoaiVnBjzUk38076689 = -358183334;    long dnXfjPsmPUpBIkxoaiVnBjzUk32247371 = -298158184;    long dnXfjPsmPUpBIkxoaiVnBjzUk31701423 = -897146273;    long dnXfjPsmPUpBIkxoaiVnBjzUk45036721 = 62938507;    long dnXfjPsmPUpBIkxoaiVnBjzUk24051542 = -116213498;    long dnXfjPsmPUpBIkxoaiVnBjzUk1469936 = -548400429;    long dnXfjPsmPUpBIkxoaiVnBjzUk87315394 = -412587476;    long dnXfjPsmPUpBIkxoaiVnBjzUk60783420 = -134085530;    long dnXfjPsmPUpBIkxoaiVnBjzUk29349461 = -367561789;    long dnXfjPsmPUpBIkxoaiVnBjzUk78761382 = -672181909;    long dnXfjPsmPUpBIkxoaiVnBjzUk8409978 = -403353936;    long dnXfjPsmPUpBIkxoaiVnBjzUk617553 = -385289305;    long dnXfjPsmPUpBIkxoaiVnBjzUk46497122 = -628754698;    long dnXfjPsmPUpBIkxoaiVnBjzUk20203256 = -73171765;    long dnXfjPsmPUpBIkxoaiVnBjzUk22365504 = -547535225;    long dnXfjPsmPUpBIkxoaiVnBjzUk25184474 = -599752588;    long dnXfjPsmPUpBIkxoaiVnBjzUk84388839 = -73320242;    long dnXfjPsmPUpBIkxoaiVnBjzUk47226447 = -719885367;    long dnXfjPsmPUpBIkxoaiVnBjzUk156605 = 1452074;    long dnXfjPsmPUpBIkxoaiVnBjzUk11234866 = -556849484;    long dnXfjPsmPUpBIkxoaiVnBjzUk98752127 = 72305056;    long dnXfjPsmPUpBIkxoaiVnBjzUk62049787 = -377477238;    long dnXfjPsmPUpBIkxoaiVnBjzUk56882681 = 4758251;    long dnXfjPsmPUpBIkxoaiVnBjzUk46162997 = -82610895;    long dnXfjPsmPUpBIkxoaiVnBjzUk50237291 = -467610838;    long dnXfjPsmPUpBIkxoaiVnBjzUk97918546 = 35220052;     dnXfjPsmPUpBIkxoaiVnBjzUk58061988 = dnXfjPsmPUpBIkxoaiVnBjzUk12166523;     dnXfjPsmPUpBIkxoaiVnBjzUk12166523 = dnXfjPsmPUpBIkxoaiVnBjzUk25748278;     dnXfjPsmPUpBIkxoaiVnBjzUk25748278 = dnXfjPsmPUpBIkxoaiVnBjzUk24243973;     dnXfjPsmPUpBIkxoaiVnBjzUk24243973 = dnXfjPsmPUpBIkxoaiVnBjzUk64242938;     dnXfjPsmPUpBIkxoaiVnBjzUk64242938 = dnXfjPsmPUpBIkxoaiVnBjzUk93080366;     dnXfjPsmPUpBIkxoaiVnBjzUk93080366 = dnXfjPsmPUpBIkxoaiVnBjzUk93355500;     dnXfjPsmPUpBIkxoaiVnBjzUk93355500 = dnXfjPsmPUpBIkxoaiVnBjzUk81862638;     dnXfjPsmPUpBIkxoaiVnBjzUk81862638 = dnXfjPsmPUpBIkxoaiVnBjzUk59350839;     dnXfjPsmPUpBIkxoaiVnBjzUk59350839 = dnXfjPsmPUpBIkxoaiVnBjzUk65949016;     dnXfjPsmPUpBIkxoaiVnBjzUk65949016 = dnXfjPsmPUpBIkxoaiVnBjzUk41656254;     dnXfjPsmPUpBIkxoaiVnBjzUk41656254 = dnXfjPsmPUpBIkxoaiVnBjzUk8036795;     dnXfjPsmPUpBIkxoaiVnBjzUk8036795 = dnXfjPsmPUpBIkxoaiVnBjzUk95974653;     dnXfjPsmPUpBIkxoaiVnBjzUk95974653 = dnXfjPsmPUpBIkxoaiVnBjzUk87599070;     dnXfjPsmPUpBIkxoaiVnBjzUk87599070 = dnXfjPsmPUpBIkxoaiVnBjzUk39257744;     dnXfjPsmPUpBIkxoaiVnBjzUk39257744 = dnXfjPsmPUpBIkxoaiVnBjzUk19132022;     dnXfjPsmPUpBIkxoaiVnBjzUk19132022 = dnXfjPsmPUpBIkxoaiVnBjzUk80659247;     dnXfjPsmPUpBIkxoaiVnBjzUk80659247 = dnXfjPsmPUpBIkxoaiVnBjzUk78514375;     dnXfjPsmPUpBIkxoaiVnBjzUk78514375 = dnXfjPsmPUpBIkxoaiVnBjzUk86841446;     dnXfjPsmPUpBIkxoaiVnBjzUk86841446 = dnXfjPsmPUpBIkxoaiVnBjzUk69739374;     dnXfjPsmPUpBIkxoaiVnBjzUk69739374 = dnXfjPsmPUpBIkxoaiVnBjzUk5292215;     dnXfjPsmPUpBIkxoaiVnBjzUk5292215 = dnXfjPsmPUpBIkxoaiVnBjzUk80648540;     dnXfjPsmPUpBIkxoaiVnBjzUk80648540 = dnXfjPsmPUpBIkxoaiVnBjzUk35586537;     dnXfjPsmPUpBIkxoaiVnBjzUk35586537 = dnXfjPsmPUpBIkxoaiVnBjzUk81385923;     dnXfjPsmPUpBIkxoaiVnBjzUk81385923 = dnXfjPsmPUpBIkxoaiVnBjzUk38922126;     dnXfjPsmPUpBIkxoaiVnBjzUk38922126 = dnXfjPsmPUpBIkxoaiVnBjzUk2712819;     dnXfjPsmPUpBIkxoaiVnBjzUk2712819 = dnXfjPsmPUpBIkxoaiVnBjzUk43352133;     dnXfjPsmPUpBIkxoaiVnBjzUk43352133 = dnXfjPsmPUpBIkxoaiVnBjzUk23742603;     dnXfjPsmPUpBIkxoaiVnBjzUk23742603 = dnXfjPsmPUpBIkxoaiVnBjzUk65700475;     dnXfjPsmPUpBIkxoaiVnBjzUk65700475 = dnXfjPsmPUpBIkxoaiVnBjzUk56566718;     dnXfjPsmPUpBIkxoaiVnBjzUk56566718 = dnXfjPsmPUpBIkxoaiVnBjzUk25636491;     dnXfjPsmPUpBIkxoaiVnBjzUk25636491 = dnXfjPsmPUpBIkxoaiVnBjzUk82240419;     dnXfjPsmPUpBIkxoaiVnBjzUk82240419 = dnXfjPsmPUpBIkxoaiVnBjzUk64695518;     dnXfjPsmPUpBIkxoaiVnBjzUk64695518 = dnXfjPsmPUpBIkxoaiVnBjzUk79278463;     dnXfjPsmPUpBIkxoaiVnBjzUk79278463 = dnXfjPsmPUpBIkxoaiVnBjzUk2597921;     dnXfjPsmPUpBIkxoaiVnBjzUk2597921 = dnXfjPsmPUpBIkxoaiVnBjzUk60968824;     dnXfjPsmPUpBIkxoaiVnBjzUk60968824 = dnXfjPsmPUpBIkxoaiVnBjzUk91588801;     dnXfjPsmPUpBIkxoaiVnBjzUk91588801 = dnXfjPsmPUpBIkxoaiVnBjzUk85478452;     dnXfjPsmPUpBIkxoaiVnBjzUk85478452 = dnXfjPsmPUpBIkxoaiVnBjzUk72764985;     dnXfjPsmPUpBIkxoaiVnBjzUk72764985 = dnXfjPsmPUpBIkxoaiVnBjzUk48480360;     dnXfjPsmPUpBIkxoaiVnBjzUk48480360 = dnXfjPsmPUpBIkxoaiVnBjzUk31662685;     dnXfjPsmPUpBIkxoaiVnBjzUk31662685 = dnXfjPsmPUpBIkxoaiVnBjzUk73044844;     dnXfjPsmPUpBIkxoaiVnBjzUk73044844 = dnXfjPsmPUpBIkxoaiVnBjzUk48947118;     dnXfjPsmPUpBIkxoaiVnBjzUk48947118 = dnXfjPsmPUpBIkxoaiVnBjzUk90549816;     dnXfjPsmPUpBIkxoaiVnBjzUk90549816 = dnXfjPsmPUpBIkxoaiVnBjzUk57334382;     dnXfjPsmPUpBIkxoaiVnBjzUk57334382 = dnXfjPsmPUpBIkxoaiVnBjzUk37452190;     dnXfjPsmPUpBIkxoaiVnBjzUk37452190 = dnXfjPsmPUpBIkxoaiVnBjzUk15397425;     dnXfjPsmPUpBIkxoaiVnBjzUk15397425 = dnXfjPsmPUpBIkxoaiVnBjzUk82568713;     dnXfjPsmPUpBIkxoaiVnBjzUk82568713 = dnXfjPsmPUpBIkxoaiVnBjzUk94393141;     dnXfjPsmPUpBIkxoaiVnBjzUk94393141 = dnXfjPsmPUpBIkxoaiVnBjzUk86939092;     dnXfjPsmPUpBIkxoaiVnBjzUk86939092 = dnXfjPsmPUpBIkxoaiVnBjzUk48156740;     dnXfjPsmPUpBIkxoaiVnBjzUk48156740 = dnXfjPsmPUpBIkxoaiVnBjzUk25018939;     dnXfjPsmPUpBIkxoaiVnBjzUk25018939 = dnXfjPsmPUpBIkxoaiVnBjzUk35743297;     dnXfjPsmPUpBIkxoaiVnBjzUk35743297 = dnXfjPsmPUpBIkxoaiVnBjzUk44492263;     dnXfjPsmPUpBIkxoaiVnBjzUk44492263 = dnXfjPsmPUpBIkxoaiVnBjzUk56912960;     dnXfjPsmPUpBIkxoaiVnBjzUk56912960 = dnXfjPsmPUpBIkxoaiVnBjzUk77413447;     dnXfjPsmPUpBIkxoaiVnBjzUk77413447 = dnXfjPsmPUpBIkxoaiVnBjzUk76579985;     dnXfjPsmPUpBIkxoaiVnBjzUk76579985 = dnXfjPsmPUpBIkxoaiVnBjzUk44362354;     dnXfjPsmPUpBIkxoaiVnBjzUk44362354 = dnXfjPsmPUpBIkxoaiVnBjzUk85321847;     dnXfjPsmPUpBIkxoaiVnBjzUk85321847 = dnXfjPsmPUpBIkxoaiVnBjzUk61530119;     dnXfjPsmPUpBIkxoaiVnBjzUk61530119 = dnXfjPsmPUpBIkxoaiVnBjzUk49728233;     dnXfjPsmPUpBIkxoaiVnBjzUk49728233 = dnXfjPsmPUpBIkxoaiVnBjzUk69612898;     dnXfjPsmPUpBIkxoaiVnBjzUk69612898 = dnXfjPsmPUpBIkxoaiVnBjzUk16162164;     dnXfjPsmPUpBIkxoaiVnBjzUk16162164 = dnXfjPsmPUpBIkxoaiVnBjzUk2784122;     dnXfjPsmPUpBIkxoaiVnBjzUk2784122 = dnXfjPsmPUpBIkxoaiVnBjzUk40312525;     dnXfjPsmPUpBIkxoaiVnBjzUk40312525 = dnXfjPsmPUpBIkxoaiVnBjzUk59415835;     dnXfjPsmPUpBIkxoaiVnBjzUk59415835 = dnXfjPsmPUpBIkxoaiVnBjzUk43341277;     dnXfjPsmPUpBIkxoaiVnBjzUk43341277 = dnXfjPsmPUpBIkxoaiVnBjzUk16696191;     dnXfjPsmPUpBIkxoaiVnBjzUk16696191 = dnXfjPsmPUpBIkxoaiVnBjzUk85001149;     dnXfjPsmPUpBIkxoaiVnBjzUk85001149 = dnXfjPsmPUpBIkxoaiVnBjzUk78288919;     dnXfjPsmPUpBIkxoaiVnBjzUk78288919 = dnXfjPsmPUpBIkxoaiVnBjzUk27543220;     dnXfjPsmPUpBIkxoaiVnBjzUk27543220 = dnXfjPsmPUpBIkxoaiVnBjzUk95180795;     dnXfjPsmPUpBIkxoaiVnBjzUk95180795 = dnXfjPsmPUpBIkxoaiVnBjzUk5749390;     dnXfjPsmPUpBIkxoaiVnBjzUk5749390 = dnXfjPsmPUpBIkxoaiVnBjzUk38361086;     dnXfjPsmPUpBIkxoaiVnBjzUk38361086 = dnXfjPsmPUpBIkxoaiVnBjzUk38076689;     dnXfjPsmPUpBIkxoaiVnBjzUk38076689 = dnXfjPsmPUpBIkxoaiVnBjzUk32247371;     dnXfjPsmPUpBIkxoaiVnBjzUk32247371 = dnXfjPsmPUpBIkxoaiVnBjzUk31701423;     dnXfjPsmPUpBIkxoaiVnBjzUk31701423 = dnXfjPsmPUpBIkxoaiVnBjzUk45036721;     dnXfjPsmPUpBIkxoaiVnBjzUk45036721 = dnXfjPsmPUpBIkxoaiVnBjzUk24051542;     dnXfjPsmPUpBIkxoaiVnBjzUk24051542 = dnXfjPsmPUpBIkxoaiVnBjzUk1469936;     dnXfjPsmPUpBIkxoaiVnBjzUk1469936 = dnXfjPsmPUpBIkxoaiVnBjzUk87315394;     dnXfjPsmPUpBIkxoaiVnBjzUk87315394 = dnXfjPsmPUpBIkxoaiVnBjzUk60783420;     dnXfjPsmPUpBIkxoaiVnBjzUk60783420 = dnXfjPsmPUpBIkxoaiVnBjzUk29349461;     dnXfjPsmPUpBIkxoaiVnBjzUk29349461 = dnXfjPsmPUpBIkxoaiVnBjzUk78761382;     dnXfjPsmPUpBIkxoaiVnBjzUk78761382 = dnXfjPsmPUpBIkxoaiVnBjzUk8409978;     dnXfjPsmPUpBIkxoaiVnBjzUk8409978 = dnXfjPsmPUpBIkxoaiVnBjzUk617553;     dnXfjPsmPUpBIkxoaiVnBjzUk617553 = dnXfjPsmPUpBIkxoaiVnBjzUk46497122;     dnXfjPsmPUpBIkxoaiVnBjzUk46497122 = dnXfjPsmPUpBIkxoaiVnBjzUk20203256;     dnXfjPsmPUpBIkxoaiVnBjzUk20203256 = dnXfjPsmPUpBIkxoaiVnBjzUk22365504;     dnXfjPsmPUpBIkxoaiVnBjzUk22365504 = dnXfjPsmPUpBIkxoaiVnBjzUk25184474;     dnXfjPsmPUpBIkxoaiVnBjzUk25184474 = dnXfjPsmPUpBIkxoaiVnBjzUk84388839;     dnXfjPsmPUpBIkxoaiVnBjzUk84388839 = dnXfjPsmPUpBIkxoaiVnBjzUk47226447;     dnXfjPsmPUpBIkxoaiVnBjzUk47226447 = dnXfjPsmPUpBIkxoaiVnBjzUk156605;     dnXfjPsmPUpBIkxoaiVnBjzUk156605 = dnXfjPsmPUpBIkxoaiVnBjzUk11234866;     dnXfjPsmPUpBIkxoaiVnBjzUk11234866 = dnXfjPsmPUpBIkxoaiVnBjzUk98752127;     dnXfjPsmPUpBIkxoaiVnBjzUk98752127 = dnXfjPsmPUpBIkxoaiVnBjzUk62049787;     dnXfjPsmPUpBIkxoaiVnBjzUk62049787 = dnXfjPsmPUpBIkxoaiVnBjzUk56882681;     dnXfjPsmPUpBIkxoaiVnBjzUk56882681 = dnXfjPsmPUpBIkxoaiVnBjzUk46162997;     dnXfjPsmPUpBIkxoaiVnBjzUk46162997 = dnXfjPsmPUpBIkxoaiVnBjzUk50237291;     dnXfjPsmPUpBIkxoaiVnBjzUk50237291 = dnXfjPsmPUpBIkxoaiVnBjzUk97918546;     dnXfjPsmPUpBIkxoaiVnBjzUk97918546 = dnXfjPsmPUpBIkxoaiVnBjzUk58061988;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void GwtdEWrwDtWrMyLUdiycuuscCvWcpbyxLWJrNpPvkxOfmomoHiuFtIJLD77254242() {     long QaJzOGcuYgqpUHoTCrwgNqOIh64179095 = -76681837;    long QaJzOGcuYgqpUHoTCrwgNqOIh55539802 = -723886211;    long QaJzOGcuYgqpUHoTCrwgNqOIh41790461 = -77589713;    long QaJzOGcuYgqpUHoTCrwgNqOIh51318754 = 86397810;    long QaJzOGcuYgqpUHoTCrwgNqOIh33138427 = -867295275;    long QaJzOGcuYgqpUHoTCrwgNqOIh84497568 = -681760841;    long QaJzOGcuYgqpUHoTCrwgNqOIh53844466 = -926999942;    long QaJzOGcuYgqpUHoTCrwgNqOIh31622530 = -215669594;    long QaJzOGcuYgqpUHoTCrwgNqOIh23993335 = -697461353;    long QaJzOGcuYgqpUHoTCrwgNqOIh7178676 = 42346003;    long QaJzOGcuYgqpUHoTCrwgNqOIh1766545 = -374605310;    long QaJzOGcuYgqpUHoTCrwgNqOIh39859838 = 2569711;    long QaJzOGcuYgqpUHoTCrwgNqOIh82183772 = -116472149;    long QaJzOGcuYgqpUHoTCrwgNqOIh70742746 = -609867536;    long QaJzOGcuYgqpUHoTCrwgNqOIh35000171 = -874100190;    long QaJzOGcuYgqpUHoTCrwgNqOIh60637415 = 5393401;    long QaJzOGcuYgqpUHoTCrwgNqOIh74495250 = -73647306;    long QaJzOGcuYgqpUHoTCrwgNqOIh75567528 = -254114049;    long QaJzOGcuYgqpUHoTCrwgNqOIh48671288 = -367653516;    long QaJzOGcuYgqpUHoTCrwgNqOIh50289539 = -920258215;    long QaJzOGcuYgqpUHoTCrwgNqOIh93845407 = -713381615;    long QaJzOGcuYgqpUHoTCrwgNqOIh67169564 = -653411489;    long QaJzOGcuYgqpUHoTCrwgNqOIh71177329 = -808879924;    long QaJzOGcuYgqpUHoTCrwgNqOIh65378297 = -564321556;    long QaJzOGcuYgqpUHoTCrwgNqOIh82621776 = -340295147;    long QaJzOGcuYgqpUHoTCrwgNqOIh27434494 = 4829180;    long QaJzOGcuYgqpUHoTCrwgNqOIh41811911 = -955396111;    long QaJzOGcuYgqpUHoTCrwgNqOIh36849728 = -26269194;    long QaJzOGcuYgqpUHoTCrwgNqOIh31832731 = -786684159;    long QaJzOGcuYgqpUHoTCrwgNqOIh25182355 = 18825050;    long QaJzOGcuYgqpUHoTCrwgNqOIh17879040 = -84309351;    long QaJzOGcuYgqpUHoTCrwgNqOIh79851040 = -868524132;    long QaJzOGcuYgqpUHoTCrwgNqOIh74406467 = -949819641;    long QaJzOGcuYgqpUHoTCrwgNqOIh74109027 = -464078820;    long QaJzOGcuYgqpUHoTCrwgNqOIh64072573 = -457783869;    long QaJzOGcuYgqpUHoTCrwgNqOIh29694738 = -239270342;    long QaJzOGcuYgqpUHoTCrwgNqOIh72850736 = -258261461;    long QaJzOGcuYgqpUHoTCrwgNqOIh19568665 = -625808382;    long QaJzOGcuYgqpUHoTCrwgNqOIh46375239 = -780902888;    long QaJzOGcuYgqpUHoTCrwgNqOIh35982298 = -863664864;    long QaJzOGcuYgqpUHoTCrwgNqOIh37331909 = -170445856;    long QaJzOGcuYgqpUHoTCrwgNqOIh5195302 = -729878253;    long QaJzOGcuYgqpUHoTCrwgNqOIh27014097 = -929140084;    long QaJzOGcuYgqpUHoTCrwgNqOIh77957556 = 55356117;    long QaJzOGcuYgqpUHoTCrwgNqOIh69286846 = -887701225;    long QaJzOGcuYgqpUHoTCrwgNqOIh49391385 = -403914802;    long QaJzOGcuYgqpUHoTCrwgNqOIh33175999 = -822703559;    long QaJzOGcuYgqpUHoTCrwgNqOIh90525654 = -830543911;    long QaJzOGcuYgqpUHoTCrwgNqOIh4068871 = -678515440;    long QaJzOGcuYgqpUHoTCrwgNqOIh99850745 = -979130355;    long QaJzOGcuYgqpUHoTCrwgNqOIh83857418 = -602643819;    long QaJzOGcuYgqpUHoTCrwgNqOIh35828658 = -586425428;    long QaJzOGcuYgqpUHoTCrwgNqOIh83991754 = -222112207;    long QaJzOGcuYgqpUHoTCrwgNqOIh40461143 = -104504651;    long QaJzOGcuYgqpUHoTCrwgNqOIh83408834 = -765533613;    long QaJzOGcuYgqpUHoTCrwgNqOIh97009530 = -423270348;    long QaJzOGcuYgqpUHoTCrwgNqOIh84362473 = -915006287;    long QaJzOGcuYgqpUHoTCrwgNqOIh76412164 = -513268158;    long QaJzOGcuYgqpUHoTCrwgNqOIh68696978 = -573307044;    long QaJzOGcuYgqpUHoTCrwgNqOIh5703933 = -772124456;    long QaJzOGcuYgqpUHoTCrwgNqOIh42685657 = -726364730;    long QaJzOGcuYgqpUHoTCrwgNqOIh16994739 = -800730748;    long QaJzOGcuYgqpUHoTCrwgNqOIh99789799 = -428985436;    long QaJzOGcuYgqpUHoTCrwgNqOIh98810980 = -616286404;    long QaJzOGcuYgqpUHoTCrwgNqOIh89299635 = -873344646;    long QaJzOGcuYgqpUHoTCrwgNqOIh21915504 = -506081179;    long QaJzOGcuYgqpUHoTCrwgNqOIh65453370 = -47610649;    long QaJzOGcuYgqpUHoTCrwgNqOIh8074746 = -652393329;    long QaJzOGcuYgqpUHoTCrwgNqOIh6670174 = -52083668;    long QaJzOGcuYgqpUHoTCrwgNqOIh5305434 = -534829848;    long QaJzOGcuYgqpUHoTCrwgNqOIh87786679 = -736345139;    long QaJzOGcuYgqpUHoTCrwgNqOIh54926586 = -447838925;    long QaJzOGcuYgqpUHoTCrwgNqOIh29192289 = -473211162;    long QaJzOGcuYgqpUHoTCrwgNqOIh12688990 = -503988652;    long QaJzOGcuYgqpUHoTCrwgNqOIh12957630 = -649812359;    long QaJzOGcuYgqpUHoTCrwgNqOIh88650106 = -983503362;    long QaJzOGcuYgqpUHoTCrwgNqOIh40155468 = -724271406;    long QaJzOGcuYgqpUHoTCrwgNqOIh93219772 = -764236042;    long QaJzOGcuYgqpUHoTCrwgNqOIh96091450 = -676620331;    long QaJzOGcuYgqpUHoTCrwgNqOIh33230391 = -936380345;    long QaJzOGcuYgqpUHoTCrwgNqOIh94258495 = -172467262;    long QaJzOGcuYgqpUHoTCrwgNqOIh51286257 = -24852201;    long QaJzOGcuYgqpUHoTCrwgNqOIh32780857 = -347753755;    long QaJzOGcuYgqpUHoTCrwgNqOIh31981985 = -807553805;    long QaJzOGcuYgqpUHoTCrwgNqOIh41324936 = -378531132;    long QaJzOGcuYgqpUHoTCrwgNqOIh82050382 = -497883923;    long QaJzOGcuYgqpUHoTCrwgNqOIh95859286 = -546411926;    long QaJzOGcuYgqpUHoTCrwgNqOIh33945324 = -745314990;    long QaJzOGcuYgqpUHoTCrwgNqOIh90700192 = -698545208;    long QaJzOGcuYgqpUHoTCrwgNqOIh67063042 = 65486479;    long QaJzOGcuYgqpUHoTCrwgNqOIh45332265 = -324264056;    long QaJzOGcuYgqpUHoTCrwgNqOIh96438572 = -744993303;    long QaJzOGcuYgqpUHoTCrwgNqOIh50871687 = 47498661;    long QaJzOGcuYgqpUHoTCrwgNqOIh40671307 = 91221567;    long QaJzOGcuYgqpUHoTCrwgNqOIh93296640 = -37300135;    long QaJzOGcuYgqpUHoTCrwgNqOIh20337171 = -369715109;    long QaJzOGcuYgqpUHoTCrwgNqOIh5405503 = -200892818;    long QaJzOGcuYgqpUHoTCrwgNqOIh28203116 = -212853681;    long QaJzOGcuYgqpUHoTCrwgNqOIh88657921 = -71299237;    long QaJzOGcuYgqpUHoTCrwgNqOIh47371343 = -76681837;     QaJzOGcuYgqpUHoTCrwgNqOIh64179095 = QaJzOGcuYgqpUHoTCrwgNqOIh55539802;     QaJzOGcuYgqpUHoTCrwgNqOIh55539802 = QaJzOGcuYgqpUHoTCrwgNqOIh41790461;     QaJzOGcuYgqpUHoTCrwgNqOIh41790461 = QaJzOGcuYgqpUHoTCrwgNqOIh51318754;     QaJzOGcuYgqpUHoTCrwgNqOIh51318754 = QaJzOGcuYgqpUHoTCrwgNqOIh33138427;     QaJzOGcuYgqpUHoTCrwgNqOIh33138427 = QaJzOGcuYgqpUHoTCrwgNqOIh84497568;     QaJzOGcuYgqpUHoTCrwgNqOIh84497568 = QaJzOGcuYgqpUHoTCrwgNqOIh53844466;     QaJzOGcuYgqpUHoTCrwgNqOIh53844466 = QaJzOGcuYgqpUHoTCrwgNqOIh31622530;     QaJzOGcuYgqpUHoTCrwgNqOIh31622530 = QaJzOGcuYgqpUHoTCrwgNqOIh23993335;     QaJzOGcuYgqpUHoTCrwgNqOIh23993335 = QaJzOGcuYgqpUHoTCrwgNqOIh7178676;     QaJzOGcuYgqpUHoTCrwgNqOIh7178676 = QaJzOGcuYgqpUHoTCrwgNqOIh1766545;     QaJzOGcuYgqpUHoTCrwgNqOIh1766545 = QaJzOGcuYgqpUHoTCrwgNqOIh39859838;     QaJzOGcuYgqpUHoTCrwgNqOIh39859838 = QaJzOGcuYgqpUHoTCrwgNqOIh82183772;     QaJzOGcuYgqpUHoTCrwgNqOIh82183772 = QaJzOGcuYgqpUHoTCrwgNqOIh70742746;     QaJzOGcuYgqpUHoTCrwgNqOIh70742746 = QaJzOGcuYgqpUHoTCrwgNqOIh35000171;     QaJzOGcuYgqpUHoTCrwgNqOIh35000171 = QaJzOGcuYgqpUHoTCrwgNqOIh60637415;     QaJzOGcuYgqpUHoTCrwgNqOIh60637415 = QaJzOGcuYgqpUHoTCrwgNqOIh74495250;     QaJzOGcuYgqpUHoTCrwgNqOIh74495250 = QaJzOGcuYgqpUHoTCrwgNqOIh75567528;     QaJzOGcuYgqpUHoTCrwgNqOIh75567528 = QaJzOGcuYgqpUHoTCrwgNqOIh48671288;     QaJzOGcuYgqpUHoTCrwgNqOIh48671288 = QaJzOGcuYgqpUHoTCrwgNqOIh50289539;     QaJzOGcuYgqpUHoTCrwgNqOIh50289539 = QaJzOGcuYgqpUHoTCrwgNqOIh93845407;     QaJzOGcuYgqpUHoTCrwgNqOIh93845407 = QaJzOGcuYgqpUHoTCrwgNqOIh67169564;     QaJzOGcuYgqpUHoTCrwgNqOIh67169564 = QaJzOGcuYgqpUHoTCrwgNqOIh71177329;     QaJzOGcuYgqpUHoTCrwgNqOIh71177329 = QaJzOGcuYgqpUHoTCrwgNqOIh65378297;     QaJzOGcuYgqpUHoTCrwgNqOIh65378297 = QaJzOGcuYgqpUHoTCrwgNqOIh82621776;     QaJzOGcuYgqpUHoTCrwgNqOIh82621776 = QaJzOGcuYgqpUHoTCrwgNqOIh27434494;     QaJzOGcuYgqpUHoTCrwgNqOIh27434494 = QaJzOGcuYgqpUHoTCrwgNqOIh41811911;     QaJzOGcuYgqpUHoTCrwgNqOIh41811911 = QaJzOGcuYgqpUHoTCrwgNqOIh36849728;     QaJzOGcuYgqpUHoTCrwgNqOIh36849728 = QaJzOGcuYgqpUHoTCrwgNqOIh31832731;     QaJzOGcuYgqpUHoTCrwgNqOIh31832731 = QaJzOGcuYgqpUHoTCrwgNqOIh25182355;     QaJzOGcuYgqpUHoTCrwgNqOIh25182355 = QaJzOGcuYgqpUHoTCrwgNqOIh17879040;     QaJzOGcuYgqpUHoTCrwgNqOIh17879040 = QaJzOGcuYgqpUHoTCrwgNqOIh79851040;     QaJzOGcuYgqpUHoTCrwgNqOIh79851040 = QaJzOGcuYgqpUHoTCrwgNqOIh74406467;     QaJzOGcuYgqpUHoTCrwgNqOIh74406467 = QaJzOGcuYgqpUHoTCrwgNqOIh74109027;     QaJzOGcuYgqpUHoTCrwgNqOIh74109027 = QaJzOGcuYgqpUHoTCrwgNqOIh64072573;     QaJzOGcuYgqpUHoTCrwgNqOIh64072573 = QaJzOGcuYgqpUHoTCrwgNqOIh29694738;     QaJzOGcuYgqpUHoTCrwgNqOIh29694738 = QaJzOGcuYgqpUHoTCrwgNqOIh72850736;     QaJzOGcuYgqpUHoTCrwgNqOIh72850736 = QaJzOGcuYgqpUHoTCrwgNqOIh19568665;     QaJzOGcuYgqpUHoTCrwgNqOIh19568665 = QaJzOGcuYgqpUHoTCrwgNqOIh46375239;     QaJzOGcuYgqpUHoTCrwgNqOIh46375239 = QaJzOGcuYgqpUHoTCrwgNqOIh35982298;     QaJzOGcuYgqpUHoTCrwgNqOIh35982298 = QaJzOGcuYgqpUHoTCrwgNqOIh37331909;     QaJzOGcuYgqpUHoTCrwgNqOIh37331909 = QaJzOGcuYgqpUHoTCrwgNqOIh5195302;     QaJzOGcuYgqpUHoTCrwgNqOIh5195302 = QaJzOGcuYgqpUHoTCrwgNqOIh27014097;     QaJzOGcuYgqpUHoTCrwgNqOIh27014097 = QaJzOGcuYgqpUHoTCrwgNqOIh77957556;     QaJzOGcuYgqpUHoTCrwgNqOIh77957556 = QaJzOGcuYgqpUHoTCrwgNqOIh69286846;     QaJzOGcuYgqpUHoTCrwgNqOIh69286846 = QaJzOGcuYgqpUHoTCrwgNqOIh49391385;     QaJzOGcuYgqpUHoTCrwgNqOIh49391385 = QaJzOGcuYgqpUHoTCrwgNqOIh33175999;     QaJzOGcuYgqpUHoTCrwgNqOIh33175999 = QaJzOGcuYgqpUHoTCrwgNqOIh90525654;     QaJzOGcuYgqpUHoTCrwgNqOIh90525654 = QaJzOGcuYgqpUHoTCrwgNqOIh4068871;     QaJzOGcuYgqpUHoTCrwgNqOIh4068871 = QaJzOGcuYgqpUHoTCrwgNqOIh99850745;     QaJzOGcuYgqpUHoTCrwgNqOIh99850745 = QaJzOGcuYgqpUHoTCrwgNqOIh83857418;     QaJzOGcuYgqpUHoTCrwgNqOIh83857418 = QaJzOGcuYgqpUHoTCrwgNqOIh35828658;     QaJzOGcuYgqpUHoTCrwgNqOIh35828658 = QaJzOGcuYgqpUHoTCrwgNqOIh83991754;     QaJzOGcuYgqpUHoTCrwgNqOIh83991754 = QaJzOGcuYgqpUHoTCrwgNqOIh40461143;     QaJzOGcuYgqpUHoTCrwgNqOIh40461143 = QaJzOGcuYgqpUHoTCrwgNqOIh83408834;     QaJzOGcuYgqpUHoTCrwgNqOIh83408834 = QaJzOGcuYgqpUHoTCrwgNqOIh97009530;     QaJzOGcuYgqpUHoTCrwgNqOIh97009530 = QaJzOGcuYgqpUHoTCrwgNqOIh84362473;     QaJzOGcuYgqpUHoTCrwgNqOIh84362473 = QaJzOGcuYgqpUHoTCrwgNqOIh76412164;     QaJzOGcuYgqpUHoTCrwgNqOIh76412164 = QaJzOGcuYgqpUHoTCrwgNqOIh68696978;     QaJzOGcuYgqpUHoTCrwgNqOIh68696978 = QaJzOGcuYgqpUHoTCrwgNqOIh5703933;     QaJzOGcuYgqpUHoTCrwgNqOIh5703933 = QaJzOGcuYgqpUHoTCrwgNqOIh42685657;     QaJzOGcuYgqpUHoTCrwgNqOIh42685657 = QaJzOGcuYgqpUHoTCrwgNqOIh16994739;     QaJzOGcuYgqpUHoTCrwgNqOIh16994739 = QaJzOGcuYgqpUHoTCrwgNqOIh99789799;     QaJzOGcuYgqpUHoTCrwgNqOIh99789799 = QaJzOGcuYgqpUHoTCrwgNqOIh98810980;     QaJzOGcuYgqpUHoTCrwgNqOIh98810980 = QaJzOGcuYgqpUHoTCrwgNqOIh89299635;     QaJzOGcuYgqpUHoTCrwgNqOIh89299635 = QaJzOGcuYgqpUHoTCrwgNqOIh21915504;     QaJzOGcuYgqpUHoTCrwgNqOIh21915504 = QaJzOGcuYgqpUHoTCrwgNqOIh65453370;     QaJzOGcuYgqpUHoTCrwgNqOIh65453370 = QaJzOGcuYgqpUHoTCrwgNqOIh8074746;     QaJzOGcuYgqpUHoTCrwgNqOIh8074746 = QaJzOGcuYgqpUHoTCrwgNqOIh6670174;     QaJzOGcuYgqpUHoTCrwgNqOIh6670174 = QaJzOGcuYgqpUHoTCrwgNqOIh5305434;     QaJzOGcuYgqpUHoTCrwgNqOIh5305434 = QaJzOGcuYgqpUHoTCrwgNqOIh87786679;     QaJzOGcuYgqpUHoTCrwgNqOIh87786679 = QaJzOGcuYgqpUHoTCrwgNqOIh54926586;     QaJzOGcuYgqpUHoTCrwgNqOIh54926586 = QaJzOGcuYgqpUHoTCrwgNqOIh29192289;     QaJzOGcuYgqpUHoTCrwgNqOIh29192289 = QaJzOGcuYgqpUHoTCrwgNqOIh12688990;     QaJzOGcuYgqpUHoTCrwgNqOIh12688990 = QaJzOGcuYgqpUHoTCrwgNqOIh12957630;     QaJzOGcuYgqpUHoTCrwgNqOIh12957630 = QaJzOGcuYgqpUHoTCrwgNqOIh88650106;     QaJzOGcuYgqpUHoTCrwgNqOIh88650106 = QaJzOGcuYgqpUHoTCrwgNqOIh40155468;     QaJzOGcuYgqpUHoTCrwgNqOIh40155468 = QaJzOGcuYgqpUHoTCrwgNqOIh93219772;     QaJzOGcuYgqpUHoTCrwgNqOIh93219772 = QaJzOGcuYgqpUHoTCrwgNqOIh96091450;     QaJzOGcuYgqpUHoTCrwgNqOIh96091450 = QaJzOGcuYgqpUHoTCrwgNqOIh33230391;     QaJzOGcuYgqpUHoTCrwgNqOIh33230391 = QaJzOGcuYgqpUHoTCrwgNqOIh94258495;     QaJzOGcuYgqpUHoTCrwgNqOIh94258495 = QaJzOGcuYgqpUHoTCrwgNqOIh51286257;     QaJzOGcuYgqpUHoTCrwgNqOIh51286257 = QaJzOGcuYgqpUHoTCrwgNqOIh32780857;     QaJzOGcuYgqpUHoTCrwgNqOIh32780857 = QaJzOGcuYgqpUHoTCrwgNqOIh31981985;     QaJzOGcuYgqpUHoTCrwgNqOIh31981985 = QaJzOGcuYgqpUHoTCrwgNqOIh41324936;     QaJzOGcuYgqpUHoTCrwgNqOIh41324936 = QaJzOGcuYgqpUHoTCrwgNqOIh82050382;     QaJzOGcuYgqpUHoTCrwgNqOIh82050382 = QaJzOGcuYgqpUHoTCrwgNqOIh95859286;     QaJzOGcuYgqpUHoTCrwgNqOIh95859286 = QaJzOGcuYgqpUHoTCrwgNqOIh33945324;     QaJzOGcuYgqpUHoTCrwgNqOIh33945324 = QaJzOGcuYgqpUHoTCrwgNqOIh90700192;     QaJzOGcuYgqpUHoTCrwgNqOIh90700192 = QaJzOGcuYgqpUHoTCrwgNqOIh67063042;     QaJzOGcuYgqpUHoTCrwgNqOIh67063042 = QaJzOGcuYgqpUHoTCrwgNqOIh45332265;     QaJzOGcuYgqpUHoTCrwgNqOIh45332265 = QaJzOGcuYgqpUHoTCrwgNqOIh96438572;     QaJzOGcuYgqpUHoTCrwgNqOIh96438572 = QaJzOGcuYgqpUHoTCrwgNqOIh50871687;     QaJzOGcuYgqpUHoTCrwgNqOIh50871687 = QaJzOGcuYgqpUHoTCrwgNqOIh40671307;     QaJzOGcuYgqpUHoTCrwgNqOIh40671307 = QaJzOGcuYgqpUHoTCrwgNqOIh93296640;     QaJzOGcuYgqpUHoTCrwgNqOIh93296640 = QaJzOGcuYgqpUHoTCrwgNqOIh20337171;     QaJzOGcuYgqpUHoTCrwgNqOIh20337171 = QaJzOGcuYgqpUHoTCrwgNqOIh5405503;     QaJzOGcuYgqpUHoTCrwgNqOIh5405503 = QaJzOGcuYgqpUHoTCrwgNqOIh28203116;     QaJzOGcuYgqpUHoTCrwgNqOIh28203116 = QaJzOGcuYgqpUHoTCrwgNqOIh88657921;     QaJzOGcuYgqpUHoTCrwgNqOIh88657921 = QaJzOGcuYgqpUHoTCrwgNqOIh47371343;     QaJzOGcuYgqpUHoTCrwgNqOIh47371343 = QaJzOGcuYgqpUHoTCrwgNqOIh64179095;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void lnnaTlzvEBzIluyYNDZbkiotdcFdDITjLowEcmtUEVZOJhnsyNtbBDvCz44545842() {     long twqfVsvhQwxxtwbKEXPJZkvpN99638063 = -542958737;    long twqfVsvhQwxxtwbKEXPJZkvpN68811880 = -604437818;    long twqfVsvhQwxxtwbKEXPJZkvpN79176938 = -843256788;    long twqfVsvhQwxxtwbKEXPJZkvpN23542109 = -834753261;    long twqfVsvhQwxxtwbKEXPJZkvpN89423695 = -972894121;    long twqfVsvhQwxxtwbKEXPJZkvpN20720441 = -944108736;    long twqfVsvhQwxxtwbKEXPJZkvpN64501872 = -771725676;    long twqfVsvhQwxxtwbKEXPJZkvpN93754090 = -959903735;    long twqfVsvhQwxxtwbKEXPJZkvpN25510940 = -85792760;    long twqfVsvhQwxxtwbKEXPJZkvpN22081388 = -722340995;    long twqfVsvhQwxxtwbKEXPJZkvpN39948279 = -176613040;    long twqfVsvhQwxxtwbKEXPJZkvpN40427986 = -961551061;    long twqfVsvhQwxxtwbKEXPJZkvpN20418418 = -668484654;    long twqfVsvhQwxxtwbKEXPJZkvpN23883610 = -586230945;    long twqfVsvhQwxxtwbKEXPJZkvpN93194687 = -277525205;    long twqfVsvhQwxxtwbKEXPJZkvpN44178716 = -730418206;    long twqfVsvhQwxxtwbKEXPJZkvpN30331187 = -600621859;    long twqfVsvhQwxxtwbKEXPJZkvpN75327719 = -327542118;    long twqfVsvhQwxxtwbKEXPJZkvpN49221618 = -684216937;    long twqfVsvhQwxxtwbKEXPJZkvpN44126757 = -246819281;    long twqfVsvhQwxxtwbKEXPJZkvpN6932271 = -370656303;    long twqfVsvhQwxxtwbKEXPJZkvpN70591089 = -740047783;    long twqfVsvhQwxxtwbKEXPJZkvpN41702709 = -446512109;    long twqfVsvhQwxxtwbKEXPJZkvpN59171242 = 24853840;    long twqfVsvhQwxxtwbKEXPJZkvpN90639727 = -364280345;    long twqfVsvhQwxxtwbKEXPJZkvpN38132666 = -783747627;    long twqfVsvhQwxxtwbKEXPJZkvpN2232486 = -761680252;    long twqfVsvhQwxxtwbKEXPJZkvpN77578152 = -196041369;    long twqfVsvhQwxxtwbKEXPJZkvpN78500945 = -260778962;    long twqfVsvhQwxxtwbKEXPJZkvpN30715766 = -15682121;    long twqfVsvhQwxxtwbKEXPJZkvpN36462272 = -636289838;    long twqfVsvhQwxxtwbKEXPJZkvpN17674059 = -641495546;    long twqfVsvhQwxxtwbKEXPJZkvpN86624477 = 2584382;    long twqfVsvhQwxxtwbKEXPJZkvpN3857454 = -528772634;    long twqfVsvhQwxxtwbKEXPJZkvpN29881027 = -408884119;    long twqfVsvhQwxxtwbKEXPJZkvpN81255581 = -453835648;    long twqfVsvhQwxxtwbKEXPJZkvpN22262553 = -122957501;    long twqfVsvhQwxxtwbKEXPJZkvpN70784068 = -608463963;    long twqfVsvhQwxxtwbKEXPJZkvpN76765800 = -431779164;    long twqfVsvhQwxxtwbKEXPJZkvpN253831 = -328927410;    long twqfVsvhQwxxtwbKEXPJZkvpN70783517 = 60355229;    long twqfVsvhQwxxtwbKEXPJZkvpN94560428 = -324423544;    long twqfVsvhQwxxtwbKEXPJZkvpN16397475 = -482320870;    long twqfVsvhQwxxtwbKEXPJZkvpN18088895 = -548976293;    long twqfVsvhQwxxtwbKEXPJZkvpN69303305 = -714212386;    long twqfVsvhQwxxtwbKEXPJZkvpN95352713 = -442838434;    long twqfVsvhQwxxtwbKEXPJZkvpN52521163 = -206689919;    long twqfVsvhQwxxtwbKEXPJZkvpN8251967 = -997070504;    long twqfVsvhQwxxtwbKEXPJZkvpN26961537 = -342252320;    long twqfVsvhQwxxtwbKEXPJZkvpN24380335 = -370157171;    long twqfVsvhQwxxtwbKEXPJZkvpN64628142 = -476920376;    long twqfVsvhQwxxtwbKEXPJZkvpN19314131 = -800077775;    long twqfVsvhQwxxtwbKEXPJZkvpN52612903 = 21842239;    long twqfVsvhQwxxtwbKEXPJZkvpN56452990 = -296013151;    long twqfVsvhQwxxtwbKEXPJZkvpN37613571 = -12023758;    long twqfVsvhQwxxtwbKEXPJZkvpN29046975 = -802910954;    long twqfVsvhQwxxtwbKEXPJZkvpN27109172 = -57925710;    long twqfVsvhQwxxtwbKEXPJZkvpN20005696 = -768110629;    long twqfVsvhQwxxtwbKEXPJZkvpN32902382 = -370472917;    long twqfVsvhQwxxtwbKEXPJZkvpN51291030 = -89146494;    long twqfVsvhQwxxtwbKEXPJZkvpN18487955 = -82428485;    long twqfVsvhQwxxtwbKEXPJZkvpN86923720 = -475684308;    long twqfVsvhQwxxtwbKEXPJZkvpN15253146 = -599124774;    long twqfVsvhQwxxtwbKEXPJZkvpN94795174 = 29889360;    long twqfVsvhQwxxtwbKEXPJZkvpN85619115 = 13948843;    long twqfVsvhQwxxtwbKEXPJZkvpN22274220 = -535117494;    long twqfVsvhQwxxtwbKEXPJZkvpN53803508 = -864135443;    long twqfVsvhQwxxtwbKEXPJZkvpN16560964 = -39712021;    long twqfVsvhQwxxtwbKEXPJZkvpN94002583 = -77346826;    long twqfVsvhQwxxtwbKEXPJZkvpN11939106 = -823689557;    long twqfVsvhQwxxtwbKEXPJZkvpN21916164 = -507460706;    long twqfVsvhQwxxtwbKEXPJZkvpN59547118 = -992157896;    long twqfVsvhQwxxtwbKEXPJZkvpN98561918 = -895762954;    long twqfVsvhQwxxtwbKEXPJZkvpN48967788 = -255289528;    long twqfVsvhQwxxtwbKEXPJZkvpN73343240 = -207174511;    long twqfVsvhQwxxtwbKEXPJZkvpN12371843 = 53767241;    long twqfVsvhQwxxtwbKEXPJZkvpN54193614 = -157726914;    long twqfVsvhQwxxtwbKEXPJZkvpN23613814 = -897535816;    long twqfVsvhQwxxtwbKEXPJZkvpN89867937 = -260933774;    long twqfVsvhQwxxtwbKEXPJZkvpN95287013 = -921441911;    long twqfVsvhQwxxtwbKEXPJZkvpN85611503 = -477057708;    long twqfVsvhQwxxtwbKEXPJZkvpN93980519 = -764609748;    long twqfVsvhQwxxtwbKEXPJZkvpN50616616 = -853789049;    long twqfVsvhQwxxtwbKEXPJZkvpN54120611 = -890621792;    long twqfVsvhQwxxtwbKEXPJZkvpN66087623 = -538761745;    long twqfVsvhQwxxtwbKEXPJZkvpN17148142 = -836212064;    long twqfVsvhQwxxtwbKEXPJZkvpN65061156 = -563337786;    long twqfVsvhQwxxtwbKEXPJZkvpN30171488 = -701402468;    long twqfVsvhQwxxtwbKEXPJZkvpN66243883 = -416748876;    long twqfVsvhQwxxtwbKEXPJZkvpN834053 = -605973166;    long twqfVsvhQwxxtwbKEXPJZkvpN54146410 = -295909939;    long twqfVsvhQwxxtwbKEXPJZkvpN2256858 = -354846873;    long twqfVsvhQwxxtwbKEXPJZkvpN37881687 = -137991047;    long twqfVsvhQwxxtwbKEXPJZkvpN25474771 = -242632670;    long twqfVsvhQwxxtwbKEXPJZkvpN81765875 = -146498926;    long twqfVsvhQwxxtwbKEXPJZkvpN83859797 = -463960463;    long twqfVsvhQwxxtwbKEXPJZkvpN79307282 = -725298771;    long twqfVsvhQwxxtwbKEXPJZkvpN21602301 = -412210231;    long twqfVsvhQwxxtwbKEXPJZkvpN32469779 = -462925136;    long twqfVsvhQwxxtwbKEXPJZkvpN47029085 = -542958737;     twqfVsvhQwxxtwbKEXPJZkvpN99638063 = twqfVsvhQwxxtwbKEXPJZkvpN68811880;     twqfVsvhQwxxtwbKEXPJZkvpN68811880 = twqfVsvhQwxxtwbKEXPJZkvpN79176938;     twqfVsvhQwxxtwbKEXPJZkvpN79176938 = twqfVsvhQwxxtwbKEXPJZkvpN23542109;     twqfVsvhQwxxtwbKEXPJZkvpN23542109 = twqfVsvhQwxxtwbKEXPJZkvpN89423695;     twqfVsvhQwxxtwbKEXPJZkvpN89423695 = twqfVsvhQwxxtwbKEXPJZkvpN20720441;     twqfVsvhQwxxtwbKEXPJZkvpN20720441 = twqfVsvhQwxxtwbKEXPJZkvpN64501872;     twqfVsvhQwxxtwbKEXPJZkvpN64501872 = twqfVsvhQwxxtwbKEXPJZkvpN93754090;     twqfVsvhQwxxtwbKEXPJZkvpN93754090 = twqfVsvhQwxxtwbKEXPJZkvpN25510940;     twqfVsvhQwxxtwbKEXPJZkvpN25510940 = twqfVsvhQwxxtwbKEXPJZkvpN22081388;     twqfVsvhQwxxtwbKEXPJZkvpN22081388 = twqfVsvhQwxxtwbKEXPJZkvpN39948279;     twqfVsvhQwxxtwbKEXPJZkvpN39948279 = twqfVsvhQwxxtwbKEXPJZkvpN40427986;     twqfVsvhQwxxtwbKEXPJZkvpN40427986 = twqfVsvhQwxxtwbKEXPJZkvpN20418418;     twqfVsvhQwxxtwbKEXPJZkvpN20418418 = twqfVsvhQwxxtwbKEXPJZkvpN23883610;     twqfVsvhQwxxtwbKEXPJZkvpN23883610 = twqfVsvhQwxxtwbKEXPJZkvpN93194687;     twqfVsvhQwxxtwbKEXPJZkvpN93194687 = twqfVsvhQwxxtwbKEXPJZkvpN44178716;     twqfVsvhQwxxtwbKEXPJZkvpN44178716 = twqfVsvhQwxxtwbKEXPJZkvpN30331187;     twqfVsvhQwxxtwbKEXPJZkvpN30331187 = twqfVsvhQwxxtwbKEXPJZkvpN75327719;     twqfVsvhQwxxtwbKEXPJZkvpN75327719 = twqfVsvhQwxxtwbKEXPJZkvpN49221618;     twqfVsvhQwxxtwbKEXPJZkvpN49221618 = twqfVsvhQwxxtwbKEXPJZkvpN44126757;     twqfVsvhQwxxtwbKEXPJZkvpN44126757 = twqfVsvhQwxxtwbKEXPJZkvpN6932271;     twqfVsvhQwxxtwbKEXPJZkvpN6932271 = twqfVsvhQwxxtwbKEXPJZkvpN70591089;     twqfVsvhQwxxtwbKEXPJZkvpN70591089 = twqfVsvhQwxxtwbKEXPJZkvpN41702709;     twqfVsvhQwxxtwbKEXPJZkvpN41702709 = twqfVsvhQwxxtwbKEXPJZkvpN59171242;     twqfVsvhQwxxtwbKEXPJZkvpN59171242 = twqfVsvhQwxxtwbKEXPJZkvpN90639727;     twqfVsvhQwxxtwbKEXPJZkvpN90639727 = twqfVsvhQwxxtwbKEXPJZkvpN38132666;     twqfVsvhQwxxtwbKEXPJZkvpN38132666 = twqfVsvhQwxxtwbKEXPJZkvpN2232486;     twqfVsvhQwxxtwbKEXPJZkvpN2232486 = twqfVsvhQwxxtwbKEXPJZkvpN77578152;     twqfVsvhQwxxtwbKEXPJZkvpN77578152 = twqfVsvhQwxxtwbKEXPJZkvpN78500945;     twqfVsvhQwxxtwbKEXPJZkvpN78500945 = twqfVsvhQwxxtwbKEXPJZkvpN30715766;     twqfVsvhQwxxtwbKEXPJZkvpN30715766 = twqfVsvhQwxxtwbKEXPJZkvpN36462272;     twqfVsvhQwxxtwbKEXPJZkvpN36462272 = twqfVsvhQwxxtwbKEXPJZkvpN17674059;     twqfVsvhQwxxtwbKEXPJZkvpN17674059 = twqfVsvhQwxxtwbKEXPJZkvpN86624477;     twqfVsvhQwxxtwbKEXPJZkvpN86624477 = twqfVsvhQwxxtwbKEXPJZkvpN3857454;     twqfVsvhQwxxtwbKEXPJZkvpN3857454 = twqfVsvhQwxxtwbKEXPJZkvpN29881027;     twqfVsvhQwxxtwbKEXPJZkvpN29881027 = twqfVsvhQwxxtwbKEXPJZkvpN81255581;     twqfVsvhQwxxtwbKEXPJZkvpN81255581 = twqfVsvhQwxxtwbKEXPJZkvpN22262553;     twqfVsvhQwxxtwbKEXPJZkvpN22262553 = twqfVsvhQwxxtwbKEXPJZkvpN70784068;     twqfVsvhQwxxtwbKEXPJZkvpN70784068 = twqfVsvhQwxxtwbKEXPJZkvpN76765800;     twqfVsvhQwxxtwbKEXPJZkvpN76765800 = twqfVsvhQwxxtwbKEXPJZkvpN253831;     twqfVsvhQwxxtwbKEXPJZkvpN253831 = twqfVsvhQwxxtwbKEXPJZkvpN70783517;     twqfVsvhQwxxtwbKEXPJZkvpN70783517 = twqfVsvhQwxxtwbKEXPJZkvpN94560428;     twqfVsvhQwxxtwbKEXPJZkvpN94560428 = twqfVsvhQwxxtwbKEXPJZkvpN16397475;     twqfVsvhQwxxtwbKEXPJZkvpN16397475 = twqfVsvhQwxxtwbKEXPJZkvpN18088895;     twqfVsvhQwxxtwbKEXPJZkvpN18088895 = twqfVsvhQwxxtwbKEXPJZkvpN69303305;     twqfVsvhQwxxtwbKEXPJZkvpN69303305 = twqfVsvhQwxxtwbKEXPJZkvpN95352713;     twqfVsvhQwxxtwbKEXPJZkvpN95352713 = twqfVsvhQwxxtwbKEXPJZkvpN52521163;     twqfVsvhQwxxtwbKEXPJZkvpN52521163 = twqfVsvhQwxxtwbKEXPJZkvpN8251967;     twqfVsvhQwxxtwbKEXPJZkvpN8251967 = twqfVsvhQwxxtwbKEXPJZkvpN26961537;     twqfVsvhQwxxtwbKEXPJZkvpN26961537 = twqfVsvhQwxxtwbKEXPJZkvpN24380335;     twqfVsvhQwxxtwbKEXPJZkvpN24380335 = twqfVsvhQwxxtwbKEXPJZkvpN64628142;     twqfVsvhQwxxtwbKEXPJZkvpN64628142 = twqfVsvhQwxxtwbKEXPJZkvpN19314131;     twqfVsvhQwxxtwbKEXPJZkvpN19314131 = twqfVsvhQwxxtwbKEXPJZkvpN52612903;     twqfVsvhQwxxtwbKEXPJZkvpN52612903 = twqfVsvhQwxxtwbKEXPJZkvpN56452990;     twqfVsvhQwxxtwbKEXPJZkvpN56452990 = twqfVsvhQwxxtwbKEXPJZkvpN37613571;     twqfVsvhQwxxtwbKEXPJZkvpN37613571 = twqfVsvhQwxxtwbKEXPJZkvpN29046975;     twqfVsvhQwxxtwbKEXPJZkvpN29046975 = twqfVsvhQwxxtwbKEXPJZkvpN27109172;     twqfVsvhQwxxtwbKEXPJZkvpN27109172 = twqfVsvhQwxxtwbKEXPJZkvpN20005696;     twqfVsvhQwxxtwbKEXPJZkvpN20005696 = twqfVsvhQwxxtwbKEXPJZkvpN32902382;     twqfVsvhQwxxtwbKEXPJZkvpN32902382 = twqfVsvhQwxxtwbKEXPJZkvpN51291030;     twqfVsvhQwxxtwbKEXPJZkvpN51291030 = twqfVsvhQwxxtwbKEXPJZkvpN18487955;     twqfVsvhQwxxtwbKEXPJZkvpN18487955 = twqfVsvhQwxxtwbKEXPJZkvpN86923720;     twqfVsvhQwxxtwbKEXPJZkvpN86923720 = twqfVsvhQwxxtwbKEXPJZkvpN15253146;     twqfVsvhQwxxtwbKEXPJZkvpN15253146 = twqfVsvhQwxxtwbKEXPJZkvpN94795174;     twqfVsvhQwxxtwbKEXPJZkvpN94795174 = twqfVsvhQwxxtwbKEXPJZkvpN85619115;     twqfVsvhQwxxtwbKEXPJZkvpN85619115 = twqfVsvhQwxxtwbKEXPJZkvpN22274220;     twqfVsvhQwxxtwbKEXPJZkvpN22274220 = twqfVsvhQwxxtwbKEXPJZkvpN53803508;     twqfVsvhQwxxtwbKEXPJZkvpN53803508 = twqfVsvhQwxxtwbKEXPJZkvpN16560964;     twqfVsvhQwxxtwbKEXPJZkvpN16560964 = twqfVsvhQwxxtwbKEXPJZkvpN94002583;     twqfVsvhQwxxtwbKEXPJZkvpN94002583 = twqfVsvhQwxxtwbKEXPJZkvpN11939106;     twqfVsvhQwxxtwbKEXPJZkvpN11939106 = twqfVsvhQwxxtwbKEXPJZkvpN21916164;     twqfVsvhQwxxtwbKEXPJZkvpN21916164 = twqfVsvhQwxxtwbKEXPJZkvpN59547118;     twqfVsvhQwxxtwbKEXPJZkvpN59547118 = twqfVsvhQwxxtwbKEXPJZkvpN98561918;     twqfVsvhQwxxtwbKEXPJZkvpN98561918 = twqfVsvhQwxxtwbKEXPJZkvpN48967788;     twqfVsvhQwxxtwbKEXPJZkvpN48967788 = twqfVsvhQwxxtwbKEXPJZkvpN73343240;     twqfVsvhQwxxtwbKEXPJZkvpN73343240 = twqfVsvhQwxxtwbKEXPJZkvpN12371843;     twqfVsvhQwxxtwbKEXPJZkvpN12371843 = twqfVsvhQwxxtwbKEXPJZkvpN54193614;     twqfVsvhQwxxtwbKEXPJZkvpN54193614 = twqfVsvhQwxxtwbKEXPJZkvpN23613814;     twqfVsvhQwxxtwbKEXPJZkvpN23613814 = twqfVsvhQwxxtwbKEXPJZkvpN89867937;     twqfVsvhQwxxtwbKEXPJZkvpN89867937 = twqfVsvhQwxxtwbKEXPJZkvpN95287013;     twqfVsvhQwxxtwbKEXPJZkvpN95287013 = twqfVsvhQwxxtwbKEXPJZkvpN85611503;     twqfVsvhQwxxtwbKEXPJZkvpN85611503 = twqfVsvhQwxxtwbKEXPJZkvpN93980519;     twqfVsvhQwxxtwbKEXPJZkvpN93980519 = twqfVsvhQwxxtwbKEXPJZkvpN50616616;     twqfVsvhQwxxtwbKEXPJZkvpN50616616 = twqfVsvhQwxxtwbKEXPJZkvpN54120611;     twqfVsvhQwxxtwbKEXPJZkvpN54120611 = twqfVsvhQwxxtwbKEXPJZkvpN66087623;     twqfVsvhQwxxtwbKEXPJZkvpN66087623 = twqfVsvhQwxxtwbKEXPJZkvpN17148142;     twqfVsvhQwxxtwbKEXPJZkvpN17148142 = twqfVsvhQwxxtwbKEXPJZkvpN65061156;     twqfVsvhQwxxtwbKEXPJZkvpN65061156 = twqfVsvhQwxxtwbKEXPJZkvpN30171488;     twqfVsvhQwxxtwbKEXPJZkvpN30171488 = twqfVsvhQwxxtwbKEXPJZkvpN66243883;     twqfVsvhQwxxtwbKEXPJZkvpN66243883 = twqfVsvhQwxxtwbKEXPJZkvpN834053;     twqfVsvhQwxxtwbKEXPJZkvpN834053 = twqfVsvhQwxxtwbKEXPJZkvpN54146410;     twqfVsvhQwxxtwbKEXPJZkvpN54146410 = twqfVsvhQwxxtwbKEXPJZkvpN2256858;     twqfVsvhQwxxtwbKEXPJZkvpN2256858 = twqfVsvhQwxxtwbKEXPJZkvpN37881687;     twqfVsvhQwxxtwbKEXPJZkvpN37881687 = twqfVsvhQwxxtwbKEXPJZkvpN25474771;     twqfVsvhQwxxtwbKEXPJZkvpN25474771 = twqfVsvhQwxxtwbKEXPJZkvpN81765875;     twqfVsvhQwxxtwbKEXPJZkvpN81765875 = twqfVsvhQwxxtwbKEXPJZkvpN83859797;     twqfVsvhQwxxtwbKEXPJZkvpN83859797 = twqfVsvhQwxxtwbKEXPJZkvpN79307282;     twqfVsvhQwxxtwbKEXPJZkvpN79307282 = twqfVsvhQwxxtwbKEXPJZkvpN21602301;     twqfVsvhQwxxtwbKEXPJZkvpN21602301 = twqfVsvhQwxxtwbKEXPJZkvpN32469779;     twqfVsvhQwxxtwbKEXPJZkvpN32469779 = twqfVsvhQwxxtwbKEXPJZkvpN47029085;     twqfVsvhQwxxtwbKEXPJZkvpN47029085 = twqfVsvhQwxxtwbKEXPJZkvpN99638063;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void SzxvdXKodsTNiDjLsSkrLAMfMnxNynjgGAnYKvcHVHyQMImmXlHzrNzRn59594909() {     long SiqZwqqInGhQKBxqdWDCvSEAK5755171 = -654860625;    long SiqZwqqInGhQKBxqdWDCvSEAK12185160 = -314037598;    long SiqZwqqInGhQKBxqdWDCvSEAK95219121 = -994089710;    long SiqZwqqInGhQKBxqdWDCvSEAK50616890 = 74498109;    long SiqZwqqInGhQKBxqdWDCvSEAK58319184 = -393543992;    long SiqZwqqInGhQKBxqdWDCvSEAK12137643 = -108604971;    long SiqZwqqInGhQKBxqdWDCvSEAK24990839 = -910690653;    long SiqZwqqInGhQKBxqdWDCvSEAK43513982 = -146777648;    long SiqZwqqInGhQKBxqdWDCvSEAK90153435 = -953825426;    long SiqZwqqInGhQKBxqdWDCvSEAK63311047 = 48683528;    long SiqZwqqInGhQKBxqdWDCvSEAK58570 = -54050626;    long SiqZwqqInGhQKBxqdWDCvSEAK72251028 = -305957263;    long SiqZwqqInGhQKBxqdWDCvSEAK6627537 = -8375743;    long SiqZwqqInGhQKBxqdWDCvSEAK7027287 = -18469513;    long SiqZwqqInGhQKBxqdWDCvSEAK88937114 = -967987371;    long SiqZwqqInGhQKBxqdWDCvSEAK85684110 = -703417749;    long SiqZwqqInGhQKBxqdWDCvSEAK24167190 = -117166971;    long SiqZwqqInGhQKBxqdWDCvSEAK72380872 = 6935240;    long SiqZwqqInGhQKBxqdWDCvSEAK11051460 = 10013966;    long SiqZwqqInGhQKBxqdWDCvSEAK24676922 = -603722201;    long SiqZwqqInGhQKBxqdWDCvSEAK95485464 = -226143759;    long SiqZwqqInGhQKBxqdWDCvSEAK57112113 = -647977499;    long SiqZwqqInGhQKBxqdWDCvSEAK77293500 = -193029595;    long SiqZwqqInGhQKBxqdWDCvSEAK43163616 = -197451148;    long SiqZwqqInGhQKBxqdWDCvSEAK34339377 = -737476378;    long SiqZwqqInGhQKBxqdWDCvSEAK62854341 = -662402950;    long SiqZwqqInGhQKBxqdWDCvSEAK692264 = -662342455;    long SiqZwqqInGhQKBxqdWDCvSEAK90685277 = -261970322;    long SiqZwqqInGhQKBxqdWDCvSEAK44633201 = -483161666;    long SiqZwqqInGhQKBxqdWDCvSEAK99331402 = -933152988;    long SiqZwqqInGhQKBxqdWDCvSEAK28704821 = -549610776;    long SiqZwqqInGhQKBxqdWDCvSEAK15284681 = -350942362;    long SiqZwqqInGhQKBxqdWDCvSEAK96335426 = -990028988;    long SiqZwqqInGhQKBxqdWDCvSEAK98688017 = -280314399;    long SiqZwqqInGhQKBxqdWDCvSEAK91355678 = 52382775;    long SiqZwqqInGhQKBxqdWDCvSEAK49981495 = -667861756;    long SiqZwqqInGhQKBxqdWDCvSEAK3524488 = -76593371;    long SiqZwqqInGhQKBxqdWDCvSEAK4874281 = -379969973;    long SiqZwqqInGhQKBxqdWDCvSEAK50376054 = -425702661;    long SiqZwqqInGhQKBxqdWDCvSEAK87755767 = -802366633;    long SiqZwqqInGhQKBxqdWDCvSEAK76452740 = -4918665;    long SiqZwqqInGhQKBxqdWDCvSEAK26710885 = -594565823;    long SiqZwqqInGhQKBxqdWDCvSEAK94464452 = -563125454;    long SiqZwqqInGhQKBxqdWDCvSEAK5496636 = -568319231;    long SiqZwqqInGhQKBxqdWDCvSEAK81255770 = -376110541;    long SiqZwqqInGhQKBxqdWDCvSEAK7291909 = -428054550;    long SiqZwqqInGhQKBxqdWDCvSEAK70299737 = -325465457;    long SiqZwqqInGhQKBxqdWDCvSEAK16208907 = 93033963;    long SiqZwqqInGhQKBxqdWDCvSEAK36637266 = -427989308;    long SiqZwqqInGhQKBxqdWDCvSEAK37291987 = -457167979;    long SiqZwqqInGhQKBxqdWDCvSEAK328821 = -319214048;    long SiqZwqqInGhQKBxqdWDCvSEAK30123850 = -600804095;    long SiqZwqqInGhQKBxqdWDCvSEAK861360 = -869947349;    long SiqZwqqInGhQKBxqdWDCvSEAK52421870 = -616483296;    long SiqZwqqInGhQKBxqdWDCvSEAK64109445 = -712555541;    long SiqZwqqInGhQKBxqdWDCvSEAK48643057 = 93116873;    long SiqZwqqInGhQKBxqdWDCvSEAK34891660 = -21008003;    long SiqZwqqInGhQKBxqdWDCvSEAK52055505 = -696638562;    long SiqZwqqInGhQKBxqdWDCvSEAK16277513 = -188025514;    long SiqZwqqInGhQKBxqdWDCvSEAK95464843 = -731141042;    long SiqZwqqInGhQKBxqdWDCvSEAK11445380 = -446262517;    long SiqZwqqInGhQKBxqdWDCvSEAK34305561 = -548720331;    long SiqZwqqInGhQKBxqdWDCvSEAK98880780 = -663615982;    long SiqZwqqInGhQKBxqdWDCvSEAK90822033 = 79327562;    long SiqZwqqInGhQKBxqdWDCvSEAK34606226 = -401705697;    long SiqZwqqInGhQKBxqdWDCvSEAK84773888 = -703108265;    long SiqZwqqInGhQKBxqdWDCvSEAK75915602 = -315928275;    long SiqZwqqInGhQKBxqdWDCvSEAK7939519 = -728061344;    long SiqZwqqInGhQKBxqdWDCvSEAK15671608 = 29147711;    long SiqZwqqInGhQKBxqdWDCvSEAK38955619 = -200125616;    long SiqZwqqInGhQKBxqdWDCvSEAK82159623 = -526824379;    long SiqZwqqInGhQKBxqdWDCvSEAK19292909 = -737196999;    long SiqZwqqInGhQKBxqdWDCvSEAK22004818 = -567362100;    long SiqZwqqInGhQKBxqdWDCvSEAK23295692 = -187619402;    long SiqZwqqInGhQKBxqdWDCvSEAK48224181 = -498803536;    long SiqZwqqInGhQKBxqdWDCvSEAK68774579 = -631577937;    long SiqZwqqInGhQKBxqdWDCvSEAK62647660 = 15147954;    long SiqZwqqInGhQKBxqdWDCvSEAK71796865 = -624710365;    long SiqZwqqInGhQKBxqdWDCvSEAK61907846 = -821340608;    long SiqZwqqInGhQKBxqdWDCvSEAK27047468 = -209421828;    long SiqZwqqInGhQKBxqdWDCvSEAK92554604 = -236937494;    long SiqZwqqInGhQKBxqdWDCvSEAK84483356 = -655376419;    long SiqZwqqInGhQKBxqdWDCvSEAK54048012 = -833981014;    long SiqZwqqInGhQKBxqdWDCvSEAK7341214 = 74006312;    long SiqZwqqInGhQKBxqdWDCvSEAK99002581 = -513938941;    long SiqZwqqInGhQKBxqdWDCvSEAK98580971 = -948806682;    long SiqZwqqInGhQKBxqdWDCvSEAK14423321 = -480995014;    long SiqZwqqInGhQKBxqdWDCvSEAK43913557 = -273545693;    long SiqZwqqInGhQKBxqdWDCvSEAK34578573 = -567758859;    long SiqZwqqInGhQKBxqdWDCvSEAK42712621 = 59265902;    long SiqZwqqInGhQKBxqdWDCvSEAK15089836 = -546853753;    long SiqZwqqInGhQKBxqdWDCvSEAK51468982 = -379954809;    long SiqZwqqInGhQKBxqdWDCvSEAK88596768 = -91944459;    long SiqZwqqInGhQKBxqdWDCvSEAK54911211 = -694561619;    long SiqZwqqInGhQKBxqdWDCvSEAK76310388 = -256104117;    long SiqZwqqInGhQKBxqdWDCvSEAK42147180 = -456198334;    long SiqZwqqInGhQKBxqdWDCvSEAK27830104 = -930949841;    long SiqZwqqInGhQKBxqdWDCvSEAK3642420 = -542453016;    long SiqZwqqInGhQKBxqdWDCvSEAK70890409 = -66613535;    long SiqZwqqInGhQKBxqdWDCvSEAK96481881 = -654860625;     SiqZwqqInGhQKBxqdWDCvSEAK5755171 = SiqZwqqInGhQKBxqdWDCvSEAK12185160;     SiqZwqqInGhQKBxqdWDCvSEAK12185160 = SiqZwqqInGhQKBxqdWDCvSEAK95219121;     SiqZwqqInGhQKBxqdWDCvSEAK95219121 = SiqZwqqInGhQKBxqdWDCvSEAK50616890;     SiqZwqqInGhQKBxqdWDCvSEAK50616890 = SiqZwqqInGhQKBxqdWDCvSEAK58319184;     SiqZwqqInGhQKBxqdWDCvSEAK58319184 = SiqZwqqInGhQKBxqdWDCvSEAK12137643;     SiqZwqqInGhQKBxqdWDCvSEAK12137643 = SiqZwqqInGhQKBxqdWDCvSEAK24990839;     SiqZwqqInGhQKBxqdWDCvSEAK24990839 = SiqZwqqInGhQKBxqdWDCvSEAK43513982;     SiqZwqqInGhQKBxqdWDCvSEAK43513982 = SiqZwqqInGhQKBxqdWDCvSEAK90153435;     SiqZwqqInGhQKBxqdWDCvSEAK90153435 = SiqZwqqInGhQKBxqdWDCvSEAK63311047;     SiqZwqqInGhQKBxqdWDCvSEAK63311047 = SiqZwqqInGhQKBxqdWDCvSEAK58570;     SiqZwqqInGhQKBxqdWDCvSEAK58570 = SiqZwqqInGhQKBxqdWDCvSEAK72251028;     SiqZwqqInGhQKBxqdWDCvSEAK72251028 = SiqZwqqInGhQKBxqdWDCvSEAK6627537;     SiqZwqqInGhQKBxqdWDCvSEAK6627537 = SiqZwqqInGhQKBxqdWDCvSEAK7027287;     SiqZwqqInGhQKBxqdWDCvSEAK7027287 = SiqZwqqInGhQKBxqdWDCvSEAK88937114;     SiqZwqqInGhQKBxqdWDCvSEAK88937114 = SiqZwqqInGhQKBxqdWDCvSEAK85684110;     SiqZwqqInGhQKBxqdWDCvSEAK85684110 = SiqZwqqInGhQKBxqdWDCvSEAK24167190;     SiqZwqqInGhQKBxqdWDCvSEAK24167190 = SiqZwqqInGhQKBxqdWDCvSEAK72380872;     SiqZwqqInGhQKBxqdWDCvSEAK72380872 = SiqZwqqInGhQKBxqdWDCvSEAK11051460;     SiqZwqqInGhQKBxqdWDCvSEAK11051460 = SiqZwqqInGhQKBxqdWDCvSEAK24676922;     SiqZwqqInGhQKBxqdWDCvSEAK24676922 = SiqZwqqInGhQKBxqdWDCvSEAK95485464;     SiqZwqqInGhQKBxqdWDCvSEAK95485464 = SiqZwqqInGhQKBxqdWDCvSEAK57112113;     SiqZwqqInGhQKBxqdWDCvSEAK57112113 = SiqZwqqInGhQKBxqdWDCvSEAK77293500;     SiqZwqqInGhQKBxqdWDCvSEAK77293500 = SiqZwqqInGhQKBxqdWDCvSEAK43163616;     SiqZwqqInGhQKBxqdWDCvSEAK43163616 = SiqZwqqInGhQKBxqdWDCvSEAK34339377;     SiqZwqqInGhQKBxqdWDCvSEAK34339377 = SiqZwqqInGhQKBxqdWDCvSEAK62854341;     SiqZwqqInGhQKBxqdWDCvSEAK62854341 = SiqZwqqInGhQKBxqdWDCvSEAK692264;     SiqZwqqInGhQKBxqdWDCvSEAK692264 = SiqZwqqInGhQKBxqdWDCvSEAK90685277;     SiqZwqqInGhQKBxqdWDCvSEAK90685277 = SiqZwqqInGhQKBxqdWDCvSEAK44633201;     SiqZwqqInGhQKBxqdWDCvSEAK44633201 = SiqZwqqInGhQKBxqdWDCvSEAK99331402;     SiqZwqqInGhQKBxqdWDCvSEAK99331402 = SiqZwqqInGhQKBxqdWDCvSEAK28704821;     SiqZwqqInGhQKBxqdWDCvSEAK28704821 = SiqZwqqInGhQKBxqdWDCvSEAK15284681;     SiqZwqqInGhQKBxqdWDCvSEAK15284681 = SiqZwqqInGhQKBxqdWDCvSEAK96335426;     SiqZwqqInGhQKBxqdWDCvSEAK96335426 = SiqZwqqInGhQKBxqdWDCvSEAK98688017;     SiqZwqqInGhQKBxqdWDCvSEAK98688017 = SiqZwqqInGhQKBxqdWDCvSEAK91355678;     SiqZwqqInGhQKBxqdWDCvSEAK91355678 = SiqZwqqInGhQKBxqdWDCvSEAK49981495;     SiqZwqqInGhQKBxqdWDCvSEAK49981495 = SiqZwqqInGhQKBxqdWDCvSEAK3524488;     SiqZwqqInGhQKBxqdWDCvSEAK3524488 = SiqZwqqInGhQKBxqdWDCvSEAK4874281;     SiqZwqqInGhQKBxqdWDCvSEAK4874281 = SiqZwqqInGhQKBxqdWDCvSEAK50376054;     SiqZwqqInGhQKBxqdWDCvSEAK50376054 = SiqZwqqInGhQKBxqdWDCvSEAK87755767;     SiqZwqqInGhQKBxqdWDCvSEAK87755767 = SiqZwqqInGhQKBxqdWDCvSEAK76452740;     SiqZwqqInGhQKBxqdWDCvSEAK76452740 = SiqZwqqInGhQKBxqdWDCvSEAK26710885;     SiqZwqqInGhQKBxqdWDCvSEAK26710885 = SiqZwqqInGhQKBxqdWDCvSEAK94464452;     SiqZwqqInGhQKBxqdWDCvSEAK94464452 = SiqZwqqInGhQKBxqdWDCvSEAK5496636;     SiqZwqqInGhQKBxqdWDCvSEAK5496636 = SiqZwqqInGhQKBxqdWDCvSEAK81255770;     SiqZwqqInGhQKBxqdWDCvSEAK81255770 = SiqZwqqInGhQKBxqdWDCvSEAK7291909;     SiqZwqqInGhQKBxqdWDCvSEAK7291909 = SiqZwqqInGhQKBxqdWDCvSEAK70299737;     SiqZwqqInGhQKBxqdWDCvSEAK70299737 = SiqZwqqInGhQKBxqdWDCvSEAK16208907;     SiqZwqqInGhQKBxqdWDCvSEAK16208907 = SiqZwqqInGhQKBxqdWDCvSEAK36637266;     SiqZwqqInGhQKBxqdWDCvSEAK36637266 = SiqZwqqInGhQKBxqdWDCvSEAK37291987;     SiqZwqqInGhQKBxqdWDCvSEAK37291987 = SiqZwqqInGhQKBxqdWDCvSEAK328821;     SiqZwqqInGhQKBxqdWDCvSEAK328821 = SiqZwqqInGhQKBxqdWDCvSEAK30123850;     SiqZwqqInGhQKBxqdWDCvSEAK30123850 = SiqZwqqInGhQKBxqdWDCvSEAK861360;     SiqZwqqInGhQKBxqdWDCvSEAK861360 = SiqZwqqInGhQKBxqdWDCvSEAK52421870;     SiqZwqqInGhQKBxqdWDCvSEAK52421870 = SiqZwqqInGhQKBxqdWDCvSEAK64109445;     SiqZwqqInGhQKBxqdWDCvSEAK64109445 = SiqZwqqInGhQKBxqdWDCvSEAK48643057;     SiqZwqqInGhQKBxqdWDCvSEAK48643057 = SiqZwqqInGhQKBxqdWDCvSEAK34891660;     SiqZwqqInGhQKBxqdWDCvSEAK34891660 = SiqZwqqInGhQKBxqdWDCvSEAK52055505;     SiqZwqqInGhQKBxqdWDCvSEAK52055505 = SiqZwqqInGhQKBxqdWDCvSEAK16277513;     SiqZwqqInGhQKBxqdWDCvSEAK16277513 = SiqZwqqInGhQKBxqdWDCvSEAK95464843;     SiqZwqqInGhQKBxqdWDCvSEAK95464843 = SiqZwqqInGhQKBxqdWDCvSEAK11445380;     SiqZwqqInGhQKBxqdWDCvSEAK11445380 = SiqZwqqInGhQKBxqdWDCvSEAK34305561;     SiqZwqqInGhQKBxqdWDCvSEAK34305561 = SiqZwqqInGhQKBxqdWDCvSEAK98880780;     SiqZwqqInGhQKBxqdWDCvSEAK98880780 = SiqZwqqInGhQKBxqdWDCvSEAK90822033;     SiqZwqqInGhQKBxqdWDCvSEAK90822033 = SiqZwqqInGhQKBxqdWDCvSEAK34606226;     SiqZwqqInGhQKBxqdWDCvSEAK34606226 = SiqZwqqInGhQKBxqdWDCvSEAK84773888;     SiqZwqqInGhQKBxqdWDCvSEAK84773888 = SiqZwqqInGhQKBxqdWDCvSEAK75915602;     SiqZwqqInGhQKBxqdWDCvSEAK75915602 = SiqZwqqInGhQKBxqdWDCvSEAK7939519;     SiqZwqqInGhQKBxqdWDCvSEAK7939519 = SiqZwqqInGhQKBxqdWDCvSEAK15671608;     SiqZwqqInGhQKBxqdWDCvSEAK15671608 = SiqZwqqInGhQKBxqdWDCvSEAK38955619;     SiqZwqqInGhQKBxqdWDCvSEAK38955619 = SiqZwqqInGhQKBxqdWDCvSEAK82159623;     SiqZwqqInGhQKBxqdWDCvSEAK82159623 = SiqZwqqInGhQKBxqdWDCvSEAK19292909;     SiqZwqqInGhQKBxqdWDCvSEAK19292909 = SiqZwqqInGhQKBxqdWDCvSEAK22004818;     SiqZwqqInGhQKBxqdWDCvSEAK22004818 = SiqZwqqInGhQKBxqdWDCvSEAK23295692;     SiqZwqqInGhQKBxqdWDCvSEAK23295692 = SiqZwqqInGhQKBxqdWDCvSEAK48224181;     SiqZwqqInGhQKBxqdWDCvSEAK48224181 = SiqZwqqInGhQKBxqdWDCvSEAK68774579;     SiqZwqqInGhQKBxqdWDCvSEAK68774579 = SiqZwqqInGhQKBxqdWDCvSEAK62647660;     SiqZwqqInGhQKBxqdWDCvSEAK62647660 = SiqZwqqInGhQKBxqdWDCvSEAK71796865;     SiqZwqqInGhQKBxqdWDCvSEAK71796865 = SiqZwqqInGhQKBxqdWDCvSEAK61907846;     SiqZwqqInGhQKBxqdWDCvSEAK61907846 = SiqZwqqInGhQKBxqdWDCvSEAK27047468;     SiqZwqqInGhQKBxqdWDCvSEAK27047468 = SiqZwqqInGhQKBxqdWDCvSEAK92554604;     SiqZwqqInGhQKBxqdWDCvSEAK92554604 = SiqZwqqInGhQKBxqdWDCvSEAK84483356;     SiqZwqqInGhQKBxqdWDCvSEAK84483356 = SiqZwqqInGhQKBxqdWDCvSEAK54048012;     SiqZwqqInGhQKBxqdWDCvSEAK54048012 = SiqZwqqInGhQKBxqdWDCvSEAK7341214;     SiqZwqqInGhQKBxqdWDCvSEAK7341214 = SiqZwqqInGhQKBxqdWDCvSEAK99002581;     SiqZwqqInGhQKBxqdWDCvSEAK99002581 = SiqZwqqInGhQKBxqdWDCvSEAK98580971;     SiqZwqqInGhQKBxqdWDCvSEAK98580971 = SiqZwqqInGhQKBxqdWDCvSEAK14423321;     SiqZwqqInGhQKBxqdWDCvSEAK14423321 = SiqZwqqInGhQKBxqdWDCvSEAK43913557;     SiqZwqqInGhQKBxqdWDCvSEAK43913557 = SiqZwqqInGhQKBxqdWDCvSEAK34578573;     SiqZwqqInGhQKBxqdWDCvSEAK34578573 = SiqZwqqInGhQKBxqdWDCvSEAK42712621;     SiqZwqqInGhQKBxqdWDCvSEAK42712621 = SiqZwqqInGhQKBxqdWDCvSEAK15089836;     SiqZwqqInGhQKBxqdWDCvSEAK15089836 = SiqZwqqInGhQKBxqdWDCvSEAK51468982;     SiqZwqqInGhQKBxqdWDCvSEAK51468982 = SiqZwqqInGhQKBxqdWDCvSEAK88596768;     SiqZwqqInGhQKBxqdWDCvSEAK88596768 = SiqZwqqInGhQKBxqdWDCvSEAK54911211;     SiqZwqqInGhQKBxqdWDCvSEAK54911211 = SiqZwqqInGhQKBxqdWDCvSEAK76310388;     SiqZwqqInGhQKBxqdWDCvSEAK76310388 = SiqZwqqInGhQKBxqdWDCvSEAK42147180;     SiqZwqqInGhQKBxqdWDCvSEAK42147180 = SiqZwqqInGhQKBxqdWDCvSEAK27830104;     SiqZwqqInGhQKBxqdWDCvSEAK27830104 = SiqZwqqInGhQKBxqdWDCvSEAK3642420;     SiqZwqqInGhQKBxqdWDCvSEAK3642420 = SiqZwqqInGhQKBxqdWDCvSEAK70890409;     SiqZwqqInGhQKBxqdWDCvSEAK70890409 = SiqZwqqInGhQKBxqdWDCvSEAK96481881;     SiqZwqqInGhQKBxqdWDCvSEAK96481881 = SiqZwqqInGhQKBxqdWDCvSEAK5755171;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void aTCRdqFELmQTSmWJAkrZbUXRCpYwnovWfmYMEAzjFuADzEpfoLbuOxqFv26886509() {     long lOnRIQXrtngNKEAkHUgTURyAt41214139 = -21137525;    long lOnRIQXrtngNKEAkHUgTURyAt25457239 = -194589205;    long lOnRIQXrtngNKEAkHUgTURyAt32605598 = -659756785;    long lOnRIQXrtngNKEAkHUgTURyAt22840245 = -846652963;    long lOnRIQXrtngNKEAkHUgTURyAt14604454 = -499142837;    long lOnRIQXrtngNKEAkHUgTURyAt48360515 = -370952867;    long lOnRIQXrtngNKEAkHUgTURyAt35648245 = -755416387;    long lOnRIQXrtngNKEAkHUgTURyAt5645543 = -891011788;    long lOnRIQXrtngNKEAkHUgTURyAt91671040 = -342156833;    long lOnRIQXrtngNKEAkHUgTURyAt78213759 = -716003470;    long lOnRIQXrtngNKEAkHUgTURyAt38240304 = -956058355;    long lOnRIQXrtngNKEAkHUgTURyAt72819177 = -170078034;    long lOnRIQXrtngNKEAkHUgTURyAt44862182 = -560388248;    long lOnRIQXrtngNKEAkHUgTURyAt60168150 = 5167078;    long lOnRIQXrtngNKEAkHUgTURyAt47131630 = -371412386;    long lOnRIQXrtngNKEAkHUgTURyAt69225411 = -339229357;    long lOnRIQXrtngNKEAkHUgTURyAt80003125 = -644141524;    long lOnRIQXrtngNKEAkHUgTURyAt72141064 = -66492829;    long lOnRIQXrtngNKEAkHUgTURyAt11601790 = -306549455;    long lOnRIQXrtngNKEAkHUgTURyAt18514141 = 69716734;    long lOnRIQXrtngNKEAkHUgTURyAt8572327 = -983418448;    long lOnRIQXrtngNKEAkHUgTURyAt60533637 = -734613793;    long lOnRIQXrtngNKEAkHUgTURyAt47818880 = -930661780;    long lOnRIQXrtngNKEAkHUgTURyAt36956561 = -708275752;    long lOnRIQXrtngNKEAkHUgTURyAt42357328 = -761461576;    long lOnRIQXrtngNKEAkHUgTURyAt73552513 = -350979757;    long lOnRIQXrtngNKEAkHUgTURyAt61112837 = -468626596;    long lOnRIQXrtngNKEAkHUgTURyAt31413703 = -431742497;    long lOnRIQXrtngNKEAkHUgTURyAt91301415 = 42743531;    long lOnRIQXrtngNKEAkHUgTURyAt4864813 = -967660159;    long lOnRIQXrtngNKEAkHUgTURyAt47288053 = -1591263;    long lOnRIQXrtngNKEAkHUgTURyAt53107699 = -123913776;    long lOnRIQXrtngNKEAkHUgTURyAt8553438 = -37624966;    long lOnRIQXrtngNKEAkHUgTURyAt28436445 = -345008212;    long lOnRIQXrtngNKEAkHUgTURyAt57164132 = -998717475;    long lOnRIQXrtngNKEAkHUgTURyAt1542339 = -882427062;    long lOnRIQXrtngNKEAkHUgTURyAt52936304 = 58710589;    long lOnRIQXrtngNKEAkHUgTURyAt56089684 = -362625554;    long lOnRIQXrtngNKEAkHUgTURyAt80766616 = -76578937;    long lOnRIQXrtngNKEAkHUgTURyAt52027300 = -267629179;    long lOnRIQXrtngNKEAkHUgTURyAt9904349 = -874117579;    long lOnRIQXrtngNKEAkHUgTURyAt16076012 = -189111113;    long lOnRIQXrtngNKEAkHUgTURyAt83847831 = -116306240;    long lOnRIQXrtngNKEAkHUgTURyAt45627973 = -72651641;    long lOnRIQXrtngNKEAkHUgTURyAt81272229 = -202621702;    long lOnRIQXrtngNKEAkHUgTURyAt53253237 = -466978183;    long lOnRIQXrtngNKEAkHUgTURyAt89644900 = -809451818;    long lOnRIQXrtngNKEAkHUgTURyAt33935219 = -73492630;    long lOnRIQXrtngNKEAkHUgTURyAt59529931 = -91726189;    long lOnRIQXrtngNKEAkHUgTURyAt61821576 = -948194794;    long lOnRIQXrtngNKEAkHUgTURyAt81099544 = -193490605;    long lOnRIQXrtngNKEAkHUgTURyAt13609322 = -814456441;    long lOnRIQXrtngNKEAkHUgTURyAt69482508 = -625992903;    long lOnRIQXrtngNKEAkHUgTURyAt68413716 = -807991796;    long lOnRIQXrtngNKEAkHUgTURyAt18314182 = 40954313;    long lOnRIQXrtngNKEAkHUgTURyAt80680501 = -286523732;    long lOnRIQXrtngNKEAkHUgTURyAt77638358 = -263927426;    long lOnRIQXrtngNKEAkHUgTURyAt95649037 = -951481033;    long lOnRIQXrtngNKEAkHUgTURyAt80482916 = 14808613;    long lOnRIQXrtngNKEAkHUgTURyAt41051941 = -48163081;    long lOnRIQXrtngNKEAkHUgTURyAt87247677 = -902326271;    long lOnRIQXrtngNKEAkHUgTURyAt4234542 = -223673891;    long lOnRIQXrtngNKEAkHUgTURyAt14344127 = -833755320;    long lOnRIQXrtngNKEAkHUgTURyAt86806227 = -374496675;    long lOnRIQXrtngNKEAkHUgTURyAt30925706 = -614412207;    long lOnRIQXrtngNKEAkHUgTURyAt85132604 = -732144580;    long lOnRIQXrtngNKEAkHUgTURyAt64265739 = -32453069;    long lOnRIQXrtngNKEAkHUgTURyAt16425738 = -115380036;    long lOnRIQXrtngNKEAkHUgTURyAt3004018 = 3884552;    long lOnRIQXrtngNKEAkHUgTURyAt45589292 = -488985325;    long lOnRIQXrtngNKEAkHUgTURyAt16289108 = -297939946;    long lOnRIQXrtngNKEAkHUgTURyAt23913441 = -181515971;    long lOnRIQXrtngNKEAkHUgTURyAt91374448 = -989913892;    long lOnRIQXrtngNKEAkHUgTURyAt59574489 = 61079723;    long lOnRIQXrtngNKEAkHUgTURyAt8609793 = -56165688;    long lOnRIQXrtngNKEAkHUgTURyAt92496315 = -694307335;    long lOnRIQXrtngNKEAkHUgTURyAt76685806 = -518307554;    long lOnRIQXrtngNKEAkHUgTURyAt2190907 = -758010139;    long lOnRIQXrtngNKEAkHUgTURyAt55684332 = -405654050;    long lOnRIQXrtngNKEAkHUgTURyAt89104091 = -194483394;    long lOnRIQXrtngNKEAkHUgTURyAt83907612 = -541527940;    long lOnRIQXrtngNKEAkHUgTURyAt27177619 = -295133966;    long lOnRIQXrtngNKEAkHUgTURyAt71883771 = -240016308;    long lOnRIQXrtngNKEAkHUgTURyAt29479839 = -9061675;    long lOnRIQXrtngNKEAkHUgTURyAt23765269 = -674169554;    long lOnRIQXrtngNKEAkHUgTURyAt33678731 = -187134822;    long lOnRIQXrtngNKEAkHUgTURyAt83625191 = -497920874;    long lOnRIQXrtngNKEAkHUgTURyAt40139721 = -229633170;    long lOnRIQXrtngNKEAkHUgTURyAt10122263 = -285962526;    long lOnRIQXrtngNKEAkHUgTURyAt76483631 = -612193743;    long lOnRIQXrtngNKEAkHUgTURyAt23903981 = -518499636;    long lOnRIQXrtngNKEAkHUgTURyAt57287267 = 10191621;    long lOnRIQXrtngNKEAkHUgTURyAt75606768 = -277434167;    long lOnRIQXrtngNKEAkHUgTURyAt39714675 = 71584143;    long lOnRIQXrtngNKEAkHUgTURyAt64779623 = -365302908;    long lOnRIQXrtngNKEAkHUgTURyAt5669807 = -550443689;    long lOnRIQXrtngNKEAkHUgTURyAt1731885 = -355355794;    long lOnRIQXrtngNKEAkHUgTURyAt97041603 = -741809566;    long lOnRIQXrtngNKEAkHUgTURyAt14702268 = -458239434;    long lOnRIQXrtngNKEAkHUgTURyAt96139624 = -21137525;     lOnRIQXrtngNKEAkHUgTURyAt41214139 = lOnRIQXrtngNKEAkHUgTURyAt25457239;     lOnRIQXrtngNKEAkHUgTURyAt25457239 = lOnRIQXrtngNKEAkHUgTURyAt32605598;     lOnRIQXrtngNKEAkHUgTURyAt32605598 = lOnRIQXrtngNKEAkHUgTURyAt22840245;     lOnRIQXrtngNKEAkHUgTURyAt22840245 = lOnRIQXrtngNKEAkHUgTURyAt14604454;     lOnRIQXrtngNKEAkHUgTURyAt14604454 = lOnRIQXrtngNKEAkHUgTURyAt48360515;     lOnRIQXrtngNKEAkHUgTURyAt48360515 = lOnRIQXrtngNKEAkHUgTURyAt35648245;     lOnRIQXrtngNKEAkHUgTURyAt35648245 = lOnRIQXrtngNKEAkHUgTURyAt5645543;     lOnRIQXrtngNKEAkHUgTURyAt5645543 = lOnRIQXrtngNKEAkHUgTURyAt91671040;     lOnRIQXrtngNKEAkHUgTURyAt91671040 = lOnRIQXrtngNKEAkHUgTURyAt78213759;     lOnRIQXrtngNKEAkHUgTURyAt78213759 = lOnRIQXrtngNKEAkHUgTURyAt38240304;     lOnRIQXrtngNKEAkHUgTURyAt38240304 = lOnRIQXrtngNKEAkHUgTURyAt72819177;     lOnRIQXrtngNKEAkHUgTURyAt72819177 = lOnRIQXrtngNKEAkHUgTURyAt44862182;     lOnRIQXrtngNKEAkHUgTURyAt44862182 = lOnRIQXrtngNKEAkHUgTURyAt60168150;     lOnRIQXrtngNKEAkHUgTURyAt60168150 = lOnRIQXrtngNKEAkHUgTURyAt47131630;     lOnRIQXrtngNKEAkHUgTURyAt47131630 = lOnRIQXrtngNKEAkHUgTURyAt69225411;     lOnRIQXrtngNKEAkHUgTURyAt69225411 = lOnRIQXrtngNKEAkHUgTURyAt80003125;     lOnRIQXrtngNKEAkHUgTURyAt80003125 = lOnRIQXrtngNKEAkHUgTURyAt72141064;     lOnRIQXrtngNKEAkHUgTURyAt72141064 = lOnRIQXrtngNKEAkHUgTURyAt11601790;     lOnRIQXrtngNKEAkHUgTURyAt11601790 = lOnRIQXrtngNKEAkHUgTURyAt18514141;     lOnRIQXrtngNKEAkHUgTURyAt18514141 = lOnRIQXrtngNKEAkHUgTURyAt8572327;     lOnRIQXrtngNKEAkHUgTURyAt8572327 = lOnRIQXrtngNKEAkHUgTURyAt60533637;     lOnRIQXrtngNKEAkHUgTURyAt60533637 = lOnRIQXrtngNKEAkHUgTURyAt47818880;     lOnRIQXrtngNKEAkHUgTURyAt47818880 = lOnRIQXrtngNKEAkHUgTURyAt36956561;     lOnRIQXrtngNKEAkHUgTURyAt36956561 = lOnRIQXrtngNKEAkHUgTURyAt42357328;     lOnRIQXrtngNKEAkHUgTURyAt42357328 = lOnRIQXrtngNKEAkHUgTURyAt73552513;     lOnRIQXrtngNKEAkHUgTURyAt73552513 = lOnRIQXrtngNKEAkHUgTURyAt61112837;     lOnRIQXrtngNKEAkHUgTURyAt61112837 = lOnRIQXrtngNKEAkHUgTURyAt31413703;     lOnRIQXrtngNKEAkHUgTURyAt31413703 = lOnRIQXrtngNKEAkHUgTURyAt91301415;     lOnRIQXrtngNKEAkHUgTURyAt91301415 = lOnRIQXrtngNKEAkHUgTURyAt4864813;     lOnRIQXrtngNKEAkHUgTURyAt4864813 = lOnRIQXrtngNKEAkHUgTURyAt47288053;     lOnRIQXrtngNKEAkHUgTURyAt47288053 = lOnRIQXrtngNKEAkHUgTURyAt53107699;     lOnRIQXrtngNKEAkHUgTURyAt53107699 = lOnRIQXrtngNKEAkHUgTURyAt8553438;     lOnRIQXrtngNKEAkHUgTURyAt8553438 = lOnRIQXrtngNKEAkHUgTURyAt28436445;     lOnRIQXrtngNKEAkHUgTURyAt28436445 = lOnRIQXrtngNKEAkHUgTURyAt57164132;     lOnRIQXrtngNKEAkHUgTURyAt57164132 = lOnRIQXrtngNKEAkHUgTURyAt1542339;     lOnRIQXrtngNKEAkHUgTURyAt1542339 = lOnRIQXrtngNKEAkHUgTURyAt52936304;     lOnRIQXrtngNKEAkHUgTURyAt52936304 = lOnRIQXrtngNKEAkHUgTURyAt56089684;     lOnRIQXrtngNKEAkHUgTURyAt56089684 = lOnRIQXrtngNKEAkHUgTURyAt80766616;     lOnRIQXrtngNKEAkHUgTURyAt80766616 = lOnRIQXrtngNKEAkHUgTURyAt52027300;     lOnRIQXrtngNKEAkHUgTURyAt52027300 = lOnRIQXrtngNKEAkHUgTURyAt9904349;     lOnRIQXrtngNKEAkHUgTURyAt9904349 = lOnRIQXrtngNKEAkHUgTURyAt16076012;     lOnRIQXrtngNKEAkHUgTURyAt16076012 = lOnRIQXrtngNKEAkHUgTURyAt83847831;     lOnRIQXrtngNKEAkHUgTURyAt83847831 = lOnRIQXrtngNKEAkHUgTURyAt45627973;     lOnRIQXrtngNKEAkHUgTURyAt45627973 = lOnRIQXrtngNKEAkHUgTURyAt81272229;     lOnRIQXrtngNKEAkHUgTURyAt81272229 = lOnRIQXrtngNKEAkHUgTURyAt53253237;     lOnRIQXrtngNKEAkHUgTURyAt53253237 = lOnRIQXrtngNKEAkHUgTURyAt89644900;     lOnRIQXrtngNKEAkHUgTURyAt89644900 = lOnRIQXrtngNKEAkHUgTURyAt33935219;     lOnRIQXrtngNKEAkHUgTURyAt33935219 = lOnRIQXrtngNKEAkHUgTURyAt59529931;     lOnRIQXrtngNKEAkHUgTURyAt59529931 = lOnRIQXrtngNKEAkHUgTURyAt61821576;     lOnRIQXrtngNKEAkHUgTURyAt61821576 = lOnRIQXrtngNKEAkHUgTURyAt81099544;     lOnRIQXrtngNKEAkHUgTURyAt81099544 = lOnRIQXrtngNKEAkHUgTURyAt13609322;     lOnRIQXrtngNKEAkHUgTURyAt13609322 = lOnRIQXrtngNKEAkHUgTURyAt69482508;     lOnRIQXrtngNKEAkHUgTURyAt69482508 = lOnRIQXrtngNKEAkHUgTURyAt68413716;     lOnRIQXrtngNKEAkHUgTURyAt68413716 = lOnRIQXrtngNKEAkHUgTURyAt18314182;     lOnRIQXrtngNKEAkHUgTURyAt18314182 = lOnRIQXrtngNKEAkHUgTURyAt80680501;     lOnRIQXrtngNKEAkHUgTURyAt80680501 = lOnRIQXrtngNKEAkHUgTURyAt77638358;     lOnRIQXrtngNKEAkHUgTURyAt77638358 = lOnRIQXrtngNKEAkHUgTURyAt95649037;     lOnRIQXrtngNKEAkHUgTURyAt95649037 = lOnRIQXrtngNKEAkHUgTURyAt80482916;     lOnRIQXrtngNKEAkHUgTURyAt80482916 = lOnRIQXrtngNKEAkHUgTURyAt41051941;     lOnRIQXrtngNKEAkHUgTURyAt41051941 = lOnRIQXrtngNKEAkHUgTURyAt87247677;     lOnRIQXrtngNKEAkHUgTURyAt87247677 = lOnRIQXrtngNKEAkHUgTURyAt4234542;     lOnRIQXrtngNKEAkHUgTURyAt4234542 = lOnRIQXrtngNKEAkHUgTURyAt14344127;     lOnRIQXrtngNKEAkHUgTURyAt14344127 = lOnRIQXrtngNKEAkHUgTURyAt86806227;     lOnRIQXrtngNKEAkHUgTURyAt86806227 = lOnRIQXrtngNKEAkHUgTURyAt30925706;     lOnRIQXrtngNKEAkHUgTURyAt30925706 = lOnRIQXrtngNKEAkHUgTURyAt85132604;     lOnRIQXrtngNKEAkHUgTURyAt85132604 = lOnRIQXrtngNKEAkHUgTURyAt64265739;     lOnRIQXrtngNKEAkHUgTURyAt64265739 = lOnRIQXrtngNKEAkHUgTURyAt16425738;     lOnRIQXrtngNKEAkHUgTURyAt16425738 = lOnRIQXrtngNKEAkHUgTURyAt3004018;     lOnRIQXrtngNKEAkHUgTURyAt3004018 = lOnRIQXrtngNKEAkHUgTURyAt45589292;     lOnRIQXrtngNKEAkHUgTURyAt45589292 = lOnRIQXrtngNKEAkHUgTURyAt16289108;     lOnRIQXrtngNKEAkHUgTURyAt16289108 = lOnRIQXrtngNKEAkHUgTURyAt23913441;     lOnRIQXrtngNKEAkHUgTURyAt23913441 = lOnRIQXrtngNKEAkHUgTURyAt91374448;     lOnRIQXrtngNKEAkHUgTURyAt91374448 = lOnRIQXrtngNKEAkHUgTURyAt59574489;     lOnRIQXrtngNKEAkHUgTURyAt59574489 = lOnRIQXrtngNKEAkHUgTURyAt8609793;     lOnRIQXrtngNKEAkHUgTURyAt8609793 = lOnRIQXrtngNKEAkHUgTURyAt92496315;     lOnRIQXrtngNKEAkHUgTURyAt92496315 = lOnRIQXrtngNKEAkHUgTURyAt76685806;     lOnRIQXrtngNKEAkHUgTURyAt76685806 = lOnRIQXrtngNKEAkHUgTURyAt2190907;     lOnRIQXrtngNKEAkHUgTURyAt2190907 = lOnRIQXrtngNKEAkHUgTURyAt55684332;     lOnRIQXrtngNKEAkHUgTURyAt55684332 = lOnRIQXrtngNKEAkHUgTURyAt89104091;     lOnRIQXrtngNKEAkHUgTURyAt89104091 = lOnRIQXrtngNKEAkHUgTURyAt83907612;     lOnRIQXrtngNKEAkHUgTURyAt83907612 = lOnRIQXrtngNKEAkHUgTURyAt27177619;     lOnRIQXrtngNKEAkHUgTURyAt27177619 = lOnRIQXrtngNKEAkHUgTURyAt71883771;     lOnRIQXrtngNKEAkHUgTURyAt71883771 = lOnRIQXrtngNKEAkHUgTURyAt29479839;     lOnRIQXrtngNKEAkHUgTURyAt29479839 = lOnRIQXrtngNKEAkHUgTURyAt23765269;     lOnRIQXrtngNKEAkHUgTURyAt23765269 = lOnRIQXrtngNKEAkHUgTURyAt33678731;     lOnRIQXrtngNKEAkHUgTURyAt33678731 = lOnRIQXrtngNKEAkHUgTURyAt83625191;     lOnRIQXrtngNKEAkHUgTURyAt83625191 = lOnRIQXrtngNKEAkHUgTURyAt40139721;     lOnRIQXrtngNKEAkHUgTURyAt40139721 = lOnRIQXrtngNKEAkHUgTURyAt10122263;     lOnRIQXrtngNKEAkHUgTURyAt10122263 = lOnRIQXrtngNKEAkHUgTURyAt76483631;     lOnRIQXrtngNKEAkHUgTURyAt76483631 = lOnRIQXrtngNKEAkHUgTURyAt23903981;     lOnRIQXrtngNKEAkHUgTURyAt23903981 = lOnRIQXrtngNKEAkHUgTURyAt57287267;     lOnRIQXrtngNKEAkHUgTURyAt57287267 = lOnRIQXrtngNKEAkHUgTURyAt75606768;     lOnRIQXrtngNKEAkHUgTURyAt75606768 = lOnRIQXrtngNKEAkHUgTURyAt39714675;     lOnRIQXrtngNKEAkHUgTURyAt39714675 = lOnRIQXrtngNKEAkHUgTURyAt64779623;     lOnRIQXrtngNKEAkHUgTURyAt64779623 = lOnRIQXrtngNKEAkHUgTURyAt5669807;     lOnRIQXrtngNKEAkHUgTURyAt5669807 = lOnRIQXrtngNKEAkHUgTURyAt1731885;     lOnRIQXrtngNKEAkHUgTURyAt1731885 = lOnRIQXrtngNKEAkHUgTURyAt97041603;     lOnRIQXrtngNKEAkHUgTURyAt97041603 = lOnRIQXrtngNKEAkHUgTURyAt14702268;     lOnRIQXrtngNKEAkHUgTURyAt14702268 = lOnRIQXrtngNKEAkHUgTURyAt96139624;     lOnRIQXrtngNKEAkHUgTURyAt96139624 = lOnRIQXrtngNKEAkHUgTURyAt41214139;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void pVDpEEpugNFZwQYLciceaqQUvPLwaZzfRxaEpHuUPpKIdrVcFICUwQPyE41935577() {     long jupstTGOZHypTVUnIOlgIrDtj47331245 = -133039414;    long jupstTGOZHypTVUnIOlgIrDtj68830518 = 95811014;    long jupstTGOZHypTVUnIOlgIrDtj48647782 = -810589706;    long jupstTGOZHypTVUnIOlgIrDtj49915025 = 62598407;    long jupstTGOZHypTVUnIOlgIrDtj83499942 = 80207291;    long jupstTGOZHypTVUnIOlgIrDtj39777717 = -635449102;    long jupstTGOZHypTVUnIOlgIrDtj96137210 = -894381364;    long jupstTGOZHypTVUnIOlgIrDtj55405433 = -77885701;    long jupstTGOZHypTVUnIOlgIrDtj56313536 = -110189499;    long jupstTGOZHypTVUnIOlgIrDtj19443418 = 55021052;    long jupstTGOZHypTVUnIOlgIrDtj98350594 = -833495942;    long jupstTGOZHypTVUnIOlgIrDtj4642220 = -614484236;    long jupstTGOZHypTVUnIOlgIrDtj31071300 = 99720663;    long jupstTGOZHypTVUnIOlgIrDtj43311827 = -527071490;    long jupstTGOZHypTVUnIOlgIrDtj42874057 = 38125447;    long jupstTGOZHypTVUnIOlgIrDtj10730805 = -312228900;    long jupstTGOZHypTVUnIOlgIrDtj73839128 = -160686637;    long jupstTGOZHypTVUnIOlgIrDtj69194217 = -832015472;    long jupstTGOZHypTVUnIOlgIrDtj73431631 = -712318552;    long jupstTGOZHypTVUnIOlgIrDtj99064305 = -287186186;    long jupstTGOZHypTVUnIOlgIrDtj97125520 = -838905903;    long jupstTGOZHypTVUnIOlgIrDtj47054661 = -642543510;    long jupstTGOZHypTVUnIOlgIrDtj83409672 = -677179266;    long jupstTGOZHypTVUnIOlgIrDtj20948935 = -930580740;    long jupstTGOZHypTVUnIOlgIrDtj86056978 = -34657609;    long jupstTGOZHypTVUnIOlgIrDtj98274188 = -229635080;    long jupstTGOZHypTVUnIOlgIrDtj59572616 = -369288799;    long jupstTGOZHypTVUnIOlgIrDtj44520828 = -497671450;    long jupstTGOZHypTVUnIOlgIrDtj57433671 = -179639173;    long jupstTGOZHypTVUnIOlgIrDtj73480449 = -785131026;    long jupstTGOZHypTVUnIOlgIrDtj39530602 = 85087799;    long jupstTGOZHypTVUnIOlgIrDtj50718321 = -933360592;    long jupstTGOZHypTVUnIOlgIrDtj18264386 = 69761664;    long jupstTGOZHypTVUnIOlgIrDtj23267009 = -96549978;    long jupstTGOZHypTVUnIOlgIrDtj18638785 = -537450581;    long jupstTGOZHypTVUnIOlgIrDtj70268252 = 3546831;    long jupstTGOZHypTVUnIOlgIrDtj34198239 = -994925281;    long jupstTGOZHypTVUnIOlgIrDtj90179896 = -134131563;    long jupstTGOZHypTVUnIOlgIrDtj54376870 = -70502434;    long jupstTGOZHypTVUnIOlgIrDtj39529238 = -741068401;    long jupstTGOZHypTVUnIOlgIrDtj15573573 = -939391473;    long jupstTGOZHypTVUnIOlgIrDtj48226469 = -459253392;    long jupstTGOZHypTVUnIOlgIrDtj61914809 = -197110824;    long jupstTGOZHypTVUnIOlgIrDtj33035714 = -91994579;    long jupstTGOZHypTVUnIOlgIrDtj93224694 = -964519857;    long jupstTGOZHypTVUnIOlgIrDtj65192432 = -452194299;    long jupstTGOZHypTVUnIOlgIrDtj7423475 = -928227355;    long jupstTGOZHypTVUnIOlgIrDtj41892160 = -83388163;    long jupstTGOZHypTVUnIOlgIrDtj69205660 = -177463177;    long jupstTGOZHypTVUnIOlgIrDtj74733229 = 64794398;    long jupstTGOZHypTVUnIOlgIrDtj16800223 = -35784276;    long jupstTGOZHypTVUnIOlgIrDtj24419042 = -615182761;    long jupstTGOZHypTVUnIOlgIrDtj17730966 = -417782490;    long jupstTGOZHypTVUnIOlgIrDtj64382597 = -28461941;    long jupstTGOZHypTVUnIOlgIrDtj44810056 = -659577469;    long jupstTGOZHypTVUnIOlgIrDtj276585 = -490495905;    long jupstTGOZHypTVUnIOlgIrDtj85420845 = -227009720;    long jupstTGOZHypTVUnIOlgIrDtj27698847 = -880008966;    long jupstTGOZHypTVUnIOlgIrDtj63858047 = -902743984;    long jupstTGOZHypTVUnIOlgIrDtj85225754 = -690157629;    long jupstTGOZHypTVUnIOlgIrDtj80205101 = -166160303;    long jupstTGOZHypTVUnIOlgIrDtj51616383 = -296709914;    long jupstTGOZHypTVUnIOlgIrDtj97971762 = -898246529;    long jupstTGOZHypTVUnIOlgIrDtj82833086 = -325058473;    long jupstTGOZHypTVUnIOlgIrDtj79912816 = 69933253;    long jupstTGOZHypTVUnIOlgIrDtj47632273 = -900135350;    long jupstTGOZHypTVUnIOlgIrDtj86377833 = -584245900;    long jupstTGOZHypTVUnIOlgIrDtj7804292 = -803729359;    long jupstTGOZHypTVUnIOlgIrDtj24673042 = -989620910;    long jupstTGOZHypTVUnIOlgIrDtj72605805 = -965421384;    long jupstTGOZHypTVUnIOlgIrDtj76532566 = -317303620;    long jupstTGOZHypTVUnIOlgIrDtj83659231 = 73444926;    long jupstTGOZHypTVUnIOlgIrDtj14817348 = -661513038;    long jupstTGOZHypTVUnIOlgIrDtj33902393 = -971250151;    long jupstTGOZHypTVUnIOlgIrDtj83490733 = -347794713;    long jupstTGOZHypTVUnIOlgIrDtj48899052 = -279652512;    long jupstTGOZHypTVUnIOlgIrDtj85139851 = -345432687;    long jupstTGOZHypTVUnIOlgIrDtj50373958 = -485184688;    long jupstTGOZHypTVUnIOlgIrDtj27724241 = -966060884;    long jupstTGOZHypTVUnIOlgIrDtj20864546 = -582463311;    long jupstTGOZHypTVUnIOlgIrDtj90850713 = -301407726;    long jupstTGOZHypTVUnIOlgIrDtj17680456 = -185900637;    long jupstTGOZHypTVUnIOlgIrDtj75315167 = -220208274;    long jupstTGOZHypTVUnIOlgIrDtj82700441 = -144433571;    long jupstTGOZHypTVUnIOlgIrDtj56680227 = -649346750;    long jupstTGOZHypTVUnIOlgIrDtj15111561 = -299729440;    long jupstTGOZHypTVUnIOlgIrDtj32987355 = -415578102;    long jupstTGOZHypTVUnIOlgIrDtj53881789 = -901776395;    long jupstTGOZHypTVUnIOlgIrDtj78456952 = -436972509;    long jupstTGOZHypTVUnIOlgIrDtj18362201 = 53045324;    long jupstTGOZHypTVUnIOlgIrDtj84847406 = -769443450;    long jupstTGOZHypTVUnIOlgIrDtj6499392 = -14916315;    long jupstTGOZHypTVUnIOlgIrDtj26321850 = -231387579;    long jupstTGOZHypTVUnIOlgIrDtj69151115 = -380344806;    long jupstTGOZHypTVUnIOlgIrDtj59324136 = -474908099;    long jupstTGOZHypTVUnIOlgIrDtj63957190 = -542681559;    long jupstTGOZHypTVUnIOlgIrDtj50254706 = -561006863;    long jupstTGOZHypTVUnIOlgIrDtj79081723 = -872052351;    long jupstTGOZHypTVUnIOlgIrDtj53122898 = -61927833;    long jupstTGOZHypTVUnIOlgIrDtj45592421 = -133039414;     jupstTGOZHypTVUnIOlgIrDtj47331245 = jupstTGOZHypTVUnIOlgIrDtj68830518;     jupstTGOZHypTVUnIOlgIrDtj68830518 = jupstTGOZHypTVUnIOlgIrDtj48647782;     jupstTGOZHypTVUnIOlgIrDtj48647782 = jupstTGOZHypTVUnIOlgIrDtj49915025;     jupstTGOZHypTVUnIOlgIrDtj49915025 = jupstTGOZHypTVUnIOlgIrDtj83499942;     jupstTGOZHypTVUnIOlgIrDtj83499942 = jupstTGOZHypTVUnIOlgIrDtj39777717;     jupstTGOZHypTVUnIOlgIrDtj39777717 = jupstTGOZHypTVUnIOlgIrDtj96137210;     jupstTGOZHypTVUnIOlgIrDtj96137210 = jupstTGOZHypTVUnIOlgIrDtj55405433;     jupstTGOZHypTVUnIOlgIrDtj55405433 = jupstTGOZHypTVUnIOlgIrDtj56313536;     jupstTGOZHypTVUnIOlgIrDtj56313536 = jupstTGOZHypTVUnIOlgIrDtj19443418;     jupstTGOZHypTVUnIOlgIrDtj19443418 = jupstTGOZHypTVUnIOlgIrDtj98350594;     jupstTGOZHypTVUnIOlgIrDtj98350594 = jupstTGOZHypTVUnIOlgIrDtj4642220;     jupstTGOZHypTVUnIOlgIrDtj4642220 = jupstTGOZHypTVUnIOlgIrDtj31071300;     jupstTGOZHypTVUnIOlgIrDtj31071300 = jupstTGOZHypTVUnIOlgIrDtj43311827;     jupstTGOZHypTVUnIOlgIrDtj43311827 = jupstTGOZHypTVUnIOlgIrDtj42874057;     jupstTGOZHypTVUnIOlgIrDtj42874057 = jupstTGOZHypTVUnIOlgIrDtj10730805;     jupstTGOZHypTVUnIOlgIrDtj10730805 = jupstTGOZHypTVUnIOlgIrDtj73839128;     jupstTGOZHypTVUnIOlgIrDtj73839128 = jupstTGOZHypTVUnIOlgIrDtj69194217;     jupstTGOZHypTVUnIOlgIrDtj69194217 = jupstTGOZHypTVUnIOlgIrDtj73431631;     jupstTGOZHypTVUnIOlgIrDtj73431631 = jupstTGOZHypTVUnIOlgIrDtj99064305;     jupstTGOZHypTVUnIOlgIrDtj99064305 = jupstTGOZHypTVUnIOlgIrDtj97125520;     jupstTGOZHypTVUnIOlgIrDtj97125520 = jupstTGOZHypTVUnIOlgIrDtj47054661;     jupstTGOZHypTVUnIOlgIrDtj47054661 = jupstTGOZHypTVUnIOlgIrDtj83409672;     jupstTGOZHypTVUnIOlgIrDtj83409672 = jupstTGOZHypTVUnIOlgIrDtj20948935;     jupstTGOZHypTVUnIOlgIrDtj20948935 = jupstTGOZHypTVUnIOlgIrDtj86056978;     jupstTGOZHypTVUnIOlgIrDtj86056978 = jupstTGOZHypTVUnIOlgIrDtj98274188;     jupstTGOZHypTVUnIOlgIrDtj98274188 = jupstTGOZHypTVUnIOlgIrDtj59572616;     jupstTGOZHypTVUnIOlgIrDtj59572616 = jupstTGOZHypTVUnIOlgIrDtj44520828;     jupstTGOZHypTVUnIOlgIrDtj44520828 = jupstTGOZHypTVUnIOlgIrDtj57433671;     jupstTGOZHypTVUnIOlgIrDtj57433671 = jupstTGOZHypTVUnIOlgIrDtj73480449;     jupstTGOZHypTVUnIOlgIrDtj73480449 = jupstTGOZHypTVUnIOlgIrDtj39530602;     jupstTGOZHypTVUnIOlgIrDtj39530602 = jupstTGOZHypTVUnIOlgIrDtj50718321;     jupstTGOZHypTVUnIOlgIrDtj50718321 = jupstTGOZHypTVUnIOlgIrDtj18264386;     jupstTGOZHypTVUnIOlgIrDtj18264386 = jupstTGOZHypTVUnIOlgIrDtj23267009;     jupstTGOZHypTVUnIOlgIrDtj23267009 = jupstTGOZHypTVUnIOlgIrDtj18638785;     jupstTGOZHypTVUnIOlgIrDtj18638785 = jupstTGOZHypTVUnIOlgIrDtj70268252;     jupstTGOZHypTVUnIOlgIrDtj70268252 = jupstTGOZHypTVUnIOlgIrDtj34198239;     jupstTGOZHypTVUnIOlgIrDtj34198239 = jupstTGOZHypTVUnIOlgIrDtj90179896;     jupstTGOZHypTVUnIOlgIrDtj90179896 = jupstTGOZHypTVUnIOlgIrDtj54376870;     jupstTGOZHypTVUnIOlgIrDtj54376870 = jupstTGOZHypTVUnIOlgIrDtj39529238;     jupstTGOZHypTVUnIOlgIrDtj39529238 = jupstTGOZHypTVUnIOlgIrDtj15573573;     jupstTGOZHypTVUnIOlgIrDtj15573573 = jupstTGOZHypTVUnIOlgIrDtj48226469;     jupstTGOZHypTVUnIOlgIrDtj48226469 = jupstTGOZHypTVUnIOlgIrDtj61914809;     jupstTGOZHypTVUnIOlgIrDtj61914809 = jupstTGOZHypTVUnIOlgIrDtj33035714;     jupstTGOZHypTVUnIOlgIrDtj33035714 = jupstTGOZHypTVUnIOlgIrDtj93224694;     jupstTGOZHypTVUnIOlgIrDtj93224694 = jupstTGOZHypTVUnIOlgIrDtj65192432;     jupstTGOZHypTVUnIOlgIrDtj65192432 = jupstTGOZHypTVUnIOlgIrDtj7423475;     jupstTGOZHypTVUnIOlgIrDtj7423475 = jupstTGOZHypTVUnIOlgIrDtj41892160;     jupstTGOZHypTVUnIOlgIrDtj41892160 = jupstTGOZHypTVUnIOlgIrDtj69205660;     jupstTGOZHypTVUnIOlgIrDtj69205660 = jupstTGOZHypTVUnIOlgIrDtj74733229;     jupstTGOZHypTVUnIOlgIrDtj74733229 = jupstTGOZHypTVUnIOlgIrDtj16800223;     jupstTGOZHypTVUnIOlgIrDtj16800223 = jupstTGOZHypTVUnIOlgIrDtj24419042;     jupstTGOZHypTVUnIOlgIrDtj24419042 = jupstTGOZHypTVUnIOlgIrDtj17730966;     jupstTGOZHypTVUnIOlgIrDtj17730966 = jupstTGOZHypTVUnIOlgIrDtj64382597;     jupstTGOZHypTVUnIOlgIrDtj64382597 = jupstTGOZHypTVUnIOlgIrDtj44810056;     jupstTGOZHypTVUnIOlgIrDtj44810056 = jupstTGOZHypTVUnIOlgIrDtj276585;     jupstTGOZHypTVUnIOlgIrDtj276585 = jupstTGOZHypTVUnIOlgIrDtj85420845;     jupstTGOZHypTVUnIOlgIrDtj85420845 = jupstTGOZHypTVUnIOlgIrDtj27698847;     jupstTGOZHypTVUnIOlgIrDtj27698847 = jupstTGOZHypTVUnIOlgIrDtj63858047;     jupstTGOZHypTVUnIOlgIrDtj63858047 = jupstTGOZHypTVUnIOlgIrDtj85225754;     jupstTGOZHypTVUnIOlgIrDtj85225754 = jupstTGOZHypTVUnIOlgIrDtj80205101;     jupstTGOZHypTVUnIOlgIrDtj80205101 = jupstTGOZHypTVUnIOlgIrDtj51616383;     jupstTGOZHypTVUnIOlgIrDtj51616383 = jupstTGOZHypTVUnIOlgIrDtj97971762;     jupstTGOZHypTVUnIOlgIrDtj97971762 = jupstTGOZHypTVUnIOlgIrDtj82833086;     jupstTGOZHypTVUnIOlgIrDtj82833086 = jupstTGOZHypTVUnIOlgIrDtj79912816;     jupstTGOZHypTVUnIOlgIrDtj79912816 = jupstTGOZHypTVUnIOlgIrDtj47632273;     jupstTGOZHypTVUnIOlgIrDtj47632273 = jupstTGOZHypTVUnIOlgIrDtj86377833;     jupstTGOZHypTVUnIOlgIrDtj86377833 = jupstTGOZHypTVUnIOlgIrDtj7804292;     jupstTGOZHypTVUnIOlgIrDtj7804292 = jupstTGOZHypTVUnIOlgIrDtj24673042;     jupstTGOZHypTVUnIOlgIrDtj24673042 = jupstTGOZHypTVUnIOlgIrDtj72605805;     jupstTGOZHypTVUnIOlgIrDtj72605805 = jupstTGOZHypTVUnIOlgIrDtj76532566;     jupstTGOZHypTVUnIOlgIrDtj76532566 = jupstTGOZHypTVUnIOlgIrDtj83659231;     jupstTGOZHypTVUnIOlgIrDtj83659231 = jupstTGOZHypTVUnIOlgIrDtj14817348;     jupstTGOZHypTVUnIOlgIrDtj14817348 = jupstTGOZHypTVUnIOlgIrDtj33902393;     jupstTGOZHypTVUnIOlgIrDtj33902393 = jupstTGOZHypTVUnIOlgIrDtj83490733;     jupstTGOZHypTVUnIOlgIrDtj83490733 = jupstTGOZHypTVUnIOlgIrDtj48899052;     jupstTGOZHypTVUnIOlgIrDtj48899052 = jupstTGOZHypTVUnIOlgIrDtj85139851;     jupstTGOZHypTVUnIOlgIrDtj85139851 = jupstTGOZHypTVUnIOlgIrDtj50373958;     jupstTGOZHypTVUnIOlgIrDtj50373958 = jupstTGOZHypTVUnIOlgIrDtj27724241;     jupstTGOZHypTVUnIOlgIrDtj27724241 = jupstTGOZHypTVUnIOlgIrDtj20864546;     jupstTGOZHypTVUnIOlgIrDtj20864546 = jupstTGOZHypTVUnIOlgIrDtj90850713;     jupstTGOZHypTVUnIOlgIrDtj90850713 = jupstTGOZHypTVUnIOlgIrDtj17680456;     jupstTGOZHypTVUnIOlgIrDtj17680456 = jupstTGOZHypTVUnIOlgIrDtj75315167;     jupstTGOZHypTVUnIOlgIrDtj75315167 = jupstTGOZHypTVUnIOlgIrDtj82700441;     jupstTGOZHypTVUnIOlgIrDtj82700441 = jupstTGOZHypTVUnIOlgIrDtj56680227;     jupstTGOZHypTVUnIOlgIrDtj56680227 = jupstTGOZHypTVUnIOlgIrDtj15111561;     jupstTGOZHypTVUnIOlgIrDtj15111561 = jupstTGOZHypTVUnIOlgIrDtj32987355;     jupstTGOZHypTVUnIOlgIrDtj32987355 = jupstTGOZHypTVUnIOlgIrDtj53881789;     jupstTGOZHypTVUnIOlgIrDtj53881789 = jupstTGOZHypTVUnIOlgIrDtj78456952;     jupstTGOZHypTVUnIOlgIrDtj78456952 = jupstTGOZHypTVUnIOlgIrDtj18362201;     jupstTGOZHypTVUnIOlgIrDtj18362201 = jupstTGOZHypTVUnIOlgIrDtj84847406;     jupstTGOZHypTVUnIOlgIrDtj84847406 = jupstTGOZHypTVUnIOlgIrDtj6499392;     jupstTGOZHypTVUnIOlgIrDtj6499392 = jupstTGOZHypTVUnIOlgIrDtj26321850;     jupstTGOZHypTVUnIOlgIrDtj26321850 = jupstTGOZHypTVUnIOlgIrDtj69151115;     jupstTGOZHypTVUnIOlgIrDtj69151115 = jupstTGOZHypTVUnIOlgIrDtj59324136;     jupstTGOZHypTVUnIOlgIrDtj59324136 = jupstTGOZHypTVUnIOlgIrDtj63957190;     jupstTGOZHypTVUnIOlgIrDtj63957190 = jupstTGOZHypTVUnIOlgIrDtj50254706;     jupstTGOZHypTVUnIOlgIrDtj50254706 = jupstTGOZHypTVUnIOlgIrDtj79081723;     jupstTGOZHypTVUnIOlgIrDtj79081723 = jupstTGOZHypTVUnIOlgIrDtj53122898;     jupstTGOZHypTVUnIOlgIrDtj53122898 = jupstTGOZHypTVUnIOlgIrDtj45592421;     jupstTGOZHypTVUnIOlgIrDtj45592421 = jupstTGOZHypTVUnIOlgIrDtj47331245;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void BkasNXluTmgjfmDqCINlJvqJaDoRIFrVWxaLVznWwuOYnyryWkjdDsGGu9227176() {     long QRKjTmOvKMiMsVDUqoPhSVcLp82790213 = -599316314;    long QRKjTmOvKMiMsVDUqoPhSVcLp82102596 = -884740592;    long QRKjTmOvKMiMsVDUqoPhSVcLp86034258 = -476256781;    long QRKjTmOvKMiMsVDUqoPhSVcLp22138380 = -858552664;    long QRKjTmOvKMiMsVDUqoPhSVcLp39785211 = -25391554;    long QRKjTmOvKMiMsVDUqoPhSVcLp76000589 = -897796997;    long QRKjTmOvKMiMsVDUqoPhSVcLp6794617 = -739107098;    long QRKjTmOvKMiMsVDUqoPhSVcLp17536995 = -822119842;    long QRKjTmOvKMiMsVDUqoPhSVcLp57831141 = -598520906;    long QRKjTmOvKMiMsVDUqoPhSVcLp34346130 = -709665946;    long QRKjTmOvKMiMsVDUqoPhSVcLp36532329 = -635503671;    long QRKjTmOvKMiMsVDUqoPhSVcLp5210368 = -478605007;    long QRKjTmOvKMiMsVDUqoPhSVcLp69305946 = -452291841;    long QRKjTmOvKMiMsVDUqoPhSVcLp96452689 = -503434899;    long QRKjTmOvKMiMsVDUqoPhSVcLp1068574 = -465299568;    long QRKjTmOvKMiMsVDUqoPhSVcLp94272105 = 51959493;    long QRKjTmOvKMiMsVDUqoPhSVcLp29675065 = -687661190;    long QRKjTmOvKMiMsVDUqoPhSVcLp68954408 = -905443540;    long QRKjTmOvKMiMsVDUqoPhSVcLp73981961 = 71118026;    long QRKjTmOvKMiMsVDUqoPhSVcLp92901523 = -713747252;    long QRKjTmOvKMiMsVDUqoPhSVcLp10212384 = -496180592;    long QRKjTmOvKMiMsVDUqoPhSVcLp50476186 = -729179804;    long QRKjTmOvKMiMsVDUqoPhSVcLp53935052 = -314811450;    long QRKjTmOvKMiMsVDUqoPhSVcLp14741881 = -341405344;    long QRKjTmOvKMiMsVDUqoPhSVcLp94074929 = -58642807;    long QRKjTmOvKMiMsVDUqoPhSVcLp8972360 = 81788113;    long QRKjTmOvKMiMsVDUqoPhSVcLp19993190 = -175572940;    long QRKjTmOvKMiMsVDUqoPhSVcLp85249253 = -667443625;    long QRKjTmOvKMiMsVDUqoPhSVcLp4101886 = -753733976;    long QRKjTmOvKMiMsVDUqoPhSVcLp79013860 = -819638197;    long QRKjTmOvKMiMsVDUqoPhSVcLp58113834 = -466892688;    long QRKjTmOvKMiMsVDUqoPhSVcLp88541339 = -706332006;    long QRKjTmOvKMiMsVDUqoPhSVcLp30482397 = -77834313;    long QRKjTmOvKMiMsVDUqoPhSVcLp53015435 = -161243791;    long QRKjTmOvKMiMsVDUqoPhSVcLp84447238 = -488550831;    long QRKjTmOvKMiMsVDUqoPhSVcLp21829096 = -211018475;    long QRKjTmOvKMiMsVDUqoPhSVcLp83610055 = -859621321;    long QRKjTmOvKMiMsVDUqoPhSVcLp41395300 = -116787144;    long QRKjTmOvKMiMsVDUqoPhSVcLp84767431 = -821378710;    long QRKjTmOvKMiMsVDUqoPhSVcLp3800770 = -206330947;    long QRKjTmOvKMiMsVDUqoPhSVcLp49025180 = -708590387;    long QRKjTmOvKMiMsVDUqoPhSVcLp37591596 = -53798683;    long QRKjTmOvKMiMsVDUqoPhSVcLp51298188 = -850291610;    long QRKjTmOvKMiMsVDUqoPhSVcLp73167052 = -696326989;    long QRKjTmOvKMiMsVDUqoPhSVcLp93241152 = -791031018;    long QRKjTmOvKMiMsVDUqoPhSVcLp11153761 = -491117931;    long QRKjTmOvKMiMsVDUqoPhSVcLp26768639 = -312213716;    long QRKjTmOvKMiMsVDUqoPhSVcLp59618472 = -249914756;    long QRKjTmOvKMiMsVDUqoPhSVcLp92098326 = -941200057;    long QRKjTmOvKMiMsVDUqoPhSVcLp99262818 = -426232418;    long QRKjTmOvKMiMsVDUqoPhSVcLp97570946 = 89939166;    long QRKjTmOvKMiMsVDUqoPhSVcLp7904514 = -828835108;    long QRKjTmOvKMiMsVDUqoPhSVcLp86352114 = -173828044;    long QRKjTmOvKMiMsVDUqoPhSVcLp80374443 = -219970441;    long QRKjTmOvKMiMsVDUqoPhSVcLp99014792 = 93932385;    long QRKjTmOvKMiMsVDUqoPhSVcLp32314028 = -870136511;    long QRKjTmOvKMiMsVDUqoPhSVcLp28167545 = -469929142;    long QRKjTmOvKMiMsVDUqoPhSVcLp71292378 = -34851437;    long QRKjTmOvKMiMsVDUqoPhSVcLp28063451 = -699909857;    long QRKjTmOvKMiMsVDUqoPhSVcLp30812852 = -7179667;    long QRKjTmOvKMiMsVDUqoPhSVcLp56007399 = -622224058;    long QRKjTmOvKMiMsVDUqoPhSVcLp21545364 = 28336526;    long QRKjTmOvKMiMsVDUqoPhSVcLp13435109 = 31614133;    long QRKjTmOvKMiMsVDUqoPhSVcLp78817280 = -778882709;    long QRKjTmOvKMiMsVDUqoPhSVcLp76232296 = -142773258;    long QRKjTmOvKMiMsVDUqoPhSVcLp47990990 = -929171665;    long QRKjTmOvKMiMsVDUqoPhSVcLp74727971 = -300770695;    long QRKjTmOvKMiMsVDUqoPhSVcLp16290511 = -191048051;    long QRKjTmOvKMiMsVDUqoPhSVcLp12005452 = 85115931;    long QRKjTmOvKMiMsVDUqoPhSVcLp79239477 = -154281093;    long QRKjTmOvKMiMsVDUqoPhSVcLp10662051 = -88419186;    long QRKjTmOvKMiMsVDUqoPhSVcLp88279764 = -470874046;    long QRKjTmOvKMiMsVDUqoPhSVcLp84186977 = 15935170;    long QRKjTmOvKMiMsVDUqoPhSVcLp70181191 = -722551027;    long QRKjTmOvKMiMsVDUqoPhSVcLp43876344 = 94843135;    long QRKjTmOvKMiMsVDUqoPhSVcLp72620788 = -342381910;    long QRKjTmOvKMiMsVDUqoPhSVcLp99177997 = -878888195;    long QRKjTmOvKMiMsVDUqoPhSVcLp80767999 = -618484462;    long QRKjTmOvKMiMsVDUqoPhSVcLp21500728 = -550374327;    long QRKjTmOvKMiMsVDUqoPhSVcLp82921168 = -567524877;    long QRKjTmOvKMiMsVDUqoPhSVcLp82203721 = -605998172;    long QRKjTmOvKMiMsVDUqoPhSVcLp60374718 = -925658184;    long QRKjTmOvKMiMsVDUqoPhSVcLp93150926 = -726243568;    long QRKjTmOvKMiMsVDUqoPhSVcLp4839067 = -227501558;    long QRKjTmOvKMiMsVDUqoPhSVcLp81442914 = -809577363;    long QRKjTmOvKMiMsVDUqoPhSVcLp50209320 = -638057581;    long QRKjTmOvKMiMsVDUqoPhSVcLp2189226 = -432503963;    long QRKjTmOvKMiMsVDUqoPhSVcLp50107953 = -857863873;    long QRKjTmOvKMiMsVDUqoPhSVcLp54000642 = -155176177;    long QRKjTmOvKMiMsVDUqoPhSVcLp52133210 = -618414321;    long QRKjTmOvKMiMsVDUqoPhSVcLp93661551 = -741089333;    long QRKjTmOvKMiMsVDUqoPhSVcLp12317677 = -724769884;    long QRKjTmOvKMiMsVDUqoPhSVcLp13331850 = -416877288;    long QRKjTmOvKMiMsVDUqoPhSVcLp53954580 = -714199043;    long QRKjTmOvKMiMsVDUqoPhSVcLp47793371 = -584106890;    long QRKjTmOvKMiMsVDUqoPhSVcLp27479816 = -636926914;    long QRKjTmOvKMiMsVDUqoPhSVcLp24156487 = 14587184;    long QRKjTmOvKMiMsVDUqoPhSVcLp72480907 = 28591099;    long QRKjTmOvKMiMsVDUqoPhSVcLp96934755 = -453553732;    long QRKjTmOvKMiMsVDUqoPhSVcLp45250163 = -599316314;     QRKjTmOvKMiMsVDUqoPhSVcLp82790213 = QRKjTmOvKMiMsVDUqoPhSVcLp82102596;     QRKjTmOvKMiMsVDUqoPhSVcLp82102596 = QRKjTmOvKMiMsVDUqoPhSVcLp86034258;     QRKjTmOvKMiMsVDUqoPhSVcLp86034258 = QRKjTmOvKMiMsVDUqoPhSVcLp22138380;     QRKjTmOvKMiMsVDUqoPhSVcLp22138380 = QRKjTmOvKMiMsVDUqoPhSVcLp39785211;     QRKjTmOvKMiMsVDUqoPhSVcLp39785211 = QRKjTmOvKMiMsVDUqoPhSVcLp76000589;     QRKjTmOvKMiMsVDUqoPhSVcLp76000589 = QRKjTmOvKMiMsVDUqoPhSVcLp6794617;     QRKjTmOvKMiMsVDUqoPhSVcLp6794617 = QRKjTmOvKMiMsVDUqoPhSVcLp17536995;     QRKjTmOvKMiMsVDUqoPhSVcLp17536995 = QRKjTmOvKMiMsVDUqoPhSVcLp57831141;     QRKjTmOvKMiMsVDUqoPhSVcLp57831141 = QRKjTmOvKMiMsVDUqoPhSVcLp34346130;     QRKjTmOvKMiMsVDUqoPhSVcLp34346130 = QRKjTmOvKMiMsVDUqoPhSVcLp36532329;     QRKjTmOvKMiMsVDUqoPhSVcLp36532329 = QRKjTmOvKMiMsVDUqoPhSVcLp5210368;     QRKjTmOvKMiMsVDUqoPhSVcLp5210368 = QRKjTmOvKMiMsVDUqoPhSVcLp69305946;     QRKjTmOvKMiMsVDUqoPhSVcLp69305946 = QRKjTmOvKMiMsVDUqoPhSVcLp96452689;     QRKjTmOvKMiMsVDUqoPhSVcLp96452689 = QRKjTmOvKMiMsVDUqoPhSVcLp1068574;     QRKjTmOvKMiMsVDUqoPhSVcLp1068574 = QRKjTmOvKMiMsVDUqoPhSVcLp94272105;     QRKjTmOvKMiMsVDUqoPhSVcLp94272105 = QRKjTmOvKMiMsVDUqoPhSVcLp29675065;     QRKjTmOvKMiMsVDUqoPhSVcLp29675065 = QRKjTmOvKMiMsVDUqoPhSVcLp68954408;     QRKjTmOvKMiMsVDUqoPhSVcLp68954408 = QRKjTmOvKMiMsVDUqoPhSVcLp73981961;     QRKjTmOvKMiMsVDUqoPhSVcLp73981961 = QRKjTmOvKMiMsVDUqoPhSVcLp92901523;     QRKjTmOvKMiMsVDUqoPhSVcLp92901523 = QRKjTmOvKMiMsVDUqoPhSVcLp10212384;     QRKjTmOvKMiMsVDUqoPhSVcLp10212384 = QRKjTmOvKMiMsVDUqoPhSVcLp50476186;     QRKjTmOvKMiMsVDUqoPhSVcLp50476186 = QRKjTmOvKMiMsVDUqoPhSVcLp53935052;     QRKjTmOvKMiMsVDUqoPhSVcLp53935052 = QRKjTmOvKMiMsVDUqoPhSVcLp14741881;     QRKjTmOvKMiMsVDUqoPhSVcLp14741881 = QRKjTmOvKMiMsVDUqoPhSVcLp94074929;     QRKjTmOvKMiMsVDUqoPhSVcLp94074929 = QRKjTmOvKMiMsVDUqoPhSVcLp8972360;     QRKjTmOvKMiMsVDUqoPhSVcLp8972360 = QRKjTmOvKMiMsVDUqoPhSVcLp19993190;     QRKjTmOvKMiMsVDUqoPhSVcLp19993190 = QRKjTmOvKMiMsVDUqoPhSVcLp85249253;     QRKjTmOvKMiMsVDUqoPhSVcLp85249253 = QRKjTmOvKMiMsVDUqoPhSVcLp4101886;     QRKjTmOvKMiMsVDUqoPhSVcLp4101886 = QRKjTmOvKMiMsVDUqoPhSVcLp79013860;     QRKjTmOvKMiMsVDUqoPhSVcLp79013860 = QRKjTmOvKMiMsVDUqoPhSVcLp58113834;     QRKjTmOvKMiMsVDUqoPhSVcLp58113834 = QRKjTmOvKMiMsVDUqoPhSVcLp88541339;     QRKjTmOvKMiMsVDUqoPhSVcLp88541339 = QRKjTmOvKMiMsVDUqoPhSVcLp30482397;     QRKjTmOvKMiMsVDUqoPhSVcLp30482397 = QRKjTmOvKMiMsVDUqoPhSVcLp53015435;     QRKjTmOvKMiMsVDUqoPhSVcLp53015435 = QRKjTmOvKMiMsVDUqoPhSVcLp84447238;     QRKjTmOvKMiMsVDUqoPhSVcLp84447238 = QRKjTmOvKMiMsVDUqoPhSVcLp21829096;     QRKjTmOvKMiMsVDUqoPhSVcLp21829096 = QRKjTmOvKMiMsVDUqoPhSVcLp83610055;     QRKjTmOvKMiMsVDUqoPhSVcLp83610055 = QRKjTmOvKMiMsVDUqoPhSVcLp41395300;     QRKjTmOvKMiMsVDUqoPhSVcLp41395300 = QRKjTmOvKMiMsVDUqoPhSVcLp84767431;     QRKjTmOvKMiMsVDUqoPhSVcLp84767431 = QRKjTmOvKMiMsVDUqoPhSVcLp3800770;     QRKjTmOvKMiMsVDUqoPhSVcLp3800770 = QRKjTmOvKMiMsVDUqoPhSVcLp49025180;     QRKjTmOvKMiMsVDUqoPhSVcLp49025180 = QRKjTmOvKMiMsVDUqoPhSVcLp37591596;     QRKjTmOvKMiMsVDUqoPhSVcLp37591596 = QRKjTmOvKMiMsVDUqoPhSVcLp51298188;     QRKjTmOvKMiMsVDUqoPhSVcLp51298188 = QRKjTmOvKMiMsVDUqoPhSVcLp73167052;     QRKjTmOvKMiMsVDUqoPhSVcLp73167052 = QRKjTmOvKMiMsVDUqoPhSVcLp93241152;     QRKjTmOvKMiMsVDUqoPhSVcLp93241152 = QRKjTmOvKMiMsVDUqoPhSVcLp11153761;     QRKjTmOvKMiMsVDUqoPhSVcLp11153761 = QRKjTmOvKMiMsVDUqoPhSVcLp26768639;     QRKjTmOvKMiMsVDUqoPhSVcLp26768639 = QRKjTmOvKMiMsVDUqoPhSVcLp59618472;     QRKjTmOvKMiMsVDUqoPhSVcLp59618472 = QRKjTmOvKMiMsVDUqoPhSVcLp92098326;     QRKjTmOvKMiMsVDUqoPhSVcLp92098326 = QRKjTmOvKMiMsVDUqoPhSVcLp99262818;     QRKjTmOvKMiMsVDUqoPhSVcLp99262818 = QRKjTmOvKMiMsVDUqoPhSVcLp97570946;     QRKjTmOvKMiMsVDUqoPhSVcLp97570946 = QRKjTmOvKMiMsVDUqoPhSVcLp7904514;     QRKjTmOvKMiMsVDUqoPhSVcLp7904514 = QRKjTmOvKMiMsVDUqoPhSVcLp86352114;     QRKjTmOvKMiMsVDUqoPhSVcLp86352114 = QRKjTmOvKMiMsVDUqoPhSVcLp80374443;     QRKjTmOvKMiMsVDUqoPhSVcLp80374443 = QRKjTmOvKMiMsVDUqoPhSVcLp99014792;     QRKjTmOvKMiMsVDUqoPhSVcLp99014792 = QRKjTmOvKMiMsVDUqoPhSVcLp32314028;     QRKjTmOvKMiMsVDUqoPhSVcLp32314028 = QRKjTmOvKMiMsVDUqoPhSVcLp28167545;     QRKjTmOvKMiMsVDUqoPhSVcLp28167545 = QRKjTmOvKMiMsVDUqoPhSVcLp71292378;     QRKjTmOvKMiMsVDUqoPhSVcLp71292378 = QRKjTmOvKMiMsVDUqoPhSVcLp28063451;     QRKjTmOvKMiMsVDUqoPhSVcLp28063451 = QRKjTmOvKMiMsVDUqoPhSVcLp30812852;     QRKjTmOvKMiMsVDUqoPhSVcLp30812852 = QRKjTmOvKMiMsVDUqoPhSVcLp56007399;     QRKjTmOvKMiMsVDUqoPhSVcLp56007399 = QRKjTmOvKMiMsVDUqoPhSVcLp21545364;     QRKjTmOvKMiMsVDUqoPhSVcLp21545364 = QRKjTmOvKMiMsVDUqoPhSVcLp13435109;     QRKjTmOvKMiMsVDUqoPhSVcLp13435109 = QRKjTmOvKMiMsVDUqoPhSVcLp78817280;     QRKjTmOvKMiMsVDUqoPhSVcLp78817280 = QRKjTmOvKMiMsVDUqoPhSVcLp76232296;     QRKjTmOvKMiMsVDUqoPhSVcLp76232296 = QRKjTmOvKMiMsVDUqoPhSVcLp47990990;     QRKjTmOvKMiMsVDUqoPhSVcLp47990990 = QRKjTmOvKMiMsVDUqoPhSVcLp74727971;     QRKjTmOvKMiMsVDUqoPhSVcLp74727971 = QRKjTmOvKMiMsVDUqoPhSVcLp16290511;     QRKjTmOvKMiMsVDUqoPhSVcLp16290511 = QRKjTmOvKMiMsVDUqoPhSVcLp12005452;     QRKjTmOvKMiMsVDUqoPhSVcLp12005452 = QRKjTmOvKMiMsVDUqoPhSVcLp79239477;     QRKjTmOvKMiMsVDUqoPhSVcLp79239477 = QRKjTmOvKMiMsVDUqoPhSVcLp10662051;     QRKjTmOvKMiMsVDUqoPhSVcLp10662051 = QRKjTmOvKMiMsVDUqoPhSVcLp88279764;     QRKjTmOvKMiMsVDUqoPhSVcLp88279764 = QRKjTmOvKMiMsVDUqoPhSVcLp84186977;     QRKjTmOvKMiMsVDUqoPhSVcLp84186977 = QRKjTmOvKMiMsVDUqoPhSVcLp70181191;     QRKjTmOvKMiMsVDUqoPhSVcLp70181191 = QRKjTmOvKMiMsVDUqoPhSVcLp43876344;     QRKjTmOvKMiMsVDUqoPhSVcLp43876344 = QRKjTmOvKMiMsVDUqoPhSVcLp72620788;     QRKjTmOvKMiMsVDUqoPhSVcLp72620788 = QRKjTmOvKMiMsVDUqoPhSVcLp99177997;     QRKjTmOvKMiMsVDUqoPhSVcLp99177997 = QRKjTmOvKMiMsVDUqoPhSVcLp80767999;     QRKjTmOvKMiMsVDUqoPhSVcLp80767999 = QRKjTmOvKMiMsVDUqoPhSVcLp21500728;     QRKjTmOvKMiMsVDUqoPhSVcLp21500728 = QRKjTmOvKMiMsVDUqoPhSVcLp82921168;     QRKjTmOvKMiMsVDUqoPhSVcLp82921168 = QRKjTmOvKMiMsVDUqoPhSVcLp82203721;     QRKjTmOvKMiMsVDUqoPhSVcLp82203721 = QRKjTmOvKMiMsVDUqoPhSVcLp60374718;     QRKjTmOvKMiMsVDUqoPhSVcLp60374718 = QRKjTmOvKMiMsVDUqoPhSVcLp93150926;     QRKjTmOvKMiMsVDUqoPhSVcLp93150926 = QRKjTmOvKMiMsVDUqoPhSVcLp4839067;     QRKjTmOvKMiMsVDUqoPhSVcLp4839067 = QRKjTmOvKMiMsVDUqoPhSVcLp81442914;     QRKjTmOvKMiMsVDUqoPhSVcLp81442914 = QRKjTmOvKMiMsVDUqoPhSVcLp50209320;     QRKjTmOvKMiMsVDUqoPhSVcLp50209320 = QRKjTmOvKMiMsVDUqoPhSVcLp2189226;     QRKjTmOvKMiMsVDUqoPhSVcLp2189226 = QRKjTmOvKMiMsVDUqoPhSVcLp50107953;     QRKjTmOvKMiMsVDUqoPhSVcLp50107953 = QRKjTmOvKMiMsVDUqoPhSVcLp54000642;     QRKjTmOvKMiMsVDUqoPhSVcLp54000642 = QRKjTmOvKMiMsVDUqoPhSVcLp52133210;     QRKjTmOvKMiMsVDUqoPhSVcLp52133210 = QRKjTmOvKMiMsVDUqoPhSVcLp93661551;     QRKjTmOvKMiMsVDUqoPhSVcLp93661551 = QRKjTmOvKMiMsVDUqoPhSVcLp12317677;     QRKjTmOvKMiMsVDUqoPhSVcLp12317677 = QRKjTmOvKMiMsVDUqoPhSVcLp13331850;     QRKjTmOvKMiMsVDUqoPhSVcLp13331850 = QRKjTmOvKMiMsVDUqoPhSVcLp53954580;     QRKjTmOvKMiMsVDUqoPhSVcLp53954580 = QRKjTmOvKMiMsVDUqoPhSVcLp47793371;     QRKjTmOvKMiMsVDUqoPhSVcLp47793371 = QRKjTmOvKMiMsVDUqoPhSVcLp27479816;     QRKjTmOvKMiMsVDUqoPhSVcLp27479816 = QRKjTmOvKMiMsVDUqoPhSVcLp24156487;     QRKjTmOvKMiMsVDUqoPhSVcLp24156487 = QRKjTmOvKMiMsVDUqoPhSVcLp72480907;     QRKjTmOvKMiMsVDUqoPhSVcLp72480907 = QRKjTmOvKMiMsVDUqoPhSVcLp96934755;     QRKjTmOvKMiMsVDUqoPhSVcLp96934755 = QRKjTmOvKMiMsVDUqoPhSVcLp45250163;     QRKjTmOvKMiMsVDUqoPhSVcLp45250163 = QRKjTmOvKMiMsVDUqoPhSVcLp82790213;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void QTUoyvPnUiWGIsOvzzSuijtsfvxBIWeLKkufuRtByarFpqkOLNQLwsQha24276244() {     long cJDxNfxDKvXxjBhGRvHrnCoKi88907320 = -711218203;    long cJDxNfxDKvXxjBhGRvHrnCoKi25475876 = -594340373;    long cJDxNfxDKvXxjBhGRvHrnCoKi2076443 = -627089702;    long cJDxNfxDKvXxjBhGRvHrnCoKi49213161 = 50698705;    long cJDxNfxDKvXxjBhGRvHrnCoKi8680700 = -546041425;    long cJDxNfxDKvXxjBhGRvHrnCoKi67417791 = -62293232;    long cJDxNfxDKvXxjBhGRvHrnCoKi67283583 = -878072076;    long cJDxNfxDKvXxjBhGRvHrnCoKi67296885 = -8993755;    long cJDxNfxDKvXxjBhGRvHrnCoKi22473637 = -366553571;    long cJDxNfxDKvXxjBhGRvHrnCoKi75575789 = 61358577;    long cJDxNfxDKvXxjBhGRvHrnCoKi96642619 = -512941258;    long cJDxNfxDKvXxjBhGRvHrnCoKi37033410 = -923011209;    long cJDxNfxDKvXxjBhGRvHrnCoKi55515064 = -892182930;    long cJDxNfxDKvXxjBhGRvHrnCoKi79596366 = 64326533;    long cJDxNfxDKvXxjBhGRvHrnCoKi96811000 = -55761734;    long cJDxNfxDKvXxjBhGRvHrnCoKi35777500 = 78959950;    long cJDxNfxDKvXxjBhGRvHrnCoKi23511068 = -204206302;    long cJDxNfxDKvXxjBhGRvHrnCoKi66007561 = -570966183;    long cJDxNfxDKvXxjBhGRvHrnCoKi35811803 = -334651070;    long cJDxNfxDKvXxjBhGRvHrnCoKi73451688 = 29349829;    long cJDxNfxDKvXxjBhGRvHrnCoKi98765576 = -351668047;    long cJDxNfxDKvXxjBhGRvHrnCoKi36997210 = -637109520;    long cJDxNfxDKvXxjBhGRvHrnCoKi89525843 = -61328937;    long cJDxNfxDKvXxjBhGRvHrnCoKi98734254 = -563710332;    long cJDxNfxDKvXxjBhGRvHrnCoKi37774580 = -431838840;    long cJDxNfxDKvXxjBhGRvHrnCoKi33694035 = -896867210;    long cJDxNfxDKvXxjBhGRvHrnCoKi18452968 = -76235143;    long cJDxNfxDKvXxjBhGRvHrnCoKi98356378 = -733372578;    long cJDxNfxDKvXxjBhGRvHrnCoKi70234141 = -976116680;    long cJDxNfxDKvXxjBhGRvHrnCoKi47629497 = -637109064;    long cJDxNfxDKvXxjBhGRvHrnCoKi50356383 = -380213626;    long cJDxNfxDKvXxjBhGRvHrnCoKi86151961 = -415778822;    long cJDxNfxDKvXxjBhGRvHrnCoKi40193345 = 29552316;    long cJDxNfxDKvXxjBhGRvHrnCoKi47845999 = 87214444;    long cJDxNfxDKvXxjBhGRvHrnCoKi45921890 = -27283937;    long cJDxNfxDKvXxjBhGRvHrnCoKi90555008 = -425044583;    long cJDxNfxDKvXxjBhGRvHrnCoKi64871990 = -813257190;    long cJDxNfxDKvXxjBhGRvHrnCoKi75485512 = -988293154;    long cJDxNfxDKvXxjBhGRvHrnCoKi58377685 = -815302207;    long cJDxNfxDKvXxjBhGRvHrnCoKi91302707 = -679770170;    long cJDxNfxDKvXxjBhGRvHrnCoKi54694404 = -773864282;    long cJDxNfxDKvXxjBhGRvHrnCoKi69742052 = -323940961;    long cJDxNfxDKvXxjBhGRvHrnCoKi29365166 = -931096193;    long cJDxNfxDKvXxjBhGRvHrnCoKi60574792 = -715669927;    long cJDxNfxDKvXxjBhGRvHrnCoKi5193618 = -452929172;    long cJDxNfxDKvXxjBhGRvHrnCoKi23092956 = -476334048;    long cJDxNfxDKvXxjBhGRvHrnCoKi44547213 = -430989253;    long cJDxNfxDKvXxjBhGRvHrnCoKi67575412 = -259810288;    long cJDxNfxDKvXxjBhGRvHrnCoKi1774056 = 73062955;    long cJDxNfxDKvXxjBhGRvHrnCoKi12174472 = -513243226;    long cJDxNfxDKvXxjBhGRvHrnCoKi33271625 = -852354505;    long cJDxNfxDKvXxjBhGRvHrnCoKi18714234 = -629561428;    long cJDxNfxDKvXxjBhGRvHrnCoKi34600572 = 34382368;    long cJDxNfxDKvXxjBhGRvHrnCoKi76343323 = -540440586;    long cJDxNfxDKvXxjBhGRvHrnCoKi25510668 = -606599397;    long cJDxNfxDKvXxjBhGRvHrnCoKi51910111 = 25891317;    long cJDxNfxDKvXxjBhGRvHrnCoKi35950032 = -433011436;    long cJDxNfxDKvXxjBhGRvHrnCoKi3342189 = 36620630;    long cJDxNfxDKvXxjBhGRvHrnCoKi11438582 = -517462455;    long cJDxNfxDKvXxjBhGRvHrnCoKi74986664 = -649174215;    long cJDxNfxDKvXxjBhGRvHrnCoKi48964824 = -986058090;    long cJDxNfxDKvXxjBhGRvHrnCoKi68927204 = -44699498;    long cJDxNfxDKvXxjBhGRvHrnCoKi97062744 = -32877075;    long cJDxNfxDKvXxjBhGRvHrnCoKi74844139 = -729444508;    long cJDxNfxDKvXxjBhGRvHrnCoKi25219407 = -558427797;    long cJDxNfxDKvXxjBhGRvHrnCoKi10490658 = 2837564;    long cJDxNfxDKvXxjBhGRvHrnCoKi96840065 = -852563526;    long cJDxNfxDKvXxjBhGRvHrnCoKi7669065 = -879397374;    long cJDxNfxDKvXxjBhGRvHrnCoKi33674476 = -908389531;    long cJDxNfxDKvXxjBhGRvHrnCoKi6255992 = -630717152;    long cJDxNfxDKvXxjBhGRvHrnCoKi70905510 = -107782860;    long cJDxNfxDKvXxjBhGRvHrnCoKi48025555 = -215913149;    long cJDxNfxDKvXxjBhGRvHrnCoKi7629877 = -755663976;    long cJDxNfxDKvXxjBhGRvHrnCoKi44509095 = -654880901;    long cJDxNfxDKvXxjBhGRvHrnCoKi18757285 = -196785890;    long cJDxNfxDKvXxjBhGRvHrnCoKi29023524 = 72272913;    long cJDxNfxDKvXxjBhGRvHrnCoKi7632044 = -706013327;    long cJDxNfxDKvXxjBhGRvHrnCoKi28951051 = -345659011;    long cJDxNfxDKvXxjBhGRvHrnCoKi93540636 = -10781160;    long cJDxNfxDKvXxjBhGRvHrnCoKi14681624 = -955504793;    long cJDxNfxDKvXxjBhGRvHrnCoKi89146822 = -365877958;    long cJDxNfxDKvXxjBhGRvHrnCoKi50877555 = -816424855;    long cJDxNfxDKvXxjBhGRvHrnCoKi96582322 = -706435534;    long cJDxNfxDKvXxjBhGRvHrnCoKi58059670 = -362873454;    long cJDxNfxDKvXxjBhGRvHrnCoKi14357873 = -784754560;    long cJDxNfxDKvXxjBhGRvHrnCoKi31642150 = -750652199;    long cJDxNfxDKvXxjBhGRvHrnCoKi51551390 = -350161191;    long cJDxNfxDKvXxjBhGRvHrnCoKi63850021 = -430007098;    long cJDxNfxDKvXxjBhGRvHrnCoKi22335332 = -306186160;    long cJDxNfxDKvXxjBhGRvHrnCoKi94011779 = 46824746;    long cJDxNfxDKvXxjBhGRvHrnCoKi54604977 = -992033147;    long cJDxNfxDKvXxjBhGRvHrnCoKi61529801 = -749877821;    long cJDxNfxDKvXxjBhGRvHrnCoKi64046931 = -370830700;    long cJDxNfxDKvXxjBhGRvHrnCoKi83391020 = -66127992;    long cJDxNfxDKvXxjBhGRvHrnCoKi42337884 = -693712081;    long cJDxNfxDKvXxjBhGRvHrnCoKi85767199 = -629164784;    long cJDxNfxDKvXxjBhGRvHrnCoKi72679308 = -191063886;    long cJDxNfxDKvXxjBhGRvHrnCoKi54521027 = -101651686;    long cJDxNfxDKvXxjBhGRvHrnCoKi35355386 = -57242130;    long cJDxNfxDKvXxjBhGRvHrnCoKi94702959 = -711218203;     cJDxNfxDKvXxjBhGRvHrnCoKi88907320 = cJDxNfxDKvXxjBhGRvHrnCoKi25475876;     cJDxNfxDKvXxjBhGRvHrnCoKi25475876 = cJDxNfxDKvXxjBhGRvHrnCoKi2076443;     cJDxNfxDKvXxjBhGRvHrnCoKi2076443 = cJDxNfxDKvXxjBhGRvHrnCoKi49213161;     cJDxNfxDKvXxjBhGRvHrnCoKi49213161 = cJDxNfxDKvXxjBhGRvHrnCoKi8680700;     cJDxNfxDKvXxjBhGRvHrnCoKi8680700 = cJDxNfxDKvXxjBhGRvHrnCoKi67417791;     cJDxNfxDKvXxjBhGRvHrnCoKi67417791 = cJDxNfxDKvXxjBhGRvHrnCoKi67283583;     cJDxNfxDKvXxjBhGRvHrnCoKi67283583 = cJDxNfxDKvXxjBhGRvHrnCoKi67296885;     cJDxNfxDKvXxjBhGRvHrnCoKi67296885 = cJDxNfxDKvXxjBhGRvHrnCoKi22473637;     cJDxNfxDKvXxjBhGRvHrnCoKi22473637 = cJDxNfxDKvXxjBhGRvHrnCoKi75575789;     cJDxNfxDKvXxjBhGRvHrnCoKi75575789 = cJDxNfxDKvXxjBhGRvHrnCoKi96642619;     cJDxNfxDKvXxjBhGRvHrnCoKi96642619 = cJDxNfxDKvXxjBhGRvHrnCoKi37033410;     cJDxNfxDKvXxjBhGRvHrnCoKi37033410 = cJDxNfxDKvXxjBhGRvHrnCoKi55515064;     cJDxNfxDKvXxjBhGRvHrnCoKi55515064 = cJDxNfxDKvXxjBhGRvHrnCoKi79596366;     cJDxNfxDKvXxjBhGRvHrnCoKi79596366 = cJDxNfxDKvXxjBhGRvHrnCoKi96811000;     cJDxNfxDKvXxjBhGRvHrnCoKi96811000 = cJDxNfxDKvXxjBhGRvHrnCoKi35777500;     cJDxNfxDKvXxjBhGRvHrnCoKi35777500 = cJDxNfxDKvXxjBhGRvHrnCoKi23511068;     cJDxNfxDKvXxjBhGRvHrnCoKi23511068 = cJDxNfxDKvXxjBhGRvHrnCoKi66007561;     cJDxNfxDKvXxjBhGRvHrnCoKi66007561 = cJDxNfxDKvXxjBhGRvHrnCoKi35811803;     cJDxNfxDKvXxjBhGRvHrnCoKi35811803 = cJDxNfxDKvXxjBhGRvHrnCoKi73451688;     cJDxNfxDKvXxjBhGRvHrnCoKi73451688 = cJDxNfxDKvXxjBhGRvHrnCoKi98765576;     cJDxNfxDKvXxjBhGRvHrnCoKi98765576 = cJDxNfxDKvXxjBhGRvHrnCoKi36997210;     cJDxNfxDKvXxjBhGRvHrnCoKi36997210 = cJDxNfxDKvXxjBhGRvHrnCoKi89525843;     cJDxNfxDKvXxjBhGRvHrnCoKi89525843 = cJDxNfxDKvXxjBhGRvHrnCoKi98734254;     cJDxNfxDKvXxjBhGRvHrnCoKi98734254 = cJDxNfxDKvXxjBhGRvHrnCoKi37774580;     cJDxNfxDKvXxjBhGRvHrnCoKi37774580 = cJDxNfxDKvXxjBhGRvHrnCoKi33694035;     cJDxNfxDKvXxjBhGRvHrnCoKi33694035 = cJDxNfxDKvXxjBhGRvHrnCoKi18452968;     cJDxNfxDKvXxjBhGRvHrnCoKi18452968 = cJDxNfxDKvXxjBhGRvHrnCoKi98356378;     cJDxNfxDKvXxjBhGRvHrnCoKi98356378 = cJDxNfxDKvXxjBhGRvHrnCoKi70234141;     cJDxNfxDKvXxjBhGRvHrnCoKi70234141 = cJDxNfxDKvXxjBhGRvHrnCoKi47629497;     cJDxNfxDKvXxjBhGRvHrnCoKi47629497 = cJDxNfxDKvXxjBhGRvHrnCoKi50356383;     cJDxNfxDKvXxjBhGRvHrnCoKi50356383 = cJDxNfxDKvXxjBhGRvHrnCoKi86151961;     cJDxNfxDKvXxjBhGRvHrnCoKi86151961 = cJDxNfxDKvXxjBhGRvHrnCoKi40193345;     cJDxNfxDKvXxjBhGRvHrnCoKi40193345 = cJDxNfxDKvXxjBhGRvHrnCoKi47845999;     cJDxNfxDKvXxjBhGRvHrnCoKi47845999 = cJDxNfxDKvXxjBhGRvHrnCoKi45921890;     cJDxNfxDKvXxjBhGRvHrnCoKi45921890 = cJDxNfxDKvXxjBhGRvHrnCoKi90555008;     cJDxNfxDKvXxjBhGRvHrnCoKi90555008 = cJDxNfxDKvXxjBhGRvHrnCoKi64871990;     cJDxNfxDKvXxjBhGRvHrnCoKi64871990 = cJDxNfxDKvXxjBhGRvHrnCoKi75485512;     cJDxNfxDKvXxjBhGRvHrnCoKi75485512 = cJDxNfxDKvXxjBhGRvHrnCoKi58377685;     cJDxNfxDKvXxjBhGRvHrnCoKi58377685 = cJDxNfxDKvXxjBhGRvHrnCoKi91302707;     cJDxNfxDKvXxjBhGRvHrnCoKi91302707 = cJDxNfxDKvXxjBhGRvHrnCoKi54694404;     cJDxNfxDKvXxjBhGRvHrnCoKi54694404 = cJDxNfxDKvXxjBhGRvHrnCoKi69742052;     cJDxNfxDKvXxjBhGRvHrnCoKi69742052 = cJDxNfxDKvXxjBhGRvHrnCoKi29365166;     cJDxNfxDKvXxjBhGRvHrnCoKi29365166 = cJDxNfxDKvXxjBhGRvHrnCoKi60574792;     cJDxNfxDKvXxjBhGRvHrnCoKi60574792 = cJDxNfxDKvXxjBhGRvHrnCoKi5193618;     cJDxNfxDKvXxjBhGRvHrnCoKi5193618 = cJDxNfxDKvXxjBhGRvHrnCoKi23092956;     cJDxNfxDKvXxjBhGRvHrnCoKi23092956 = cJDxNfxDKvXxjBhGRvHrnCoKi44547213;     cJDxNfxDKvXxjBhGRvHrnCoKi44547213 = cJDxNfxDKvXxjBhGRvHrnCoKi67575412;     cJDxNfxDKvXxjBhGRvHrnCoKi67575412 = cJDxNfxDKvXxjBhGRvHrnCoKi1774056;     cJDxNfxDKvXxjBhGRvHrnCoKi1774056 = cJDxNfxDKvXxjBhGRvHrnCoKi12174472;     cJDxNfxDKvXxjBhGRvHrnCoKi12174472 = cJDxNfxDKvXxjBhGRvHrnCoKi33271625;     cJDxNfxDKvXxjBhGRvHrnCoKi33271625 = cJDxNfxDKvXxjBhGRvHrnCoKi18714234;     cJDxNfxDKvXxjBhGRvHrnCoKi18714234 = cJDxNfxDKvXxjBhGRvHrnCoKi34600572;     cJDxNfxDKvXxjBhGRvHrnCoKi34600572 = cJDxNfxDKvXxjBhGRvHrnCoKi76343323;     cJDxNfxDKvXxjBhGRvHrnCoKi76343323 = cJDxNfxDKvXxjBhGRvHrnCoKi25510668;     cJDxNfxDKvXxjBhGRvHrnCoKi25510668 = cJDxNfxDKvXxjBhGRvHrnCoKi51910111;     cJDxNfxDKvXxjBhGRvHrnCoKi51910111 = cJDxNfxDKvXxjBhGRvHrnCoKi35950032;     cJDxNfxDKvXxjBhGRvHrnCoKi35950032 = cJDxNfxDKvXxjBhGRvHrnCoKi3342189;     cJDxNfxDKvXxjBhGRvHrnCoKi3342189 = cJDxNfxDKvXxjBhGRvHrnCoKi11438582;     cJDxNfxDKvXxjBhGRvHrnCoKi11438582 = cJDxNfxDKvXxjBhGRvHrnCoKi74986664;     cJDxNfxDKvXxjBhGRvHrnCoKi74986664 = cJDxNfxDKvXxjBhGRvHrnCoKi48964824;     cJDxNfxDKvXxjBhGRvHrnCoKi48964824 = cJDxNfxDKvXxjBhGRvHrnCoKi68927204;     cJDxNfxDKvXxjBhGRvHrnCoKi68927204 = cJDxNfxDKvXxjBhGRvHrnCoKi97062744;     cJDxNfxDKvXxjBhGRvHrnCoKi97062744 = cJDxNfxDKvXxjBhGRvHrnCoKi74844139;     cJDxNfxDKvXxjBhGRvHrnCoKi74844139 = cJDxNfxDKvXxjBhGRvHrnCoKi25219407;     cJDxNfxDKvXxjBhGRvHrnCoKi25219407 = cJDxNfxDKvXxjBhGRvHrnCoKi10490658;     cJDxNfxDKvXxjBhGRvHrnCoKi10490658 = cJDxNfxDKvXxjBhGRvHrnCoKi96840065;     cJDxNfxDKvXxjBhGRvHrnCoKi96840065 = cJDxNfxDKvXxjBhGRvHrnCoKi7669065;     cJDxNfxDKvXxjBhGRvHrnCoKi7669065 = cJDxNfxDKvXxjBhGRvHrnCoKi33674476;     cJDxNfxDKvXxjBhGRvHrnCoKi33674476 = cJDxNfxDKvXxjBhGRvHrnCoKi6255992;     cJDxNfxDKvXxjBhGRvHrnCoKi6255992 = cJDxNfxDKvXxjBhGRvHrnCoKi70905510;     cJDxNfxDKvXxjBhGRvHrnCoKi70905510 = cJDxNfxDKvXxjBhGRvHrnCoKi48025555;     cJDxNfxDKvXxjBhGRvHrnCoKi48025555 = cJDxNfxDKvXxjBhGRvHrnCoKi7629877;     cJDxNfxDKvXxjBhGRvHrnCoKi7629877 = cJDxNfxDKvXxjBhGRvHrnCoKi44509095;     cJDxNfxDKvXxjBhGRvHrnCoKi44509095 = cJDxNfxDKvXxjBhGRvHrnCoKi18757285;     cJDxNfxDKvXxjBhGRvHrnCoKi18757285 = cJDxNfxDKvXxjBhGRvHrnCoKi29023524;     cJDxNfxDKvXxjBhGRvHrnCoKi29023524 = cJDxNfxDKvXxjBhGRvHrnCoKi7632044;     cJDxNfxDKvXxjBhGRvHrnCoKi7632044 = cJDxNfxDKvXxjBhGRvHrnCoKi28951051;     cJDxNfxDKvXxjBhGRvHrnCoKi28951051 = cJDxNfxDKvXxjBhGRvHrnCoKi93540636;     cJDxNfxDKvXxjBhGRvHrnCoKi93540636 = cJDxNfxDKvXxjBhGRvHrnCoKi14681624;     cJDxNfxDKvXxjBhGRvHrnCoKi14681624 = cJDxNfxDKvXxjBhGRvHrnCoKi89146822;     cJDxNfxDKvXxjBhGRvHrnCoKi89146822 = cJDxNfxDKvXxjBhGRvHrnCoKi50877555;     cJDxNfxDKvXxjBhGRvHrnCoKi50877555 = cJDxNfxDKvXxjBhGRvHrnCoKi96582322;     cJDxNfxDKvXxjBhGRvHrnCoKi96582322 = cJDxNfxDKvXxjBhGRvHrnCoKi58059670;     cJDxNfxDKvXxjBhGRvHrnCoKi58059670 = cJDxNfxDKvXxjBhGRvHrnCoKi14357873;     cJDxNfxDKvXxjBhGRvHrnCoKi14357873 = cJDxNfxDKvXxjBhGRvHrnCoKi31642150;     cJDxNfxDKvXxjBhGRvHrnCoKi31642150 = cJDxNfxDKvXxjBhGRvHrnCoKi51551390;     cJDxNfxDKvXxjBhGRvHrnCoKi51551390 = cJDxNfxDKvXxjBhGRvHrnCoKi63850021;     cJDxNfxDKvXxjBhGRvHrnCoKi63850021 = cJDxNfxDKvXxjBhGRvHrnCoKi22335332;     cJDxNfxDKvXxjBhGRvHrnCoKi22335332 = cJDxNfxDKvXxjBhGRvHrnCoKi94011779;     cJDxNfxDKvXxjBhGRvHrnCoKi94011779 = cJDxNfxDKvXxjBhGRvHrnCoKi54604977;     cJDxNfxDKvXxjBhGRvHrnCoKi54604977 = cJDxNfxDKvXxjBhGRvHrnCoKi61529801;     cJDxNfxDKvXxjBhGRvHrnCoKi61529801 = cJDxNfxDKvXxjBhGRvHrnCoKi64046931;     cJDxNfxDKvXxjBhGRvHrnCoKi64046931 = cJDxNfxDKvXxjBhGRvHrnCoKi83391020;     cJDxNfxDKvXxjBhGRvHrnCoKi83391020 = cJDxNfxDKvXxjBhGRvHrnCoKi42337884;     cJDxNfxDKvXxjBhGRvHrnCoKi42337884 = cJDxNfxDKvXxjBhGRvHrnCoKi85767199;     cJDxNfxDKvXxjBhGRvHrnCoKi85767199 = cJDxNfxDKvXxjBhGRvHrnCoKi72679308;     cJDxNfxDKvXxjBhGRvHrnCoKi72679308 = cJDxNfxDKvXxjBhGRvHrnCoKi54521027;     cJDxNfxDKvXxjBhGRvHrnCoKi54521027 = cJDxNfxDKvXxjBhGRvHrnCoKi35355386;     cJDxNfxDKvXxjBhGRvHrnCoKi35355386 = cJDxNfxDKvXxjBhGRvHrnCoKi94702959;     cJDxNfxDKvXxjBhGRvHrnCoKi94702959 = cJDxNfxDKvXxjBhGRvHrnCoKi88907320;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void jTjDreZRgMSnJcsMCqWZgFUYqVInMVEyIWoXKUnvcaNnRFjVNzQZXCzey91567843() {     long LNVVlEKHTennVBiCbwFshGkmm24366289 = -77495102;    long LNVVlEKHTennVBiCbwFshGkmm38747954 = -474891979;    long LNVVlEKHTennVBiCbwFshGkmm39462919 = -292756777;    long LNVVlEKHTennVBiCbwFshGkmm21436516 = -870452366;    long LNVVlEKHTennVBiCbwFshGkmm64965969 = -651640271;    long LNVVlEKHTennVBiCbwFshGkmm3640664 = -324641127;    long LNVVlEKHTennVBiCbwFshGkmm77940989 = -722797810;    long LNVVlEKHTennVBiCbwFshGkmm29428446 = -753227895;    long LNVVlEKHTennVBiCbwFshGkmm23991242 = -854884978;    long LNVVlEKHTennVBiCbwFshGkmm90478501 = -703328421;    long LNVVlEKHTennVBiCbwFshGkmm34824354 = -314948987;    long LNVVlEKHTennVBiCbwFshGkmm37601559 = -787131981;    long LNVVlEKHTennVBiCbwFshGkmm93749709 = -344195435;    long LNVVlEKHTennVBiCbwFshGkmm32737230 = 87963123;    long LNVVlEKHTennVBiCbwFshGkmm55005516 = -559186749;    long LNVVlEKHTennVBiCbwFshGkmm19318801 = -656851657;    long LNVVlEKHTennVBiCbwFshGkmm79347003 = -731180855;    long LNVVlEKHTennVBiCbwFshGkmm65767753 = -644394251;    long LNVVlEKHTennVBiCbwFshGkmm36362133 = -651214492;    long LNVVlEKHTennVBiCbwFshGkmm67288907 = -397211237;    long LNVVlEKHTennVBiCbwFshGkmm11852440 = -8942736;    long LNVVlEKHTennVBiCbwFshGkmm40418734 = -723745814;    long LNVVlEKHTennVBiCbwFshGkmm60051223 = -798961121;    long LNVVlEKHTennVBiCbwFshGkmm92527199 = 25465064;    long LNVVlEKHTennVBiCbwFshGkmm45792531 = -455824039;    long LNVVlEKHTennVBiCbwFshGkmm44392207 = -585444017;    long LNVVlEKHTennVBiCbwFshGkmm78873542 = -982519284;    long LNVVlEKHTennVBiCbwFshGkmm39084803 = -903144753;    long LNVVlEKHTennVBiCbwFshGkmm16902356 = -450211483;    long LNVVlEKHTennVBiCbwFshGkmm53162908 = -671616235;    long LNVVlEKHTennVBiCbwFshGkmm68939614 = -932194113;    long LNVVlEKHTennVBiCbwFshGkmm23974980 = -188750236;    long LNVVlEKHTennVBiCbwFshGkmm52411356 = -118043661;    long LNVVlEKHTennVBiCbwFshGkmm77594426 = 22520630;    long LNVVlEKHTennVBiCbwFshGkmm11730344 = 21615813;    long LNVVlEKHTennVBiCbwFshGkmm42115853 = -639609889;    long LNVVlEKHTennVBiCbwFshGkmm14283807 = -677953231;    long LNVVlEKHTennVBiCbwFshGkmm26700916 = -970948735;    long LNVVlEKHTennVBiCbwFshGkmm88768246 = -466178483;    long LNVVlEKHTennVBiCbwFshGkmm55574240 = -145032716;    long LNVVlEKHTennVBiCbwFshGkmm88146011 = -543063196;    long LNVVlEKHTennVBiCbwFshGkmm59107179 = 81513748;    long LNVVlEKHTennVBiCbwFshGkmm18748545 = -484276979;    long LNVVlEKHTennVBiCbwFshGkmm706131 = -220002337;    long LNVVlEKHTennVBiCbwFshGkmm5210077 = -279440334;    long LNVVlEKHTennVBiCbwFshGkmm69054284 = -515257680;    long LNVVlEKHTennVBiCbwFshGkmm63892376 = -914975614;    long LNVVlEKHTennVBiCbwFshGkmm85301724 = -426336882;    long LNVVlEKHTennVBiCbwFshGkmm24666722 = -690673925;    long LNVVlEKHTennVBiCbwFshGkmm36704061 = 95729958;    long LNVVlEKHTennVBiCbwFshGkmm14042349 = -726631063;    long LNVVlEKHTennVBiCbwFshGkmm2199706 = -843213775;    long LNVVlEKHTennVBiCbwFshGkmm3221721 = -821663186;    long LNVVlEKHTennVBiCbwFshGkmm92335170 = -731949085;    long LNVVlEKHTennVBiCbwFshGkmm79715403 = -953089543;    long LNVVlEKHTennVBiCbwFshGkmm83947554 = -353749289;    long LNVVlEKHTennVBiCbwFshGkmm78696730 = -675930858;    long LNVVlEKHTennVBiCbwFshGkmm46935720 = -218221841;    long LNVVlEKHTennVBiCbwFshGkmm75643985 = -314628328;    long LNVVlEKHTennVBiCbwFshGkmm20573763 = 33803746;    long LNVVlEKHTennVBiCbwFshGkmm24767122 = -342121844;    long LNVVlEKHTennVBiCbwFshGkmm38856186 = -819653058;    long LNVVlEKHTennVBiCbwFshGkmm12526091 = -203016413;    long LNVVlEKHTennVBiCbwFshGkmm70828333 = -83268744;    long LNVVlEKHTennVBiCbwFshGkmm21538887 = -771134308;    long LNVVlEKHTennVBiCbwFshGkmm10849375 = -26198751;    long LNVVlEKHTennVBiCbwFshGkmm85190202 = -569088320;    long LNVVlEKHTennVBiCbwFshGkmm16155284 = -266716066;    long LNVVlEKHTennVBiCbwFshGkmm21006886 = -933652690;    long LNVVlEKHTennVBiCbwFshGkmm12889664 = -919576861;    long LNVVlEKHTennVBiCbwFshGkmm5034995 = -978898427;    long LNVVlEKHTennVBiCbwFshGkmm52646087 = -760232120;    long LNVVlEKHTennVBiCbwFshGkmm76999506 = -78215768;    long LNVVlEKHTennVBiCbwFshGkmm80787892 = -406181776;    long LNVVlEKHTennVBiCbwFshGkmm79142895 = -854148042;    long LNVVlEKHTennVBiCbwFshGkmm52745260 = 9543515;    long LNVVlEKHTennVBiCbwFshGkmm21670190 = -139468835;    long LNVVlEKHTennVBiCbwFshGkmm59345092 = -478958785;    long LNVVlEKHTennVBiCbwFshGkmm87317123 = -695094603;    long LNVVlEKHTennVBiCbwFshGkmm76738246 = -940566359;    long LNVVlEKHTennVBiCbwFshGkmm80499830 = -670468404;    long LNVVlEKHTennVBiCbwFshGkmm93571817 = -456182402;    long LNVVlEKHTennVBiCbwFshGkmm14418082 = -112470828;    long LNVVlEKHTennVBiCbwFshGkmm80198295 = -445941441;    long LNVVlEKHTennVBiCbwFshGkmm39120560 = -944985173;    long LNVVlEKHTennVBiCbwFshGkmm66739909 = 11019661;    long LNVVlEKHTennVBiCbwFshGkmm20753260 = -367087051;    long LNVVlEKHTennVBiCbwFshGkmm60076186 = -386094576;    long LNVVlEKHTennVBiCbwFshGkmm97879022 = -24389827;    long LNVVlEKHTennVBiCbwFshGkmm27782789 = -624634899;    long LNVVlEKHTennVBiCbwFshGkmm63419122 = -963679031;    long LNVVlEKHTennVBiCbwFshGkmm67348086 = -359731390;    long LNVVlEKHTennVBiCbwFshGkmm51056931 = -556320408;    long LNVVlEKHTennVBiCbwFshGkmm68194484 = -399982230;    long LNVVlEKHTennVBiCbwFshGkmm30807119 = -802910872;    long LNVVlEKHTennVBiCbwFshGkmm49289826 = -723410139;    long LNVVlEKHTennVBiCbwFshGkmm46581089 = -715469839;    long LNVVlEKHTennVBiCbwFshGkmm47920211 = -301008236;    long LNVVlEKHTennVBiCbwFshGkmm79167243 = -448868029;    long LNVVlEKHTennVBiCbwFshGkmm94360702 = -77495102;     LNVVlEKHTennVBiCbwFshGkmm24366289 = LNVVlEKHTennVBiCbwFshGkmm38747954;     LNVVlEKHTennVBiCbwFshGkmm38747954 = LNVVlEKHTennVBiCbwFshGkmm39462919;     LNVVlEKHTennVBiCbwFshGkmm39462919 = LNVVlEKHTennVBiCbwFshGkmm21436516;     LNVVlEKHTennVBiCbwFshGkmm21436516 = LNVVlEKHTennVBiCbwFshGkmm64965969;     LNVVlEKHTennVBiCbwFshGkmm64965969 = LNVVlEKHTennVBiCbwFshGkmm3640664;     LNVVlEKHTennVBiCbwFshGkmm3640664 = LNVVlEKHTennVBiCbwFshGkmm77940989;     LNVVlEKHTennVBiCbwFshGkmm77940989 = LNVVlEKHTennVBiCbwFshGkmm29428446;     LNVVlEKHTennVBiCbwFshGkmm29428446 = LNVVlEKHTennVBiCbwFshGkmm23991242;     LNVVlEKHTennVBiCbwFshGkmm23991242 = LNVVlEKHTennVBiCbwFshGkmm90478501;     LNVVlEKHTennVBiCbwFshGkmm90478501 = LNVVlEKHTennVBiCbwFshGkmm34824354;     LNVVlEKHTennVBiCbwFshGkmm34824354 = LNVVlEKHTennVBiCbwFshGkmm37601559;     LNVVlEKHTennVBiCbwFshGkmm37601559 = LNVVlEKHTennVBiCbwFshGkmm93749709;     LNVVlEKHTennVBiCbwFshGkmm93749709 = LNVVlEKHTennVBiCbwFshGkmm32737230;     LNVVlEKHTennVBiCbwFshGkmm32737230 = LNVVlEKHTennVBiCbwFshGkmm55005516;     LNVVlEKHTennVBiCbwFshGkmm55005516 = LNVVlEKHTennVBiCbwFshGkmm19318801;     LNVVlEKHTennVBiCbwFshGkmm19318801 = LNVVlEKHTennVBiCbwFshGkmm79347003;     LNVVlEKHTennVBiCbwFshGkmm79347003 = LNVVlEKHTennVBiCbwFshGkmm65767753;     LNVVlEKHTennVBiCbwFshGkmm65767753 = LNVVlEKHTennVBiCbwFshGkmm36362133;     LNVVlEKHTennVBiCbwFshGkmm36362133 = LNVVlEKHTennVBiCbwFshGkmm67288907;     LNVVlEKHTennVBiCbwFshGkmm67288907 = LNVVlEKHTennVBiCbwFshGkmm11852440;     LNVVlEKHTennVBiCbwFshGkmm11852440 = LNVVlEKHTennVBiCbwFshGkmm40418734;     LNVVlEKHTennVBiCbwFshGkmm40418734 = LNVVlEKHTennVBiCbwFshGkmm60051223;     LNVVlEKHTennVBiCbwFshGkmm60051223 = LNVVlEKHTennVBiCbwFshGkmm92527199;     LNVVlEKHTennVBiCbwFshGkmm92527199 = LNVVlEKHTennVBiCbwFshGkmm45792531;     LNVVlEKHTennVBiCbwFshGkmm45792531 = LNVVlEKHTennVBiCbwFshGkmm44392207;     LNVVlEKHTennVBiCbwFshGkmm44392207 = LNVVlEKHTennVBiCbwFshGkmm78873542;     LNVVlEKHTennVBiCbwFshGkmm78873542 = LNVVlEKHTennVBiCbwFshGkmm39084803;     LNVVlEKHTennVBiCbwFshGkmm39084803 = LNVVlEKHTennVBiCbwFshGkmm16902356;     LNVVlEKHTennVBiCbwFshGkmm16902356 = LNVVlEKHTennVBiCbwFshGkmm53162908;     LNVVlEKHTennVBiCbwFshGkmm53162908 = LNVVlEKHTennVBiCbwFshGkmm68939614;     LNVVlEKHTennVBiCbwFshGkmm68939614 = LNVVlEKHTennVBiCbwFshGkmm23974980;     LNVVlEKHTennVBiCbwFshGkmm23974980 = LNVVlEKHTennVBiCbwFshGkmm52411356;     LNVVlEKHTennVBiCbwFshGkmm52411356 = LNVVlEKHTennVBiCbwFshGkmm77594426;     LNVVlEKHTennVBiCbwFshGkmm77594426 = LNVVlEKHTennVBiCbwFshGkmm11730344;     LNVVlEKHTennVBiCbwFshGkmm11730344 = LNVVlEKHTennVBiCbwFshGkmm42115853;     LNVVlEKHTennVBiCbwFshGkmm42115853 = LNVVlEKHTennVBiCbwFshGkmm14283807;     LNVVlEKHTennVBiCbwFshGkmm14283807 = LNVVlEKHTennVBiCbwFshGkmm26700916;     LNVVlEKHTennVBiCbwFshGkmm26700916 = LNVVlEKHTennVBiCbwFshGkmm88768246;     LNVVlEKHTennVBiCbwFshGkmm88768246 = LNVVlEKHTennVBiCbwFshGkmm55574240;     LNVVlEKHTennVBiCbwFshGkmm55574240 = LNVVlEKHTennVBiCbwFshGkmm88146011;     LNVVlEKHTennVBiCbwFshGkmm88146011 = LNVVlEKHTennVBiCbwFshGkmm59107179;     LNVVlEKHTennVBiCbwFshGkmm59107179 = LNVVlEKHTennVBiCbwFshGkmm18748545;     LNVVlEKHTennVBiCbwFshGkmm18748545 = LNVVlEKHTennVBiCbwFshGkmm706131;     LNVVlEKHTennVBiCbwFshGkmm706131 = LNVVlEKHTennVBiCbwFshGkmm5210077;     LNVVlEKHTennVBiCbwFshGkmm5210077 = LNVVlEKHTennVBiCbwFshGkmm69054284;     LNVVlEKHTennVBiCbwFshGkmm69054284 = LNVVlEKHTennVBiCbwFshGkmm63892376;     LNVVlEKHTennVBiCbwFshGkmm63892376 = LNVVlEKHTennVBiCbwFshGkmm85301724;     LNVVlEKHTennVBiCbwFshGkmm85301724 = LNVVlEKHTennVBiCbwFshGkmm24666722;     LNVVlEKHTennVBiCbwFshGkmm24666722 = LNVVlEKHTennVBiCbwFshGkmm36704061;     LNVVlEKHTennVBiCbwFshGkmm36704061 = LNVVlEKHTennVBiCbwFshGkmm14042349;     LNVVlEKHTennVBiCbwFshGkmm14042349 = LNVVlEKHTennVBiCbwFshGkmm2199706;     LNVVlEKHTennVBiCbwFshGkmm2199706 = LNVVlEKHTennVBiCbwFshGkmm3221721;     LNVVlEKHTennVBiCbwFshGkmm3221721 = LNVVlEKHTennVBiCbwFshGkmm92335170;     LNVVlEKHTennVBiCbwFshGkmm92335170 = LNVVlEKHTennVBiCbwFshGkmm79715403;     LNVVlEKHTennVBiCbwFshGkmm79715403 = LNVVlEKHTennVBiCbwFshGkmm83947554;     LNVVlEKHTennVBiCbwFshGkmm83947554 = LNVVlEKHTennVBiCbwFshGkmm78696730;     LNVVlEKHTennVBiCbwFshGkmm78696730 = LNVVlEKHTennVBiCbwFshGkmm46935720;     LNVVlEKHTennVBiCbwFshGkmm46935720 = LNVVlEKHTennVBiCbwFshGkmm75643985;     LNVVlEKHTennVBiCbwFshGkmm75643985 = LNVVlEKHTennVBiCbwFshGkmm20573763;     LNVVlEKHTennVBiCbwFshGkmm20573763 = LNVVlEKHTennVBiCbwFshGkmm24767122;     LNVVlEKHTennVBiCbwFshGkmm24767122 = LNVVlEKHTennVBiCbwFshGkmm38856186;     LNVVlEKHTennVBiCbwFshGkmm38856186 = LNVVlEKHTennVBiCbwFshGkmm12526091;     LNVVlEKHTennVBiCbwFshGkmm12526091 = LNVVlEKHTennVBiCbwFshGkmm70828333;     LNVVlEKHTennVBiCbwFshGkmm70828333 = LNVVlEKHTennVBiCbwFshGkmm21538887;     LNVVlEKHTennVBiCbwFshGkmm21538887 = LNVVlEKHTennVBiCbwFshGkmm10849375;     LNVVlEKHTennVBiCbwFshGkmm10849375 = LNVVlEKHTennVBiCbwFshGkmm85190202;     LNVVlEKHTennVBiCbwFshGkmm85190202 = LNVVlEKHTennVBiCbwFshGkmm16155284;     LNVVlEKHTennVBiCbwFshGkmm16155284 = LNVVlEKHTennVBiCbwFshGkmm21006886;     LNVVlEKHTennVBiCbwFshGkmm21006886 = LNVVlEKHTennVBiCbwFshGkmm12889664;     LNVVlEKHTennVBiCbwFshGkmm12889664 = LNVVlEKHTennVBiCbwFshGkmm5034995;     LNVVlEKHTennVBiCbwFshGkmm5034995 = LNVVlEKHTennVBiCbwFshGkmm52646087;     LNVVlEKHTennVBiCbwFshGkmm52646087 = LNVVlEKHTennVBiCbwFshGkmm76999506;     LNVVlEKHTennVBiCbwFshGkmm76999506 = LNVVlEKHTennVBiCbwFshGkmm80787892;     LNVVlEKHTennVBiCbwFshGkmm80787892 = LNVVlEKHTennVBiCbwFshGkmm79142895;     LNVVlEKHTennVBiCbwFshGkmm79142895 = LNVVlEKHTennVBiCbwFshGkmm52745260;     LNVVlEKHTennVBiCbwFshGkmm52745260 = LNVVlEKHTennVBiCbwFshGkmm21670190;     LNVVlEKHTennVBiCbwFshGkmm21670190 = LNVVlEKHTennVBiCbwFshGkmm59345092;     LNVVlEKHTennVBiCbwFshGkmm59345092 = LNVVlEKHTennVBiCbwFshGkmm87317123;     LNVVlEKHTennVBiCbwFshGkmm87317123 = LNVVlEKHTennVBiCbwFshGkmm76738246;     LNVVlEKHTennVBiCbwFshGkmm76738246 = LNVVlEKHTennVBiCbwFshGkmm80499830;     LNVVlEKHTennVBiCbwFshGkmm80499830 = LNVVlEKHTennVBiCbwFshGkmm93571817;     LNVVlEKHTennVBiCbwFshGkmm93571817 = LNVVlEKHTennVBiCbwFshGkmm14418082;     LNVVlEKHTennVBiCbwFshGkmm14418082 = LNVVlEKHTennVBiCbwFshGkmm80198295;     LNVVlEKHTennVBiCbwFshGkmm80198295 = LNVVlEKHTennVBiCbwFshGkmm39120560;     LNVVlEKHTennVBiCbwFshGkmm39120560 = LNVVlEKHTennVBiCbwFshGkmm66739909;     LNVVlEKHTennVBiCbwFshGkmm66739909 = LNVVlEKHTennVBiCbwFshGkmm20753260;     LNVVlEKHTennVBiCbwFshGkmm20753260 = LNVVlEKHTennVBiCbwFshGkmm60076186;     LNVVlEKHTennVBiCbwFshGkmm60076186 = LNVVlEKHTennVBiCbwFshGkmm97879022;     LNVVlEKHTennVBiCbwFshGkmm97879022 = LNVVlEKHTennVBiCbwFshGkmm27782789;     LNVVlEKHTennVBiCbwFshGkmm27782789 = LNVVlEKHTennVBiCbwFshGkmm63419122;     LNVVlEKHTennVBiCbwFshGkmm63419122 = LNVVlEKHTennVBiCbwFshGkmm67348086;     LNVVlEKHTennVBiCbwFshGkmm67348086 = LNVVlEKHTennVBiCbwFshGkmm51056931;     LNVVlEKHTennVBiCbwFshGkmm51056931 = LNVVlEKHTennVBiCbwFshGkmm68194484;     LNVVlEKHTennVBiCbwFshGkmm68194484 = LNVVlEKHTennVBiCbwFshGkmm30807119;     LNVVlEKHTennVBiCbwFshGkmm30807119 = LNVVlEKHTennVBiCbwFshGkmm49289826;     LNVVlEKHTennVBiCbwFshGkmm49289826 = LNVVlEKHTennVBiCbwFshGkmm46581089;     LNVVlEKHTennVBiCbwFshGkmm46581089 = LNVVlEKHTennVBiCbwFshGkmm47920211;     LNVVlEKHTennVBiCbwFshGkmm47920211 = LNVVlEKHTennVBiCbwFshGkmm79167243;     LNVVlEKHTennVBiCbwFshGkmm79167243 = LNVVlEKHTennVBiCbwFshGkmm94360702;     LNVVlEKHTennVBiCbwFshGkmm94360702 = LNVVlEKHTennVBiCbwFshGkmm24366289;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void UOPqugLQvPJnUaxXzDZKDrZfrMJQCDoavyoVUpRRWNcdsAAXuWjPeNWdp6616911() {     long jziWvOraisWmbDJmHnqOvnqLm30483396 = -189396991;    long jziWvOraisWmbDJmHnqOvnqLm82121233 = -184491760;    long jziWvOraisWmbDJmHnqOvnqLm55505103 = -443589698;    long jziWvOraisWmbDJmHnqOvnqLm48511297 = 38799004;    long jziWvOraisWmbDJmHnqOvnqLm33861458 = -72290142;    long jziWvOraisWmbDJmHnqOvnqLm95057865 = -589137362;    long jziWvOraisWmbDJmHnqOvnqLm38429955 = -861762787;    long jziWvOraisWmbDJmHnqOvnqLm79188337 = 59898191;    long jziWvOraisWmbDJmHnqOvnqLm88633737 = -622917644;    long jziWvOraisWmbDJmHnqOvnqLm31708161 = 67696101;    long jziWvOraisWmbDJmHnqOvnqLm94934644 = -192386574;    long jziWvOraisWmbDJmHnqOvnqLm69424601 = -131538183;    long jziWvOraisWmbDJmHnqOvnqLm79958828 = -784086524;    long jziWvOraisWmbDJmHnqOvnqLm15880907 = -444275444;    long jziWvOraisWmbDJmHnqOvnqLm50747943 = -149648916;    long jziWvOraisWmbDJmHnqOvnqLm60824194 = -629851200;    long jziWvOraisWmbDJmHnqOvnqLm73183006 = -247725968;    long jziWvOraisWmbDJmHnqOvnqLm62820906 = -309916894;    long jziWvOraisWmbDJmHnqOvnqLm98191974 = 43016411;    long jziWvOraisWmbDJmHnqOvnqLm47839072 = -754114156;    long jziWvOraisWmbDJmHnqOvnqLm405633 = -964430192;    long jziWvOraisWmbDJmHnqOvnqLm26939758 = -631675530;    long jziWvOraisWmbDJmHnqOvnqLm95642015 = -545478608;    long jziWvOraisWmbDJmHnqOvnqLm76519573 = -196839924;    long jziWvOraisWmbDJmHnqOvnqLm89492181 = -829020072;    long jziWvOraisWmbDJmHnqOvnqLm69113882 = -464099341;    long jziWvOraisWmbDJmHnqOvnqLm77333320 = -883181487;    long jziWvOraisWmbDJmHnqOvnqLm52191929 = -969073706;    long jziWvOraisWmbDJmHnqOvnqLm83034611 = -672594187;    long jziWvOraisWmbDJmHnqOvnqLm21778545 = -489087102;    long jziWvOraisWmbDJmHnqOvnqLm61182164 = -845515052;    long jziWvOraisWmbDJmHnqOvnqLm21585602 = -998197052;    long jziWvOraisWmbDJmHnqOvnqLm62122304 = -10657031;    long jziWvOraisWmbDJmHnqOvnqLm72424990 = -829021135;    long jziWvOraisWmbDJmHnqOvnqLm73204995 = -617117293;    long jziWvOraisWmbDJmHnqOvnqLm10841766 = -853635996;    long jziWvOraisWmbDJmHnqOvnqLm95545741 = -631589100;    long jziWvOraisWmbDJmHnqOvnqLm60791129 = -742454745;    long jziWvOraisWmbDJmHnqOvnqLm62378500 = -460101980;    long jziWvOraisWmbDJmHnqOvnqLm43076178 = -618471939;    long jziWvOraisWmbDJmHnqOvnqLm93815235 = -608337090;    long jziWvOraisWmbDJmHnqOvnqLm91257636 = -188628530;    long jziWvOraisWmbDJmHnqOvnqLm96815522 = -565081563;    long jziWvOraisWmbDJmHnqOvnqLm88113871 = -239345275;    long jziWvOraisWmbDJmHnqOvnqLm17162542 = 58661512;    long jziWvOraisWmbDJmHnqOvnqLm80993479 = -500473796;    long jziWvOraisWmbDJmHnqOvnqLm81670951 = 66248848;    long jziWvOraisWmbDJmHnqOvnqLm93258665 = -436232414;    long jziWvOraisWmbDJmHnqOvnqLm34342451 = -776410913;    long jziWvOraisWmbDJmHnqOvnqLm49615713 = 8719150;    long jziWvOraisWmbDJmHnqOvnqLm49743027 = -568924734;    long jziWvOraisWmbDJmHnqOvnqLm13009426 = -643940095;    long jziWvOraisWmbDJmHnqOvnqLm51470178 = -613452774;    long jziWvOraisWmbDJmHnqOvnqLm88304050 = 47580769;    long jziWvOraisWmbDJmHnqOvnqLm6211279 = -553621326;    long jziWvOraisWmbDJmHnqOvnqLm3543638 = -557721461;    long jziWvOraisWmbDJmHnqOvnqLm86479218 = -639013152;    long jziWvOraisWmbDJmHnqOvnqLm78985529 = -146749775;    long jziWvOraisWmbDJmHnqOvnqLm59019116 = -132180925;    long jziWvOraisWmbDJmHnqOvnqLm64747575 = -608190802;    long jziWvOraisWmbDJmHnqOvnqLm17724546 = -705955876;    long jziWvOraisWmbDJmHnqOvnqLm86238026 = -892689081;    long jziWvOraisWmbDJmHnqOvnqLm96153725 = -267507622;    long jziWvOraisWmbDJmHnqOvnqLm66855192 = -33830542;    long jziWvOraisWmbDJmHnqOvnqLm70525997 = -86788848;    long jziWvOraisWmbDJmHnqOvnqLm73349043 = -194189522;    long jziWvOraisWmbDJmHnqOvnqLm7302297 = -20881152;    long jziWvOraisWmbDJmHnqOvnqLm7533839 = -955065389;    long jziWvOraisWmbDJmHnqOvnqLm42675911 = -827158152;    long jziWvOraisWmbDJmHnqOvnqLm39906177 = -296012920;    long jziWvOraisWmbDJmHnqOvnqLm65278453 = -998262100;    long jziWvOraisWmbDJmHnqOvnqLm12391878 = -505271223;    long jziWvOraisWmbDJmHnqOvnqLm442407 = -849814914;    long jziWvOraisWmbDJmHnqOvnqLm55115797 = -338511651;    long jziWvOraisWmbDJmHnqOvnqLm54023836 = -45777067;    long jziWvOraisWmbDJmHnqOvnqLm9147997 = -675801662;    long jziWvOraisWmbDJmHnqOvnqLm30124235 = 33406032;    long jziWvOraisWmbDJmHnqOvnqLm7528144 = -206133334;    long jziWvOraisWmbDJmHnqOvnqLm59357032 = -155501437;    long jziWvOraisWmbDJmHnqOvnqLm8498702 = -228546276;    long jziWvOraisWmbDJmHnqOvnqLm87442931 = -430348190;    long jziWvOraisWmbDJmHnqOvnqLm84074654 = -346949073;    long jziWvOraisWmbDJmHnqOvnqLm17849479 = -92662793;    long jziWvOraisWmbDJmHnqOvnqLm33418898 = -581313338;    long jziWvOraisWmbDJmHnqOvnqLm72035518 = -920162369;    long jziWvOraisWmbDJmHnqOvnqLm48172739 = -101574957;    long jziWvOraisWmbDJmHnqOvnqLm70115424 = -284744279;    long jziWvOraisWmbDJmHnqOvnqLm73818254 = 41762199;    long jziWvOraisWmbDJmHnqOvnqLm66213711 = -175399810;    long jziWvOraisWmbDJmHnqOvnqLm69661358 = 40604168;    long jziWvOraisWmbDJmHnqOvnqLm24362548 = -114622844;    long jziWvOraisWmbDJmHnqOvnqLm16560212 = -384839326;    long jziWvOraisWmbDJmHnqOvnqLm1772013 = -510273820;    long jziWvOraisWmbDJmHnqOvnqLm97630924 = -851911179;    long jziWvOraisWmbDJmHnqOvnqLm25351632 = -912516063;    long jziWvOraisWmbDJmHnqOvnqLm7577209 = -715648009;    long jziWvOraisWmbDJmHnqOvnqLm95103910 = -921120908;    long jziWvOraisWmbDJmHnqOvnqLm29960331 = -431251022;    long jziWvOraisWmbDJmHnqOvnqLm17587874 = -52556428;    long jziWvOraisWmbDJmHnqOvnqLm43813499 = -189396991;     jziWvOraisWmbDJmHnqOvnqLm30483396 = jziWvOraisWmbDJmHnqOvnqLm82121233;     jziWvOraisWmbDJmHnqOvnqLm82121233 = jziWvOraisWmbDJmHnqOvnqLm55505103;     jziWvOraisWmbDJmHnqOvnqLm55505103 = jziWvOraisWmbDJmHnqOvnqLm48511297;     jziWvOraisWmbDJmHnqOvnqLm48511297 = jziWvOraisWmbDJmHnqOvnqLm33861458;     jziWvOraisWmbDJmHnqOvnqLm33861458 = jziWvOraisWmbDJmHnqOvnqLm95057865;     jziWvOraisWmbDJmHnqOvnqLm95057865 = jziWvOraisWmbDJmHnqOvnqLm38429955;     jziWvOraisWmbDJmHnqOvnqLm38429955 = jziWvOraisWmbDJmHnqOvnqLm79188337;     jziWvOraisWmbDJmHnqOvnqLm79188337 = jziWvOraisWmbDJmHnqOvnqLm88633737;     jziWvOraisWmbDJmHnqOvnqLm88633737 = jziWvOraisWmbDJmHnqOvnqLm31708161;     jziWvOraisWmbDJmHnqOvnqLm31708161 = jziWvOraisWmbDJmHnqOvnqLm94934644;     jziWvOraisWmbDJmHnqOvnqLm94934644 = jziWvOraisWmbDJmHnqOvnqLm69424601;     jziWvOraisWmbDJmHnqOvnqLm69424601 = jziWvOraisWmbDJmHnqOvnqLm79958828;     jziWvOraisWmbDJmHnqOvnqLm79958828 = jziWvOraisWmbDJmHnqOvnqLm15880907;     jziWvOraisWmbDJmHnqOvnqLm15880907 = jziWvOraisWmbDJmHnqOvnqLm50747943;     jziWvOraisWmbDJmHnqOvnqLm50747943 = jziWvOraisWmbDJmHnqOvnqLm60824194;     jziWvOraisWmbDJmHnqOvnqLm60824194 = jziWvOraisWmbDJmHnqOvnqLm73183006;     jziWvOraisWmbDJmHnqOvnqLm73183006 = jziWvOraisWmbDJmHnqOvnqLm62820906;     jziWvOraisWmbDJmHnqOvnqLm62820906 = jziWvOraisWmbDJmHnqOvnqLm98191974;     jziWvOraisWmbDJmHnqOvnqLm98191974 = jziWvOraisWmbDJmHnqOvnqLm47839072;     jziWvOraisWmbDJmHnqOvnqLm47839072 = jziWvOraisWmbDJmHnqOvnqLm405633;     jziWvOraisWmbDJmHnqOvnqLm405633 = jziWvOraisWmbDJmHnqOvnqLm26939758;     jziWvOraisWmbDJmHnqOvnqLm26939758 = jziWvOraisWmbDJmHnqOvnqLm95642015;     jziWvOraisWmbDJmHnqOvnqLm95642015 = jziWvOraisWmbDJmHnqOvnqLm76519573;     jziWvOraisWmbDJmHnqOvnqLm76519573 = jziWvOraisWmbDJmHnqOvnqLm89492181;     jziWvOraisWmbDJmHnqOvnqLm89492181 = jziWvOraisWmbDJmHnqOvnqLm69113882;     jziWvOraisWmbDJmHnqOvnqLm69113882 = jziWvOraisWmbDJmHnqOvnqLm77333320;     jziWvOraisWmbDJmHnqOvnqLm77333320 = jziWvOraisWmbDJmHnqOvnqLm52191929;     jziWvOraisWmbDJmHnqOvnqLm52191929 = jziWvOraisWmbDJmHnqOvnqLm83034611;     jziWvOraisWmbDJmHnqOvnqLm83034611 = jziWvOraisWmbDJmHnqOvnqLm21778545;     jziWvOraisWmbDJmHnqOvnqLm21778545 = jziWvOraisWmbDJmHnqOvnqLm61182164;     jziWvOraisWmbDJmHnqOvnqLm61182164 = jziWvOraisWmbDJmHnqOvnqLm21585602;     jziWvOraisWmbDJmHnqOvnqLm21585602 = jziWvOraisWmbDJmHnqOvnqLm62122304;     jziWvOraisWmbDJmHnqOvnqLm62122304 = jziWvOraisWmbDJmHnqOvnqLm72424990;     jziWvOraisWmbDJmHnqOvnqLm72424990 = jziWvOraisWmbDJmHnqOvnqLm73204995;     jziWvOraisWmbDJmHnqOvnqLm73204995 = jziWvOraisWmbDJmHnqOvnqLm10841766;     jziWvOraisWmbDJmHnqOvnqLm10841766 = jziWvOraisWmbDJmHnqOvnqLm95545741;     jziWvOraisWmbDJmHnqOvnqLm95545741 = jziWvOraisWmbDJmHnqOvnqLm60791129;     jziWvOraisWmbDJmHnqOvnqLm60791129 = jziWvOraisWmbDJmHnqOvnqLm62378500;     jziWvOraisWmbDJmHnqOvnqLm62378500 = jziWvOraisWmbDJmHnqOvnqLm43076178;     jziWvOraisWmbDJmHnqOvnqLm43076178 = jziWvOraisWmbDJmHnqOvnqLm93815235;     jziWvOraisWmbDJmHnqOvnqLm93815235 = jziWvOraisWmbDJmHnqOvnqLm91257636;     jziWvOraisWmbDJmHnqOvnqLm91257636 = jziWvOraisWmbDJmHnqOvnqLm96815522;     jziWvOraisWmbDJmHnqOvnqLm96815522 = jziWvOraisWmbDJmHnqOvnqLm88113871;     jziWvOraisWmbDJmHnqOvnqLm88113871 = jziWvOraisWmbDJmHnqOvnqLm17162542;     jziWvOraisWmbDJmHnqOvnqLm17162542 = jziWvOraisWmbDJmHnqOvnqLm80993479;     jziWvOraisWmbDJmHnqOvnqLm80993479 = jziWvOraisWmbDJmHnqOvnqLm81670951;     jziWvOraisWmbDJmHnqOvnqLm81670951 = jziWvOraisWmbDJmHnqOvnqLm93258665;     jziWvOraisWmbDJmHnqOvnqLm93258665 = jziWvOraisWmbDJmHnqOvnqLm34342451;     jziWvOraisWmbDJmHnqOvnqLm34342451 = jziWvOraisWmbDJmHnqOvnqLm49615713;     jziWvOraisWmbDJmHnqOvnqLm49615713 = jziWvOraisWmbDJmHnqOvnqLm49743027;     jziWvOraisWmbDJmHnqOvnqLm49743027 = jziWvOraisWmbDJmHnqOvnqLm13009426;     jziWvOraisWmbDJmHnqOvnqLm13009426 = jziWvOraisWmbDJmHnqOvnqLm51470178;     jziWvOraisWmbDJmHnqOvnqLm51470178 = jziWvOraisWmbDJmHnqOvnqLm88304050;     jziWvOraisWmbDJmHnqOvnqLm88304050 = jziWvOraisWmbDJmHnqOvnqLm6211279;     jziWvOraisWmbDJmHnqOvnqLm6211279 = jziWvOraisWmbDJmHnqOvnqLm3543638;     jziWvOraisWmbDJmHnqOvnqLm3543638 = jziWvOraisWmbDJmHnqOvnqLm86479218;     jziWvOraisWmbDJmHnqOvnqLm86479218 = jziWvOraisWmbDJmHnqOvnqLm78985529;     jziWvOraisWmbDJmHnqOvnqLm78985529 = jziWvOraisWmbDJmHnqOvnqLm59019116;     jziWvOraisWmbDJmHnqOvnqLm59019116 = jziWvOraisWmbDJmHnqOvnqLm64747575;     jziWvOraisWmbDJmHnqOvnqLm64747575 = jziWvOraisWmbDJmHnqOvnqLm17724546;     jziWvOraisWmbDJmHnqOvnqLm17724546 = jziWvOraisWmbDJmHnqOvnqLm86238026;     jziWvOraisWmbDJmHnqOvnqLm86238026 = jziWvOraisWmbDJmHnqOvnqLm96153725;     jziWvOraisWmbDJmHnqOvnqLm96153725 = jziWvOraisWmbDJmHnqOvnqLm66855192;     jziWvOraisWmbDJmHnqOvnqLm66855192 = jziWvOraisWmbDJmHnqOvnqLm70525997;     jziWvOraisWmbDJmHnqOvnqLm70525997 = jziWvOraisWmbDJmHnqOvnqLm73349043;     jziWvOraisWmbDJmHnqOvnqLm73349043 = jziWvOraisWmbDJmHnqOvnqLm7302297;     jziWvOraisWmbDJmHnqOvnqLm7302297 = jziWvOraisWmbDJmHnqOvnqLm7533839;     jziWvOraisWmbDJmHnqOvnqLm7533839 = jziWvOraisWmbDJmHnqOvnqLm42675911;     jziWvOraisWmbDJmHnqOvnqLm42675911 = jziWvOraisWmbDJmHnqOvnqLm39906177;     jziWvOraisWmbDJmHnqOvnqLm39906177 = jziWvOraisWmbDJmHnqOvnqLm65278453;     jziWvOraisWmbDJmHnqOvnqLm65278453 = jziWvOraisWmbDJmHnqOvnqLm12391878;     jziWvOraisWmbDJmHnqOvnqLm12391878 = jziWvOraisWmbDJmHnqOvnqLm442407;     jziWvOraisWmbDJmHnqOvnqLm442407 = jziWvOraisWmbDJmHnqOvnqLm55115797;     jziWvOraisWmbDJmHnqOvnqLm55115797 = jziWvOraisWmbDJmHnqOvnqLm54023836;     jziWvOraisWmbDJmHnqOvnqLm54023836 = jziWvOraisWmbDJmHnqOvnqLm9147997;     jziWvOraisWmbDJmHnqOvnqLm9147997 = jziWvOraisWmbDJmHnqOvnqLm30124235;     jziWvOraisWmbDJmHnqOvnqLm30124235 = jziWvOraisWmbDJmHnqOvnqLm7528144;     jziWvOraisWmbDJmHnqOvnqLm7528144 = jziWvOraisWmbDJmHnqOvnqLm59357032;     jziWvOraisWmbDJmHnqOvnqLm59357032 = jziWvOraisWmbDJmHnqOvnqLm8498702;     jziWvOraisWmbDJmHnqOvnqLm8498702 = jziWvOraisWmbDJmHnqOvnqLm87442931;     jziWvOraisWmbDJmHnqOvnqLm87442931 = jziWvOraisWmbDJmHnqOvnqLm84074654;     jziWvOraisWmbDJmHnqOvnqLm84074654 = jziWvOraisWmbDJmHnqOvnqLm17849479;     jziWvOraisWmbDJmHnqOvnqLm17849479 = jziWvOraisWmbDJmHnqOvnqLm33418898;     jziWvOraisWmbDJmHnqOvnqLm33418898 = jziWvOraisWmbDJmHnqOvnqLm72035518;     jziWvOraisWmbDJmHnqOvnqLm72035518 = jziWvOraisWmbDJmHnqOvnqLm48172739;     jziWvOraisWmbDJmHnqOvnqLm48172739 = jziWvOraisWmbDJmHnqOvnqLm70115424;     jziWvOraisWmbDJmHnqOvnqLm70115424 = jziWvOraisWmbDJmHnqOvnqLm73818254;     jziWvOraisWmbDJmHnqOvnqLm73818254 = jziWvOraisWmbDJmHnqOvnqLm66213711;     jziWvOraisWmbDJmHnqOvnqLm66213711 = jziWvOraisWmbDJmHnqOvnqLm69661358;     jziWvOraisWmbDJmHnqOvnqLm69661358 = jziWvOraisWmbDJmHnqOvnqLm24362548;     jziWvOraisWmbDJmHnqOvnqLm24362548 = jziWvOraisWmbDJmHnqOvnqLm16560212;     jziWvOraisWmbDJmHnqOvnqLm16560212 = jziWvOraisWmbDJmHnqOvnqLm1772013;     jziWvOraisWmbDJmHnqOvnqLm1772013 = jziWvOraisWmbDJmHnqOvnqLm97630924;     jziWvOraisWmbDJmHnqOvnqLm97630924 = jziWvOraisWmbDJmHnqOvnqLm25351632;     jziWvOraisWmbDJmHnqOvnqLm25351632 = jziWvOraisWmbDJmHnqOvnqLm7577209;     jziWvOraisWmbDJmHnqOvnqLm7577209 = jziWvOraisWmbDJmHnqOvnqLm95103910;     jziWvOraisWmbDJmHnqOvnqLm95103910 = jziWvOraisWmbDJmHnqOvnqLm29960331;     jziWvOraisWmbDJmHnqOvnqLm29960331 = jziWvOraisWmbDJmHnqOvnqLm17587874;     jziWvOraisWmbDJmHnqOvnqLm17587874 = jziWvOraisWmbDJmHnqOvnqLm43813499;     jziWvOraisWmbDJmHnqOvnqLm43813499 = jziWvOraisWmbDJmHnqOvnqLm30483396;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void JSELJIESWSZvmOksTzXsPqeQHqQEoAOmtMvsupRDWXDGZNuDxgKzZyTTn73908510() {     long nETszeWDmBZTryeiTWsnXqtvM65942364 = -655673891;    long nETszeWDmBZTryeiTWsnXqtvM95393311 = -65043367;    long nETszeWDmBZTryeiTWsnXqtvM92891579 = -109256773;    long nETszeWDmBZTryeiTWsnXqtvM20734652 = -882352068;    long nETszeWDmBZTryeiTWsnXqtvM90146726 = -177888987;    long nETszeWDmBZTryeiTWsnXqtvM31280738 = -851485258;    long nETszeWDmBZTryeiTWsnXqtvM49087362 = -706488521;    long nETszeWDmBZTryeiTWsnXqtvM41319898 = -684335949;    long nETszeWDmBZTryeiTWsnXqtvM90151342 = -11249051;    long nETszeWDmBZTryeiTWsnXqtvM46610873 = -696990897;    long nETszeWDmBZTryeiTWsnXqtvM33116380 = 5605697;    long nETszeWDmBZTryeiTWsnXqtvM69992749 = 4341046;    long nETszeWDmBZTryeiTWsnXqtvM18193474 = -236099029;    long nETszeWDmBZTryeiTWsnXqtvM69021769 = -420638854;    long nETszeWDmBZTryeiTWsnXqtvM8942460 = -653073931;    long nETszeWDmBZTryeiTWsnXqtvM44365495 = -265662807;    long nETszeWDmBZTryeiTWsnXqtvM29018943 = -774700520;    long nETszeWDmBZTryeiTWsnXqtvM62581098 = -383344963;    long nETszeWDmBZTryeiTWsnXqtvM98742304 = -273547010;    long nETszeWDmBZTryeiTWsnXqtvM41676290 = -80675222;    long nETszeWDmBZTryeiTWsnXqtvM13492496 = -621704880;    long nETszeWDmBZTryeiTWsnXqtvM30361283 = -718311824;    long nETszeWDmBZTryeiTWsnXqtvM66167395 = -183110792;    long nETszeWDmBZTryeiTWsnXqtvM70312518 = -707664528;    long nETszeWDmBZTryeiTWsnXqtvM97510132 = -853005270;    long nETszeWDmBZTryeiTWsnXqtvM79812054 = -152676147;    long nETszeWDmBZTryeiTWsnXqtvM37753894 = -689465627;    long nETszeWDmBZTryeiTWsnXqtvM92920353 = -38845881;    long nETszeWDmBZTryeiTWsnXqtvM29702826 = -146688990;    long nETszeWDmBZTryeiTWsnXqtvM27311956 = -523594273;    long nETszeWDmBZTryeiTWsnXqtvM79765395 = -297495539;    long nETszeWDmBZTryeiTWsnXqtvM59408620 = -771168467;    long nETszeWDmBZTryeiTWsnXqtvM74340315 = -158253009;    long nETszeWDmBZTryeiTWsnXqtvM2173417 = -893714949;    long nETszeWDmBZTryeiTWsnXqtvM39013450 = -568217543;    long nETszeWDmBZTryeiTWsnXqtvM62402609 = 31798698;    long nETszeWDmBZTryeiTWsnXqtvM44957558 = -496285141;    long nETszeWDmBZTryeiTWsnXqtvM12006532 = -725110326;    long nETszeWDmBZTryeiTWsnXqtvM92769061 = -110978257;    long nETszeWDmBZTryeiTWsnXqtvM7347710 = -83734485;    long nETszeWDmBZTryeiTWsnXqtvM27266844 = -377536004;    long nETszeWDmBZTryeiTWsnXqtvM80622763 = -883173821;    long nETszeWDmBZTryeiTWsnXqtvM86198901 = -118262349;    long nETszeWDmBZTryeiTWsnXqtvM28245210 = -843677685;    long nETszeWDmBZTryeiTWsnXqtvM17179000 = -867849649;    long nETszeWDmBZTryeiTWsnXqtvM26954808 = -539397428;    long nETszeWDmBZTryeiTWsnXqtvM1016115 = -417737512;    long nETszeWDmBZTryeiTWsnXqtvM10984978 = -602759008;    long nETszeWDmBZTryeiTWsnXqtvM57235116 = -440147794;    long nETszeWDmBZTryeiTWsnXqtvM74145302 = -482307666;    long nETszeWDmBZTryeiTWsnXqtvM30513751 = -443201291;    long nETszeWDmBZTryeiTWsnXqtvM96494897 = -857592441;    long nETszeWDmBZTryeiTWsnXqtvM20091327 = -369498328;    long nETszeWDmBZTryeiTWsnXqtvM4295897 = -143927730;    long nETszeWDmBZTryeiTWsnXqtvM60416015 = -900111471;    long nETszeWDmBZTryeiTWsnXqtvM35581081 = -937362067;    long nETszeWDmBZTryeiTWsnXqtvM29225917 = -881932575;    long nETszeWDmBZTryeiTWsnXqtvM22579061 = -401592245;    long nETszeWDmBZTryeiTWsnXqtvM23224520 = 70653202;    long nETszeWDmBZTryeiTWsnXqtvM10334673 = 74787160;    long nETszeWDmBZTryeiTWsnXqtvM93526843 = -62019631;    long nETszeWDmBZTryeiTWsnXqtvM56167008 = -567642641;    long nETszeWDmBZTryeiTWsnXqtvM11617073 = -437646960;    long nETszeWDmBZTryeiTWsnXqtvM62839386 = -487654779;    long nETszeWDmBZTryeiTWsnXqtvM66845477 = -299495358;    long nETszeWDmBZTryeiTWsnXqtvM73707759 = -223225837;    long nETszeWDmBZTryeiTWsnXqtvM95652434 = -837405946;    long nETszeWDmBZTryeiTWsnXqtvM16020057 = -342384081;    long nETszeWDmBZTryeiTWsnXqtvM30008320 = -852421311;    long nETszeWDmBZTryeiTWsnXqtvM46539850 = -584872629;    long nETszeWDmBZTryeiTWsnXqtvM99407937 = -769377667;    long nETszeWDmBZTryeiTWsnXqtvM17012411 = 50409805;    long nETszeWDmBZTryeiTWsnXqtvM69812036 = -172366707;    long nETszeWDmBZTryeiTWsnXqtvM91394594 = -89812526;    long nETszeWDmBZTryeiTWsnXqtvM14409447 = -703139219;    long nETszeWDmBZTryeiTWsnXqtvM32869733 = -738531060;    long nETszeWDmBZTryeiTWsnXqtvM44162382 = -500049476;    long nETszeWDmBZTryeiTWsnXqtvM37922186 = -339433108;    long nETszeWDmBZTryeiTWsnXqtvM53133518 = -839814879;    long nETszeWDmBZTryeiTWsnXqtvM70555324 = -213607842;    long nETszeWDmBZTryeiTWsnXqtvM78795939 = -734938636;    long nETszeWDmBZTryeiTWsnXqtvM26768917 = 13293380;    long nETszeWDmBZTryeiTWsnXqtvM35685237 = -598698088;    long nETszeWDmBZTryeiTWsnXqtvM55557523 = -664381324;    long nETszeWDmBZTryeiTWsnXqtvM96798205 = 19607018;    long nETszeWDmBZTryeiTWsnXqtvM83270497 = -439903098;    long nETszeWDmBZTryeiTWsnXqtvM39317294 = -301670139;    long nETszeWDmBZTryeiTWsnXqtvM70044418 = 85674721;    long nETszeWDmBZTryeiTWsnXqtvM41757402 = -993603478;    long nETszeWDmBZTryeiTWsnXqtvM3432369 = -630855477;    long nETszeWDmBZTryeiTWsnXqtvM33176693 = -86268728;    long nETszeWDmBZTryeiTWsnXqtvM22378497 = 5307104;    long nETszeWDmBZTryeiTWsnXqtvM88782012 = -695763529;    long nETszeWDmBZTryeiTWsnXqtvM82434388 = -85765417;    long nETszeWDmBZTryeiTWsnXqtvM13820867 = 78285146;    long nETszeWDmBZTryeiTWsnXqtvM71099835 = -809893364;    long nETszeWDmBZTryeiTWsnXqtvM69005690 = -345526861;    long nETszeWDmBZTryeiTWsnXqtvM23359515 = -630607571;    long nETszeWDmBZTryeiTWsnXqtvM61399732 = -444182327;    long nETszeWDmBZTryeiTWsnXqtvM43471241 = -655673891;     nETszeWDmBZTryeiTWsnXqtvM65942364 = nETszeWDmBZTryeiTWsnXqtvM95393311;     nETszeWDmBZTryeiTWsnXqtvM95393311 = nETszeWDmBZTryeiTWsnXqtvM92891579;     nETszeWDmBZTryeiTWsnXqtvM92891579 = nETszeWDmBZTryeiTWsnXqtvM20734652;     nETszeWDmBZTryeiTWsnXqtvM20734652 = nETszeWDmBZTryeiTWsnXqtvM90146726;     nETszeWDmBZTryeiTWsnXqtvM90146726 = nETszeWDmBZTryeiTWsnXqtvM31280738;     nETszeWDmBZTryeiTWsnXqtvM31280738 = nETszeWDmBZTryeiTWsnXqtvM49087362;     nETszeWDmBZTryeiTWsnXqtvM49087362 = nETszeWDmBZTryeiTWsnXqtvM41319898;     nETszeWDmBZTryeiTWsnXqtvM41319898 = nETszeWDmBZTryeiTWsnXqtvM90151342;     nETszeWDmBZTryeiTWsnXqtvM90151342 = nETszeWDmBZTryeiTWsnXqtvM46610873;     nETszeWDmBZTryeiTWsnXqtvM46610873 = nETszeWDmBZTryeiTWsnXqtvM33116380;     nETszeWDmBZTryeiTWsnXqtvM33116380 = nETszeWDmBZTryeiTWsnXqtvM69992749;     nETszeWDmBZTryeiTWsnXqtvM69992749 = nETszeWDmBZTryeiTWsnXqtvM18193474;     nETszeWDmBZTryeiTWsnXqtvM18193474 = nETszeWDmBZTryeiTWsnXqtvM69021769;     nETszeWDmBZTryeiTWsnXqtvM69021769 = nETszeWDmBZTryeiTWsnXqtvM8942460;     nETszeWDmBZTryeiTWsnXqtvM8942460 = nETszeWDmBZTryeiTWsnXqtvM44365495;     nETszeWDmBZTryeiTWsnXqtvM44365495 = nETszeWDmBZTryeiTWsnXqtvM29018943;     nETszeWDmBZTryeiTWsnXqtvM29018943 = nETszeWDmBZTryeiTWsnXqtvM62581098;     nETszeWDmBZTryeiTWsnXqtvM62581098 = nETszeWDmBZTryeiTWsnXqtvM98742304;     nETszeWDmBZTryeiTWsnXqtvM98742304 = nETszeWDmBZTryeiTWsnXqtvM41676290;     nETszeWDmBZTryeiTWsnXqtvM41676290 = nETszeWDmBZTryeiTWsnXqtvM13492496;     nETszeWDmBZTryeiTWsnXqtvM13492496 = nETszeWDmBZTryeiTWsnXqtvM30361283;     nETszeWDmBZTryeiTWsnXqtvM30361283 = nETszeWDmBZTryeiTWsnXqtvM66167395;     nETszeWDmBZTryeiTWsnXqtvM66167395 = nETszeWDmBZTryeiTWsnXqtvM70312518;     nETszeWDmBZTryeiTWsnXqtvM70312518 = nETszeWDmBZTryeiTWsnXqtvM97510132;     nETszeWDmBZTryeiTWsnXqtvM97510132 = nETszeWDmBZTryeiTWsnXqtvM79812054;     nETszeWDmBZTryeiTWsnXqtvM79812054 = nETszeWDmBZTryeiTWsnXqtvM37753894;     nETszeWDmBZTryeiTWsnXqtvM37753894 = nETszeWDmBZTryeiTWsnXqtvM92920353;     nETszeWDmBZTryeiTWsnXqtvM92920353 = nETszeWDmBZTryeiTWsnXqtvM29702826;     nETszeWDmBZTryeiTWsnXqtvM29702826 = nETszeWDmBZTryeiTWsnXqtvM27311956;     nETszeWDmBZTryeiTWsnXqtvM27311956 = nETszeWDmBZTryeiTWsnXqtvM79765395;     nETszeWDmBZTryeiTWsnXqtvM79765395 = nETszeWDmBZTryeiTWsnXqtvM59408620;     nETszeWDmBZTryeiTWsnXqtvM59408620 = nETszeWDmBZTryeiTWsnXqtvM74340315;     nETszeWDmBZTryeiTWsnXqtvM74340315 = nETszeWDmBZTryeiTWsnXqtvM2173417;     nETszeWDmBZTryeiTWsnXqtvM2173417 = nETszeWDmBZTryeiTWsnXqtvM39013450;     nETszeWDmBZTryeiTWsnXqtvM39013450 = nETszeWDmBZTryeiTWsnXqtvM62402609;     nETszeWDmBZTryeiTWsnXqtvM62402609 = nETszeWDmBZTryeiTWsnXqtvM44957558;     nETszeWDmBZTryeiTWsnXqtvM44957558 = nETszeWDmBZTryeiTWsnXqtvM12006532;     nETszeWDmBZTryeiTWsnXqtvM12006532 = nETszeWDmBZTryeiTWsnXqtvM92769061;     nETszeWDmBZTryeiTWsnXqtvM92769061 = nETszeWDmBZTryeiTWsnXqtvM7347710;     nETszeWDmBZTryeiTWsnXqtvM7347710 = nETszeWDmBZTryeiTWsnXqtvM27266844;     nETszeWDmBZTryeiTWsnXqtvM27266844 = nETszeWDmBZTryeiTWsnXqtvM80622763;     nETszeWDmBZTryeiTWsnXqtvM80622763 = nETszeWDmBZTryeiTWsnXqtvM86198901;     nETszeWDmBZTryeiTWsnXqtvM86198901 = nETszeWDmBZTryeiTWsnXqtvM28245210;     nETszeWDmBZTryeiTWsnXqtvM28245210 = nETszeWDmBZTryeiTWsnXqtvM17179000;     nETszeWDmBZTryeiTWsnXqtvM17179000 = nETszeWDmBZTryeiTWsnXqtvM26954808;     nETszeWDmBZTryeiTWsnXqtvM26954808 = nETszeWDmBZTryeiTWsnXqtvM1016115;     nETszeWDmBZTryeiTWsnXqtvM1016115 = nETszeWDmBZTryeiTWsnXqtvM10984978;     nETszeWDmBZTryeiTWsnXqtvM10984978 = nETszeWDmBZTryeiTWsnXqtvM57235116;     nETszeWDmBZTryeiTWsnXqtvM57235116 = nETszeWDmBZTryeiTWsnXqtvM74145302;     nETszeWDmBZTryeiTWsnXqtvM74145302 = nETszeWDmBZTryeiTWsnXqtvM30513751;     nETszeWDmBZTryeiTWsnXqtvM30513751 = nETszeWDmBZTryeiTWsnXqtvM96494897;     nETszeWDmBZTryeiTWsnXqtvM96494897 = nETszeWDmBZTryeiTWsnXqtvM20091327;     nETszeWDmBZTryeiTWsnXqtvM20091327 = nETszeWDmBZTryeiTWsnXqtvM4295897;     nETszeWDmBZTryeiTWsnXqtvM4295897 = nETszeWDmBZTryeiTWsnXqtvM60416015;     nETszeWDmBZTryeiTWsnXqtvM60416015 = nETszeWDmBZTryeiTWsnXqtvM35581081;     nETszeWDmBZTryeiTWsnXqtvM35581081 = nETszeWDmBZTryeiTWsnXqtvM29225917;     nETszeWDmBZTryeiTWsnXqtvM29225917 = nETszeWDmBZTryeiTWsnXqtvM22579061;     nETszeWDmBZTryeiTWsnXqtvM22579061 = nETszeWDmBZTryeiTWsnXqtvM23224520;     nETszeWDmBZTryeiTWsnXqtvM23224520 = nETszeWDmBZTryeiTWsnXqtvM10334673;     nETszeWDmBZTryeiTWsnXqtvM10334673 = nETszeWDmBZTryeiTWsnXqtvM93526843;     nETszeWDmBZTryeiTWsnXqtvM93526843 = nETszeWDmBZTryeiTWsnXqtvM56167008;     nETszeWDmBZTryeiTWsnXqtvM56167008 = nETszeWDmBZTryeiTWsnXqtvM11617073;     nETszeWDmBZTryeiTWsnXqtvM11617073 = nETszeWDmBZTryeiTWsnXqtvM62839386;     nETszeWDmBZTryeiTWsnXqtvM62839386 = nETszeWDmBZTryeiTWsnXqtvM66845477;     nETszeWDmBZTryeiTWsnXqtvM66845477 = nETszeWDmBZTryeiTWsnXqtvM73707759;     nETszeWDmBZTryeiTWsnXqtvM73707759 = nETszeWDmBZTryeiTWsnXqtvM95652434;     nETszeWDmBZTryeiTWsnXqtvM95652434 = nETszeWDmBZTryeiTWsnXqtvM16020057;     nETszeWDmBZTryeiTWsnXqtvM16020057 = nETszeWDmBZTryeiTWsnXqtvM30008320;     nETszeWDmBZTryeiTWsnXqtvM30008320 = nETszeWDmBZTryeiTWsnXqtvM46539850;     nETszeWDmBZTryeiTWsnXqtvM46539850 = nETszeWDmBZTryeiTWsnXqtvM99407937;     nETszeWDmBZTryeiTWsnXqtvM99407937 = nETszeWDmBZTryeiTWsnXqtvM17012411;     nETszeWDmBZTryeiTWsnXqtvM17012411 = nETszeWDmBZTryeiTWsnXqtvM69812036;     nETszeWDmBZTryeiTWsnXqtvM69812036 = nETszeWDmBZTryeiTWsnXqtvM91394594;     nETszeWDmBZTryeiTWsnXqtvM91394594 = nETszeWDmBZTryeiTWsnXqtvM14409447;     nETszeWDmBZTryeiTWsnXqtvM14409447 = nETszeWDmBZTryeiTWsnXqtvM32869733;     nETszeWDmBZTryeiTWsnXqtvM32869733 = nETszeWDmBZTryeiTWsnXqtvM44162382;     nETszeWDmBZTryeiTWsnXqtvM44162382 = nETszeWDmBZTryeiTWsnXqtvM37922186;     nETszeWDmBZTryeiTWsnXqtvM37922186 = nETszeWDmBZTryeiTWsnXqtvM53133518;     nETszeWDmBZTryeiTWsnXqtvM53133518 = nETszeWDmBZTryeiTWsnXqtvM70555324;     nETszeWDmBZTryeiTWsnXqtvM70555324 = nETszeWDmBZTryeiTWsnXqtvM78795939;     nETszeWDmBZTryeiTWsnXqtvM78795939 = nETszeWDmBZTryeiTWsnXqtvM26768917;     nETszeWDmBZTryeiTWsnXqtvM26768917 = nETszeWDmBZTryeiTWsnXqtvM35685237;     nETszeWDmBZTryeiTWsnXqtvM35685237 = nETszeWDmBZTryeiTWsnXqtvM55557523;     nETszeWDmBZTryeiTWsnXqtvM55557523 = nETszeWDmBZTryeiTWsnXqtvM96798205;     nETszeWDmBZTryeiTWsnXqtvM96798205 = nETszeWDmBZTryeiTWsnXqtvM83270497;     nETszeWDmBZTryeiTWsnXqtvM83270497 = nETszeWDmBZTryeiTWsnXqtvM39317294;     nETszeWDmBZTryeiTWsnXqtvM39317294 = nETszeWDmBZTryeiTWsnXqtvM70044418;     nETszeWDmBZTryeiTWsnXqtvM70044418 = nETszeWDmBZTryeiTWsnXqtvM41757402;     nETszeWDmBZTryeiTWsnXqtvM41757402 = nETszeWDmBZTryeiTWsnXqtvM3432369;     nETszeWDmBZTryeiTWsnXqtvM3432369 = nETszeWDmBZTryeiTWsnXqtvM33176693;     nETszeWDmBZTryeiTWsnXqtvM33176693 = nETszeWDmBZTryeiTWsnXqtvM22378497;     nETszeWDmBZTryeiTWsnXqtvM22378497 = nETszeWDmBZTryeiTWsnXqtvM88782012;     nETszeWDmBZTryeiTWsnXqtvM88782012 = nETszeWDmBZTryeiTWsnXqtvM82434388;     nETszeWDmBZTryeiTWsnXqtvM82434388 = nETszeWDmBZTryeiTWsnXqtvM13820867;     nETszeWDmBZTryeiTWsnXqtvM13820867 = nETszeWDmBZTryeiTWsnXqtvM71099835;     nETszeWDmBZTryeiTWsnXqtvM71099835 = nETszeWDmBZTryeiTWsnXqtvM69005690;     nETszeWDmBZTryeiTWsnXqtvM69005690 = nETszeWDmBZTryeiTWsnXqtvM23359515;     nETszeWDmBZTryeiTWsnXqtvM23359515 = nETszeWDmBZTryeiTWsnXqtvM61399732;     nETszeWDmBZTryeiTWsnXqtvM61399732 = nETszeWDmBZTryeiTWsnXqtvM43471241;     nETszeWDmBZTryeiTWsnXqtvM43471241 = nETszeWDmBZTryeiTWsnXqtvM65942364;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ySqvOrUNUcLNgpSLfBoPVxOCkmwqLzKPQHYEeRkwzleqLcrTYfrXhjiAE88957578() {     long oKbvdBVSvwZQOgNRrPjTXqHvd72059470 = -767575780;    long oKbvdBVSvwZQOgNRrPjTXqHvd38766591 = -874643147;    long oKbvdBVSvwZQOgNRrPjTXqHvd8933764 = -260089694;    long oKbvdBVSvwZQOgNRrPjTXqHvd47809432 = 26899302;    long oKbvdBVSvwZQOgNRrPjTXqHvd59042215 = -698538859;    long oKbvdBVSvwZQOgNRrPjTXqHvd22697940 = -15981493;    long oKbvdBVSvwZQOgNRrPjTXqHvd9576328 = -845453498;    long oKbvdBVSvwZQOgNRrPjTXqHvd91079789 = -971209862;    long oKbvdBVSvwZQOgNRrPjTXqHvd54793837 = -879281716;    long oKbvdBVSvwZQOgNRrPjTXqHvd87840532 = 74033626;    long oKbvdBVSvwZQOgNRrPjTXqHvd93226669 = -971831890;    long oKbvdBVSvwZQOgNRrPjTXqHvd1815793 = -440065156;    long oKbvdBVSvwZQOgNRrPjTXqHvd4402593 = -675990118;    long oKbvdBVSvwZQOgNRrPjTXqHvd52165446 = -952877422;    long oKbvdBVSvwZQOgNRrPjTXqHvd4684887 = -243536097;    long oKbvdBVSvwZQOgNRrPjTXqHvd85870889 = -238662351;    long oKbvdBVSvwZQOgNRrPjTXqHvd22854946 = -291245633;    long oKbvdBVSvwZQOgNRrPjTXqHvd59634251 = -48867605;    long oKbvdBVSvwZQOgNRrPjTXqHvd60572146 = -679316107;    long oKbvdBVSvwZQOgNRrPjTXqHvd22226455 = -437578142;    long oKbvdBVSvwZQOgNRrPjTXqHvd2045689 = -477192336;    long oKbvdBVSvwZQOgNRrPjTXqHvd16882307 = -626241541;    long oKbvdBVSvwZQOgNRrPjTXqHvd1758187 = 70371721;    long oKbvdBVSvwZQOgNRrPjTXqHvd54304892 = -929969516;    long oKbvdBVSvwZQOgNRrPjTXqHvd41209782 = -126201303;    long oKbvdBVSvwZQOgNRrPjTXqHvd4533730 = -31331471;    long oKbvdBVSvwZQOgNRrPjTXqHvd36213672 = -590127830;    long oKbvdBVSvwZQOgNRrPjTXqHvd6027479 = -104774834;    long oKbvdBVSvwZQOgNRrPjTXqHvd95835081 = -369071694;    long oKbvdBVSvwZQOgNRrPjTXqHvd95927592 = -341065140;    long oKbvdBVSvwZQOgNRrPjTXqHvd72007945 = -210816477;    long oKbvdBVSvwZQOgNRrPjTXqHvd57019242 = -480615282;    long oKbvdBVSvwZQOgNRrPjTXqHvd84051263 = -50866379;    long oKbvdBVSvwZQOgNRrPjTXqHvd97003980 = -645256714;    long oKbvdBVSvwZQOgNRrPjTXqHvd488102 = -106950649;    long oKbvdBVSvwZQOgNRrPjTXqHvd31128523 = -182227410;    long oKbvdBVSvwZQOgNRrPjTXqHvd26219492 = -449921010;    long oKbvdBVSvwZQOgNRrPjTXqHvd46096745 = -496616336;    long oKbvdBVSvwZQOgNRrPjTXqHvd66379315 = -104901753;    long oKbvdBVSvwZQOgNRrPjTXqHvd94849647 = -557173707;    long oKbvdBVSvwZQOgNRrPjTXqHvd32936067 = -442809898;    long oKbvdBVSvwZQOgNRrPjTXqHvd12773220 = -53316099;    long oKbvdBVSvwZQOgNRrPjTXqHvd64265879 = -199066933;    long oKbvdBVSvwZQOgNRrPjTXqHvd15652950 = -863020623;    long oKbvdBVSvwZQOgNRrPjTXqHvd29131465 = -529747804;    long oKbvdBVSvwZQOgNRrPjTXqHvd38894003 = -524613545;    long oKbvdBVSvwZQOgNRrPjTXqHvd18794689 = -536513050;    long oKbvdBVSvwZQOgNRrPjTXqHvd18941918 = -612654540;    long oKbvdBVSvwZQOgNRrPjTXqHvd66910845 = -525884782;    long oKbvdBVSvwZQOgNRrPjTXqHvd87056955 = -569318474;    long oKbvdBVSvwZQOgNRrPjTXqHvd66214429 = -285494963;    long oKbvdBVSvwZQOgNRrPjTXqHvd7304618 = -658318761;    long oKbvdBVSvwZQOgNRrPjTXqHvd68339784 = -161287915;    long oKbvdBVSvwZQOgNRrPjTXqHvd264778 = -464397875;    long oKbvdBVSvwZQOgNRrPjTXqHvd86911889 = -500643254;    long oKbvdBVSvwZQOgNRrPjTXqHvd55177164 = -41334239;    long oKbvdBVSvwZQOgNRrPjTXqHvd37008405 = -845014869;    long oKbvdBVSvwZQOgNRrPjTXqHvd54628871 = -330120179;    long oKbvdBVSvwZQOgNRrPjTXqHvd6599651 = -846899395;    long oKbvdBVSvwZQOgNRrPjTXqHvd54508486 = -567207388;    long oKbvdBVSvwZQOgNRrPjTXqHvd86484268 = -425853663;    long oKbvdBVSvwZQOgNRrPjTXqHvd3548849 = -640678664;    long oKbvdBVSvwZQOgNRrPjTXqHvd95244707 = -502138169;    long oKbvdBVSvwZQOgNRrPjTXqHvd58866245 = -438216577;    long oKbvdBVSvwZQOgNRrPjTXqHvd15832588 = -715149898;    long oKbvdBVSvwZQOgNRrPjTXqHvd36207428 = -391216608;    long oKbvdBVSvwZQOgNRrPjTXqHvd17764529 = -289198778;    long oKbvdBVSvwZQOgNRrPjTXqHvd7398612 = 69266596;    long oKbvdBVSvwZQOgNRrPjTXqHvd51677345 = -745926773;    long oKbvdBVSvwZQOgNRrPjTXqHvd73556363 = 38691312;    long oKbvdBVSvwZQOgNRrPjTXqHvd59651397 = -788741341;    long oKbvdBVSvwZQOgNRrPjTXqHvd76758201 = -794629298;    long oKbvdBVSvwZQOgNRrPjTXqHvd93254935 = -943965852;    long oKbvdBVSvwZQOgNRrPjTXqHvd65722498 = -22142400;    long oKbvdBVSvwZQOgNRrPjTXqHvd89290387 = -994768244;    long oKbvdBVSvwZQOgNRrPjTXqHvd89272469 = -323876238;    long oKbvdBVSvwZQOgNRrPjTXqHvd52616427 = -327174608;    long oKbvdBVSvwZQOgNRrPjTXqHvd86105237 = -66607656;    long oKbvdBVSvwZQOgNRrPjTXqHvd25173427 = -300221713;    long oKbvdBVSvwZQOgNRrPjTXqHvd2315780 = -601587759;    long oKbvdBVSvwZQOgNRrPjTXqHvd85739040 = -494818421;    long oKbvdBVSvwZQOgNRrPjTXqHvd17271755 = -977473291;    long oKbvdBVSvwZQOgNRrPjTXqHvd39116634 = -578890053;    long oKbvdBVSvwZQOgNRrPjTXqHvd8778127 = -799753221;    long oKbvdBVSvwZQOgNRrPjTXqHvd29713164 = 44429822;    long oKbvdBVSvwZQOgNRrPjTXqHvd64703328 = -552497716;    long oKbvdBVSvwZQOgNRrPjTXqHvd88679458 = -219327367;    long oKbvdBVSvwZQOgNRrPjTXqHvd83786486 = -586468504;    long oKbvdBVSvwZQOgNRrPjTXqHvd10092092 = -44613460;    long oKbvdBVSvwZQOgNRrPjTXqHvd45310937 = 34383590;    long oKbvdBVSvwZQOgNRrPjTXqHvd94120118 = -337212541;    long oKbvdBVSvwZQOgNRrPjTXqHvd71590621 = -19800832;    long oKbvdBVSvwZQOgNRrPjTXqHvd39497095 = -649716941;    long oKbvdBVSvwZQOgNRrPjTXqHvd11870830 = -537694366;    long oKbvdBVSvwZQOgNRrPjTXqHvd8365380 = -31320045;    long oKbvdBVSvwZQOgNRrPjTXqHvd29387219 = -802131234;    long oKbvdBVSvwZQOgNRrPjTXqHvd17528513 = -551177931;    long oKbvdBVSvwZQOgNRrPjTXqHvd5399635 = -760850357;    long oKbvdBVSvwZQOgNRrPjTXqHvd99820362 = -47870726;    long oKbvdBVSvwZQOgNRrPjTXqHvd92924037 = -767575780;     oKbvdBVSvwZQOgNRrPjTXqHvd72059470 = oKbvdBVSvwZQOgNRrPjTXqHvd38766591;     oKbvdBVSvwZQOgNRrPjTXqHvd38766591 = oKbvdBVSvwZQOgNRrPjTXqHvd8933764;     oKbvdBVSvwZQOgNRrPjTXqHvd8933764 = oKbvdBVSvwZQOgNRrPjTXqHvd47809432;     oKbvdBVSvwZQOgNRrPjTXqHvd47809432 = oKbvdBVSvwZQOgNRrPjTXqHvd59042215;     oKbvdBVSvwZQOgNRrPjTXqHvd59042215 = oKbvdBVSvwZQOgNRrPjTXqHvd22697940;     oKbvdBVSvwZQOgNRrPjTXqHvd22697940 = oKbvdBVSvwZQOgNRrPjTXqHvd9576328;     oKbvdBVSvwZQOgNRrPjTXqHvd9576328 = oKbvdBVSvwZQOgNRrPjTXqHvd91079789;     oKbvdBVSvwZQOgNRrPjTXqHvd91079789 = oKbvdBVSvwZQOgNRrPjTXqHvd54793837;     oKbvdBVSvwZQOgNRrPjTXqHvd54793837 = oKbvdBVSvwZQOgNRrPjTXqHvd87840532;     oKbvdBVSvwZQOgNRrPjTXqHvd87840532 = oKbvdBVSvwZQOgNRrPjTXqHvd93226669;     oKbvdBVSvwZQOgNRrPjTXqHvd93226669 = oKbvdBVSvwZQOgNRrPjTXqHvd1815793;     oKbvdBVSvwZQOgNRrPjTXqHvd1815793 = oKbvdBVSvwZQOgNRrPjTXqHvd4402593;     oKbvdBVSvwZQOgNRrPjTXqHvd4402593 = oKbvdBVSvwZQOgNRrPjTXqHvd52165446;     oKbvdBVSvwZQOgNRrPjTXqHvd52165446 = oKbvdBVSvwZQOgNRrPjTXqHvd4684887;     oKbvdBVSvwZQOgNRrPjTXqHvd4684887 = oKbvdBVSvwZQOgNRrPjTXqHvd85870889;     oKbvdBVSvwZQOgNRrPjTXqHvd85870889 = oKbvdBVSvwZQOgNRrPjTXqHvd22854946;     oKbvdBVSvwZQOgNRrPjTXqHvd22854946 = oKbvdBVSvwZQOgNRrPjTXqHvd59634251;     oKbvdBVSvwZQOgNRrPjTXqHvd59634251 = oKbvdBVSvwZQOgNRrPjTXqHvd60572146;     oKbvdBVSvwZQOgNRrPjTXqHvd60572146 = oKbvdBVSvwZQOgNRrPjTXqHvd22226455;     oKbvdBVSvwZQOgNRrPjTXqHvd22226455 = oKbvdBVSvwZQOgNRrPjTXqHvd2045689;     oKbvdBVSvwZQOgNRrPjTXqHvd2045689 = oKbvdBVSvwZQOgNRrPjTXqHvd16882307;     oKbvdBVSvwZQOgNRrPjTXqHvd16882307 = oKbvdBVSvwZQOgNRrPjTXqHvd1758187;     oKbvdBVSvwZQOgNRrPjTXqHvd1758187 = oKbvdBVSvwZQOgNRrPjTXqHvd54304892;     oKbvdBVSvwZQOgNRrPjTXqHvd54304892 = oKbvdBVSvwZQOgNRrPjTXqHvd41209782;     oKbvdBVSvwZQOgNRrPjTXqHvd41209782 = oKbvdBVSvwZQOgNRrPjTXqHvd4533730;     oKbvdBVSvwZQOgNRrPjTXqHvd4533730 = oKbvdBVSvwZQOgNRrPjTXqHvd36213672;     oKbvdBVSvwZQOgNRrPjTXqHvd36213672 = oKbvdBVSvwZQOgNRrPjTXqHvd6027479;     oKbvdBVSvwZQOgNRrPjTXqHvd6027479 = oKbvdBVSvwZQOgNRrPjTXqHvd95835081;     oKbvdBVSvwZQOgNRrPjTXqHvd95835081 = oKbvdBVSvwZQOgNRrPjTXqHvd95927592;     oKbvdBVSvwZQOgNRrPjTXqHvd95927592 = oKbvdBVSvwZQOgNRrPjTXqHvd72007945;     oKbvdBVSvwZQOgNRrPjTXqHvd72007945 = oKbvdBVSvwZQOgNRrPjTXqHvd57019242;     oKbvdBVSvwZQOgNRrPjTXqHvd57019242 = oKbvdBVSvwZQOgNRrPjTXqHvd84051263;     oKbvdBVSvwZQOgNRrPjTXqHvd84051263 = oKbvdBVSvwZQOgNRrPjTXqHvd97003980;     oKbvdBVSvwZQOgNRrPjTXqHvd97003980 = oKbvdBVSvwZQOgNRrPjTXqHvd488102;     oKbvdBVSvwZQOgNRrPjTXqHvd488102 = oKbvdBVSvwZQOgNRrPjTXqHvd31128523;     oKbvdBVSvwZQOgNRrPjTXqHvd31128523 = oKbvdBVSvwZQOgNRrPjTXqHvd26219492;     oKbvdBVSvwZQOgNRrPjTXqHvd26219492 = oKbvdBVSvwZQOgNRrPjTXqHvd46096745;     oKbvdBVSvwZQOgNRrPjTXqHvd46096745 = oKbvdBVSvwZQOgNRrPjTXqHvd66379315;     oKbvdBVSvwZQOgNRrPjTXqHvd66379315 = oKbvdBVSvwZQOgNRrPjTXqHvd94849647;     oKbvdBVSvwZQOgNRrPjTXqHvd94849647 = oKbvdBVSvwZQOgNRrPjTXqHvd32936067;     oKbvdBVSvwZQOgNRrPjTXqHvd32936067 = oKbvdBVSvwZQOgNRrPjTXqHvd12773220;     oKbvdBVSvwZQOgNRrPjTXqHvd12773220 = oKbvdBVSvwZQOgNRrPjTXqHvd64265879;     oKbvdBVSvwZQOgNRrPjTXqHvd64265879 = oKbvdBVSvwZQOgNRrPjTXqHvd15652950;     oKbvdBVSvwZQOgNRrPjTXqHvd15652950 = oKbvdBVSvwZQOgNRrPjTXqHvd29131465;     oKbvdBVSvwZQOgNRrPjTXqHvd29131465 = oKbvdBVSvwZQOgNRrPjTXqHvd38894003;     oKbvdBVSvwZQOgNRrPjTXqHvd38894003 = oKbvdBVSvwZQOgNRrPjTXqHvd18794689;     oKbvdBVSvwZQOgNRrPjTXqHvd18794689 = oKbvdBVSvwZQOgNRrPjTXqHvd18941918;     oKbvdBVSvwZQOgNRrPjTXqHvd18941918 = oKbvdBVSvwZQOgNRrPjTXqHvd66910845;     oKbvdBVSvwZQOgNRrPjTXqHvd66910845 = oKbvdBVSvwZQOgNRrPjTXqHvd87056955;     oKbvdBVSvwZQOgNRrPjTXqHvd87056955 = oKbvdBVSvwZQOgNRrPjTXqHvd66214429;     oKbvdBVSvwZQOgNRrPjTXqHvd66214429 = oKbvdBVSvwZQOgNRrPjTXqHvd7304618;     oKbvdBVSvwZQOgNRrPjTXqHvd7304618 = oKbvdBVSvwZQOgNRrPjTXqHvd68339784;     oKbvdBVSvwZQOgNRrPjTXqHvd68339784 = oKbvdBVSvwZQOgNRrPjTXqHvd264778;     oKbvdBVSvwZQOgNRrPjTXqHvd264778 = oKbvdBVSvwZQOgNRrPjTXqHvd86911889;     oKbvdBVSvwZQOgNRrPjTXqHvd86911889 = oKbvdBVSvwZQOgNRrPjTXqHvd55177164;     oKbvdBVSvwZQOgNRrPjTXqHvd55177164 = oKbvdBVSvwZQOgNRrPjTXqHvd37008405;     oKbvdBVSvwZQOgNRrPjTXqHvd37008405 = oKbvdBVSvwZQOgNRrPjTXqHvd54628871;     oKbvdBVSvwZQOgNRrPjTXqHvd54628871 = oKbvdBVSvwZQOgNRrPjTXqHvd6599651;     oKbvdBVSvwZQOgNRrPjTXqHvd6599651 = oKbvdBVSvwZQOgNRrPjTXqHvd54508486;     oKbvdBVSvwZQOgNRrPjTXqHvd54508486 = oKbvdBVSvwZQOgNRrPjTXqHvd86484268;     oKbvdBVSvwZQOgNRrPjTXqHvd86484268 = oKbvdBVSvwZQOgNRrPjTXqHvd3548849;     oKbvdBVSvwZQOgNRrPjTXqHvd3548849 = oKbvdBVSvwZQOgNRrPjTXqHvd95244707;     oKbvdBVSvwZQOgNRrPjTXqHvd95244707 = oKbvdBVSvwZQOgNRrPjTXqHvd58866245;     oKbvdBVSvwZQOgNRrPjTXqHvd58866245 = oKbvdBVSvwZQOgNRrPjTXqHvd15832588;     oKbvdBVSvwZQOgNRrPjTXqHvd15832588 = oKbvdBVSvwZQOgNRrPjTXqHvd36207428;     oKbvdBVSvwZQOgNRrPjTXqHvd36207428 = oKbvdBVSvwZQOgNRrPjTXqHvd17764529;     oKbvdBVSvwZQOgNRrPjTXqHvd17764529 = oKbvdBVSvwZQOgNRrPjTXqHvd7398612;     oKbvdBVSvwZQOgNRrPjTXqHvd7398612 = oKbvdBVSvwZQOgNRrPjTXqHvd51677345;     oKbvdBVSvwZQOgNRrPjTXqHvd51677345 = oKbvdBVSvwZQOgNRrPjTXqHvd73556363;     oKbvdBVSvwZQOgNRrPjTXqHvd73556363 = oKbvdBVSvwZQOgNRrPjTXqHvd59651397;     oKbvdBVSvwZQOgNRrPjTXqHvd59651397 = oKbvdBVSvwZQOgNRrPjTXqHvd76758201;     oKbvdBVSvwZQOgNRrPjTXqHvd76758201 = oKbvdBVSvwZQOgNRrPjTXqHvd93254935;     oKbvdBVSvwZQOgNRrPjTXqHvd93254935 = oKbvdBVSvwZQOgNRrPjTXqHvd65722498;     oKbvdBVSvwZQOgNRrPjTXqHvd65722498 = oKbvdBVSvwZQOgNRrPjTXqHvd89290387;     oKbvdBVSvwZQOgNRrPjTXqHvd89290387 = oKbvdBVSvwZQOgNRrPjTXqHvd89272469;     oKbvdBVSvwZQOgNRrPjTXqHvd89272469 = oKbvdBVSvwZQOgNRrPjTXqHvd52616427;     oKbvdBVSvwZQOgNRrPjTXqHvd52616427 = oKbvdBVSvwZQOgNRrPjTXqHvd86105237;     oKbvdBVSvwZQOgNRrPjTXqHvd86105237 = oKbvdBVSvwZQOgNRrPjTXqHvd25173427;     oKbvdBVSvwZQOgNRrPjTXqHvd25173427 = oKbvdBVSvwZQOgNRrPjTXqHvd2315780;     oKbvdBVSvwZQOgNRrPjTXqHvd2315780 = oKbvdBVSvwZQOgNRrPjTXqHvd85739040;     oKbvdBVSvwZQOgNRrPjTXqHvd85739040 = oKbvdBVSvwZQOgNRrPjTXqHvd17271755;     oKbvdBVSvwZQOgNRrPjTXqHvd17271755 = oKbvdBVSvwZQOgNRrPjTXqHvd39116634;     oKbvdBVSvwZQOgNRrPjTXqHvd39116634 = oKbvdBVSvwZQOgNRrPjTXqHvd8778127;     oKbvdBVSvwZQOgNRrPjTXqHvd8778127 = oKbvdBVSvwZQOgNRrPjTXqHvd29713164;     oKbvdBVSvwZQOgNRrPjTXqHvd29713164 = oKbvdBVSvwZQOgNRrPjTXqHvd64703328;     oKbvdBVSvwZQOgNRrPjTXqHvd64703328 = oKbvdBVSvwZQOgNRrPjTXqHvd88679458;     oKbvdBVSvwZQOgNRrPjTXqHvd88679458 = oKbvdBVSvwZQOgNRrPjTXqHvd83786486;     oKbvdBVSvwZQOgNRrPjTXqHvd83786486 = oKbvdBVSvwZQOgNRrPjTXqHvd10092092;     oKbvdBVSvwZQOgNRrPjTXqHvd10092092 = oKbvdBVSvwZQOgNRrPjTXqHvd45310937;     oKbvdBVSvwZQOgNRrPjTXqHvd45310937 = oKbvdBVSvwZQOgNRrPjTXqHvd94120118;     oKbvdBVSvwZQOgNRrPjTXqHvd94120118 = oKbvdBVSvwZQOgNRrPjTXqHvd71590621;     oKbvdBVSvwZQOgNRrPjTXqHvd71590621 = oKbvdBVSvwZQOgNRrPjTXqHvd39497095;     oKbvdBVSvwZQOgNRrPjTXqHvd39497095 = oKbvdBVSvwZQOgNRrPjTXqHvd11870830;     oKbvdBVSvwZQOgNRrPjTXqHvd11870830 = oKbvdBVSvwZQOgNRrPjTXqHvd8365380;     oKbvdBVSvwZQOgNRrPjTXqHvd8365380 = oKbvdBVSvwZQOgNRrPjTXqHvd29387219;     oKbvdBVSvwZQOgNRrPjTXqHvd29387219 = oKbvdBVSvwZQOgNRrPjTXqHvd17528513;     oKbvdBVSvwZQOgNRrPjTXqHvd17528513 = oKbvdBVSvwZQOgNRrPjTXqHvd5399635;     oKbvdBVSvwZQOgNRrPjTXqHvd5399635 = oKbvdBVSvwZQOgNRrPjTXqHvd99820362;     oKbvdBVSvwZQOgNRrPjTXqHvd99820362 = oKbvdBVSvwZQOgNRrPjTXqHvd92924037;     oKbvdBVSvwZQOgNRrPjTXqHvd92924037 = oKbvdBVSvwZQOgNRrPjTXqHvd72059470;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void DQnxIMeenddzttsDUwMfzOgBGYrmhtTmUdREGQHaEOLGfOVWctvZGzook56249177() {     long mqjUswuJrfPbnxEplblCaWsDV7518440 = -133852680;    long mqjUswuJrfPbnxEplblCaWsDV52038670 = -755194754;    long mqjUswuJrfPbnxEplblCaWsDV46320240 = 74243231;    long mqjUswuJrfPbnxEplblCaWsDV20032787 = -894251769;    long mqjUswuJrfPbnxEplblCaWsDV15327485 = -804137704;    long mqjUswuJrfPbnxEplblCaWsDV58920812 = -278329388;    long mqjUswuJrfPbnxEplblCaWsDV20233734 = -690179232;    long mqjUswuJrfPbnxEplblCaWsDV53211350 = -615444003;    long mqjUswuJrfPbnxEplblCaWsDV56311443 = -267613123;    long mqjUswuJrfPbnxEplblCaWsDV2743245 = -690653372;    long mqjUswuJrfPbnxEplblCaWsDV31408405 = -773839619;    long mqjUswuJrfPbnxEplblCaWsDV2383941 = -304185927;    long mqjUswuJrfPbnxEplblCaWsDV42637238 = -128002622;    long mqjUswuJrfPbnxEplblCaWsDV5306310 = -929240831;    long mqjUswuJrfPbnxEplblCaWsDV62879402 = -746961112;    long mqjUswuJrfPbnxEplblCaWsDV69412190 = -974473958;    long mqjUswuJrfPbnxEplblCaWsDV78690881 = -818220186;    long mqjUswuJrfPbnxEplblCaWsDV59394442 = -122295674;    long mqjUswuJrfPbnxEplblCaWsDV61122476 = -995879528;    long mqjUswuJrfPbnxEplblCaWsDV16063674 = -864139208;    long mqjUswuJrfPbnxEplblCaWsDV15132552 = -134467025;    long mqjUswuJrfPbnxEplblCaWsDV20303831 = -712877835;    long mqjUswuJrfPbnxEplblCaWsDV72283566 = -667260463;    long mqjUswuJrfPbnxEplblCaWsDV48097837 = -340794120;    long mqjUswuJrfPbnxEplblCaWsDV49227733 = -150186501;    long mqjUswuJrfPbnxEplblCaWsDV15231901 = -819908277;    long mqjUswuJrfPbnxEplblCaWsDV96634246 = -396411971;    long mqjUswuJrfPbnxEplblCaWsDV46755904 = -274547009;    long mqjUswuJrfPbnxEplblCaWsDV42503296 = -943166496;    long mqjUswuJrfPbnxEplblCaWsDV1461004 = -375572311;    long mqjUswuJrfPbnxEplblCaWsDV90591176 = -762796964;    long mqjUswuJrfPbnxEplblCaWsDV94842260 = -253586697;    long mqjUswuJrfPbnxEplblCaWsDV96269274 = -198462356;    long mqjUswuJrfPbnxEplblCaWsDV26752407 = -709950527;    long mqjUswuJrfPbnxEplblCaWsDV66296555 = -58050900;    long mqjUswuJrfPbnxEplblCaWsDV82689366 = -396792715;    long mqjUswuJrfPbnxEplblCaWsDV75631308 = -314617050;    long mqjUswuJrfPbnxEplblCaWsDV97312148 = -479271917;    long mqjUswuJrfPbnxEplblCaWsDV96769877 = -855778030;    long mqjUswuJrfPbnxEplblCaWsDV59121180 = -22436253;    long mqjUswuJrfPbnxEplblCaWsDV66387675 = -212008813;    long mqjUswuJrfPbnxEplblCaWsDV2138347 = -747861390;    long mqjUswuJrfPbnxEplblCaWsDV53649258 = -852247719;    long mqjUswuJrfPbnxEplblCaWsDV55784288 = -367353033;    long mqjUswuJrfPbnxEplblCaWsDV29147924 = -356258965;    long mqjUswuJrfPbnxEplblCaWsDV84855331 = -563537177;    long mqjUswuJrfPbnxEplblCaWsDV38139853 = 79500590;    long mqjUswuJrfPbnxEplblCaWsDV36668230 = -779181133;    long mqjUswuJrfPbnxEplblCaWsDV89803511 = -189621662;    long mqjUswuJrfPbnxEplblCaWsDV11586545 = 39654710;    long mqjUswuJrfPbnxEplblCaWsDV46985153 = -159771520;    long mqjUswuJrfPbnxEplblCaWsDV90790089 = -871971108;    long mqjUswuJrfPbnxEplblCaWsDV36960932 = 82666531;    long mqjUswuJrfPbnxEplblCaWsDV16256624 = -655906375;    long mqjUswuJrfPbnxEplblCaWsDV41116626 = -847133400;    long mqjUswuJrfPbnxEplblCaWsDV87214608 = -420974845;    long mqjUswuJrfPbnxEplblCaWsDV79755103 = 12065709;    long mqjUswuJrfPbnxEplblCaWsDV98222402 = -584962650;    long mqjUswuJrfPbnxEplblCaWsDV70805054 = -644065268;    long mqjUswuJrfPbnxEplblCaWsDV95584 = -984229427;    long mqjUswuJrfPbnxEplblCaWsDV62286566 = -881917417;    long mqjUswuJrfPbnxEplblCaWsDV73477830 = -315632224;    long mqjUswuJrfPbnxEplblCaWsDV10708054 = -672277507;    long mqjUswuJrfPbnxEplblCaWsDV54850439 = -892040813;    long mqjUswuJrfPbnxEplblCaWsDV12152068 = -927856409;    long mqjUswuJrfPbnxEplblCaWsDV36566144 = -420252923;    long mqjUswuJrfPbnxEplblCaWsDV6114666 = -5723572;    long mqjUswuJrfPbnxEplblCaWsDV15884831 = -418052096;    long mqjUswuJrfPbnxEplblCaWsDV39009754 = -771189932;    long mqjUswuJrfPbnxEplblCaWsDV80190036 = -250168397;    long mqjUswuJrfPbnxEplblCaWsDV93780881 = -559856908;    long mqjUswuJrfPbnxEplblCaWsDV81378733 = -238948270;    long mqjUswuJrfPbnxEplblCaWsDV62624565 = -266517645;    long mqjUswuJrfPbnxEplblCaWsDV2001297 = -873443276;    long mqjUswuJrfPbnxEplblCaWsDV49675999 = -552130396;    long mqjUswuJrfPbnxEplblCaWsDV12994205 = -386605635;    long mqjUswuJrfPbnxEplblCaWsDV66654573 = -860630116;    long mqjUswuJrfPbnxEplblCaWsDV16499279 = -199907431;    long mqjUswuJrfPbnxEplblCaWsDV18949914 = -984535156;    long mqjUswuJrfPbnxEplblCaWsDV64372402 = -586649325;    long mqjUswuJrfPbnxEplblCaWsDV77092048 = -799408868;    long mqjUswuJrfPbnxEplblCaWsDV59966016 = -617230838;    long mqjUswuJrfPbnxEplblCaWsDV56952392 = 15074653;    long mqjUswuJrfPbnxEplblCaWsDV30916752 = -882821207;    long mqjUswuJrfPbnxEplblCaWsDV54475851 = -115800791;    long mqjUswuJrfPbnxEplblCaWsDV99801086 = -890825856;    long mqjUswuJrfPbnxEplblCaWsDV57881328 = -236253228;    long mqjUswuJrfPbnxEplblCaWsDV80012650 = -542555982;    long mqjUswuJrfPbnxEplblCaWsDV85635781 = -862817128;    long mqjUswuJrfPbnxEplblCaWsDV79081947 = -637076055;    long mqjUswuJrfPbnxEplblCaWsDV2934264 = -308858425;    long mqjUswuJrfPbnxEplblCaWsDV77408906 = -729654401;    long mqjUswuJrfPbnxEplblCaWsDV26507094 = -835206649;    long mqjUswuJrfPbnxEplblCaWsDV96674293 = -871548603;    long mqjUswuJrfPbnxEplblCaWsDV96834614 = -140518836;    long mqjUswuJrfPbnxEplblCaWsDV92909845 = -896376589;    long mqjUswuJrfPbnxEplblCaWsDV91430292 = 24416116;    long mqjUswuJrfPbnxEplblCaWsDV98798818 = -960206906;    long mqjUswuJrfPbnxEplblCaWsDV43632220 = -439496625;    long mqjUswuJrfPbnxEplblCaWsDV92581779 = -133852680;     mqjUswuJrfPbnxEplblCaWsDV7518440 = mqjUswuJrfPbnxEplblCaWsDV52038670;     mqjUswuJrfPbnxEplblCaWsDV52038670 = mqjUswuJrfPbnxEplblCaWsDV46320240;     mqjUswuJrfPbnxEplblCaWsDV46320240 = mqjUswuJrfPbnxEplblCaWsDV20032787;     mqjUswuJrfPbnxEplblCaWsDV20032787 = mqjUswuJrfPbnxEplblCaWsDV15327485;     mqjUswuJrfPbnxEplblCaWsDV15327485 = mqjUswuJrfPbnxEplblCaWsDV58920812;     mqjUswuJrfPbnxEplblCaWsDV58920812 = mqjUswuJrfPbnxEplblCaWsDV20233734;     mqjUswuJrfPbnxEplblCaWsDV20233734 = mqjUswuJrfPbnxEplblCaWsDV53211350;     mqjUswuJrfPbnxEplblCaWsDV53211350 = mqjUswuJrfPbnxEplblCaWsDV56311443;     mqjUswuJrfPbnxEplblCaWsDV56311443 = mqjUswuJrfPbnxEplblCaWsDV2743245;     mqjUswuJrfPbnxEplblCaWsDV2743245 = mqjUswuJrfPbnxEplblCaWsDV31408405;     mqjUswuJrfPbnxEplblCaWsDV31408405 = mqjUswuJrfPbnxEplblCaWsDV2383941;     mqjUswuJrfPbnxEplblCaWsDV2383941 = mqjUswuJrfPbnxEplblCaWsDV42637238;     mqjUswuJrfPbnxEplblCaWsDV42637238 = mqjUswuJrfPbnxEplblCaWsDV5306310;     mqjUswuJrfPbnxEplblCaWsDV5306310 = mqjUswuJrfPbnxEplblCaWsDV62879402;     mqjUswuJrfPbnxEplblCaWsDV62879402 = mqjUswuJrfPbnxEplblCaWsDV69412190;     mqjUswuJrfPbnxEplblCaWsDV69412190 = mqjUswuJrfPbnxEplblCaWsDV78690881;     mqjUswuJrfPbnxEplblCaWsDV78690881 = mqjUswuJrfPbnxEplblCaWsDV59394442;     mqjUswuJrfPbnxEplblCaWsDV59394442 = mqjUswuJrfPbnxEplblCaWsDV61122476;     mqjUswuJrfPbnxEplblCaWsDV61122476 = mqjUswuJrfPbnxEplblCaWsDV16063674;     mqjUswuJrfPbnxEplblCaWsDV16063674 = mqjUswuJrfPbnxEplblCaWsDV15132552;     mqjUswuJrfPbnxEplblCaWsDV15132552 = mqjUswuJrfPbnxEplblCaWsDV20303831;     mqjUswuJrfPbnxEplblCaWsDV20303831 = mqjUswuJrfPbnxEplblCaWsDV72283566;     mqjUswuJrfPbnxEplblCaWsDV72283566 = mqjUswuJrfPbnxEplblCaWsDV48097837;     mqjUswuJrfPbnxEplblCaWsDV48097837 = mqjUswuJrfPbnxEplblCaWsDV49227733;     mqjUswuJrfPbnxEplblCaWsDV49227733 = mqjUswuJrfPbnxEplblCaWsDV15231901;     mqjUswuJrfPbnxEplblCaWsDV15231901 = mqjUswuJrfPbnxEplblCaWsDV96634246;     mqjUswuJrfPbnxEplblCaWsDV96634246 = mqjUswuJrfPbnxEplblCaWsDV46755904;     mqjUswuJrfPbnxEplblCaWsDV46755904 = mqjUswuJrfPbnxEplblCaWsDV42503296;     mqjUswuJrfPbnxEplblCaWsDV42503296 = mqjUswuJrfPbnxEplblCaWsDV1461004;     mqjUswuJrfPbnxEplblCaWsDV1461004 = mqjUswuJrfPbnxEplblCaWsDV90591176;     mqjUswuJrfPbnxEplblCaWsDV90591176 = mqjUswuJrfPbnxEplblCaWsDV94842260;     mqjUswuJrfPbnxEplblCaWsDV94842260 = mqjUswuJrfPbnxEplblCaWsDV96269274;     mqjUswuJrfPbnxEplblCaWsDV96269274 = mqjUswuJrfPbnxEplblCaWsDV26752407;     mqjUswuJrfPbnxEplblCaWsDV26752407 = mqjUswuJrfPbnxEplblCaWsDV66296555;     mqjUswuJrfPbnxEplblCaWsDV66296555 = mqjUswuJrfPbnxEplblCaWsDV82689366;     mqjUswuJrfPbnxEplblCaWsDV82689366 = mqjUswuJrfPbnxEplblCaWsDV75631308;     mqjUswuJrfPbnxEplblCaWsDV75631308 = mqjUswuJrfPbnxEplblCaWsDV97312148;     mqjUswuJrfPbnxEplblCaWsDV97312148 = mqjUswuJrfPbnxEplblCaWsDV96769877;     mqjUswuJrfPbnxEplblCaWsDV96769877 = mqjUswuJrfPbnxEplblCaWsDV59121180;     mqjUswuJrfPbnxEplblCaWsDV59121180 = mqjUswuJrfPbnxEplblCaWsDV66387675;     mqjUswuJrfPbnxEplblCaWsDV66387675 = mqjUswuJrfPbnxEplblCaWsDV2138347;     mqjUswuJrfPbnxEplblCaWsDV2138347 = mqjUswuJrfPbnxEplblCaWsDV53649258;     mqjUswuJrfPbnxEplblCaWsDV53649258 = mqjUswuJrfPbnxEplblCaWsDV55784288;     mqjUswuJrfPbnxEplblCaWsDV55784288 = mqjUswuJrfPbnxEplblCaWsDV29147924;     mqjUswuJrfPbnxEplblCaWsDV29147924 = mqjUswuJrfPbnxEplblCaWsDV84855331;     mqjUswuJrfPbnxEplblCaWsDV84855331 = mqjUswuJrfPbnxEplblCaWsDV38139853;     mqjUswuJrfPbnxEplblCaWsDV38139853 = mqjUswuJrfPbnxEplblCaWsDV36668230;     mqjUswuJrfPbnxEplblCaWsDV36668230 = mqjUswuJrfPbnxEplblCaWsDV89803511;     mqjUswuJrfPbnxEplblCaWsDV89803511 = mqjUswuJrfPbnxEplblCaWsDV11586545;     mqjUswuJrfPbnxEplblCaWsDV11586545 = mqjUswuJrfPbnxEplblCaWsDV46985153;     mqjUswuJrfPbnxEplblCaWsDV46985153 = mqjUswuJrfPbnxEplblCaWsDV90790089;     mqjUswuJrfPbnxEplblCaWsDV90790089 = mqjUswuJrfPbnxEplblCaWsDV36960932;     mqjUswuJrfPbnxEplblCaWsDV36960932 = mqjUswuJrfPbnxEplblCaWsDV16256624;     mqjUswuJrfPbnxEplblCaWsDV16256624 = mqjUswuJrfPbnxEplblCaWsDV41116626;     mqjUswuJrfPbnxEplblCaWsDV41116626 = mqjUswuJrfPbnxEplblCaWsDV87214608;     mqjUswuJrfPbnxEplblCaWsDV87214608 = mqjUswuJrfPbnxEplblCaWsDV79755103;     mqjUswuJrfPbnxEplblCaWsDV79755103 = mqjUswuJrfPbnxEplblCaWsDV98222402;     mqjUswuJrfPbnxEplblCaWsDV98222402 = mqjUswuJrfPbnxEplblCaWsDV70805054;     mqjUswuJrfPbnxEplblCaWsDV70805054 = mqjUswuJrfPbnxEplblCaWsDV95584;     mqjUswuJrfPbnxEplblCaWsDV95584 = mqjUswuJrfPbnxEplblCaWsDV62286566;     mqjUswuJrfPbnxEplblCaWsDV62286566 = mqjUswuJrfPbnxEplblCaWsDV73477830;     mqjUswuJrfPbnxEplblCaWsDV73477830 = mqjUswuJrfPbnxEplblCaWsDV10708054;     mqjUswuJrfPbnxEplblCaWsDV10708054 = mqjUswuJrfPbnxEplblCaWsDV54850439;     mqjUswuJrfPbnxEplblCaWsDV54850439 = mqjUswuJrfPbnxEplblCaWsDV12152068;     mqjUswuJrfPbnxEplblCaWsDV12152068 = mqjUswuJrfPbnxEplblCaWsDV36566144;     mqjUswuJrfPbnxEplblCaWsDV36566144 = mqjUswuJrfPbnxEplblCaWsDV6114666;     mqjUswuJrfPbnxEplblCaWsDV6114666 = mqjUswuJrfPbnxEplblCaWsDV15884831;     mqjUswuJrfPbnxEplblCaWsDV15884831 = mqjUswuJrfPbnxEplblCaWsDV39009754;     mqjUswuJrfPbnxEplblCaWsDV39009754 = mqjUswuJrfPbnxEplblCaWsDV80190036;     mqjUswuJrfPbnxEplblCaWsDV80190036 = mqjUswuJrfPbnxEplblCaWsDV93780881;     mqjUswuJrfPbnxEplblCaWsDV93780881 = mqjUswuJrfPbnxEplblCaWsDV81378733;     mqjUswuJrfPbnxEplblCaWsDV81378733 = mqjUswuJrfPbnxEplblCaWsDV62624565;     mqjUswuJrfPbnxEplblCaWsDV62624565 = mqjUswuJrfPbnxEplblCaWsDV2001297;     mqjUswuJrfPbnxEplblCaWsDV2001297 = mqjUswuJrfPbnxEplblCaWsDV49675999;     mqjUswuJrfPbnxEplblCaWsDV49675999 = mqjUswuJrfPbnxEplblCaWsDV12994205;     mqjUswuJrfPbnxEplblCaWsDV12994205 = mqjUswuJrfPbnxEplblCaWsDV66654573;     mqjUswuJrfPbnxEplblCaWsDV66654573 = mqjUswuJrfPbnxEplblCaWsDV16499279;     mqjUswuJrfPbnxEplblCaWsDV16499279 = mqjUswuJrfPbnxEplblCaWsDV18949914;     mqjUswuJrfPbnxEplblCaWsDV18949914 = mqjUswuJrfPbnxEplblCaWsDV64372402;     mqjUswuJrfPbnxEplblCaWsDV64372402 = mqjUswuJrfPbnxEplblCaWsDV77092048;     mqjUswuJrfPbnxEplblCaWsDV77092048 = mqjUswuJrfPbnxEplblCaWsDV59966016;     mqjUswuJrfPbnxEplblCaWsDV59966016 = mqjUswuJrfPbnxEplblCaWsDV56952392;     mqjUswuJrfPbnxEplblCaWsDV56952392 = mqjUswuJrfPbnxEplblCaWsDV30916752;     mqjUswuJrfPbnxEplblCaWsDV30916752 = mqjUswuJrfPbnxEplblCaWsDV54475851;     mqjUswuJrfPbnxEplblCaWsDV54475851 = mqjUswuJrfPbnxEplblCaWsDV99801086;     mqjUswuJrfPbnxEplblCaWsDV99801086 = mqjUswuJrfPbnxEplblCaWsDV57881328;     mqjUswuJrfPbnxEplblCaWsDV57881328 = mqjUswuJrfPbnxEplblCaWsDV80012650;     mqjUswuJrfPbnxEplblCaWsDV80012650 = mqjUswuJrfPbnxEplblCaWsDV85635781;     mqjUswuJrfPbnxEplblCaWsDV85635781 = mqjUswuJrfPbnxEplblCaWsDV79081947;     mqjUswuJrfPbnxEplblCaWsDV79081947 = mqjUswuJrfPbnxEplblCaWsDV2934264;     mqjUswuJrfPbnxEplblCaWsDV2934264 = mqjUswuJrfPbnxEplblCaWsDV77408906;     mqjUswuJrfPbnxEplblCaWsDV77408906 = mqjUswuJrfPbnxEplblCaWsDV26507094;     mqjUswuJrfPbnxEplblCaWsDV26507094 = mqjUswuJrfPbnxEplblCaWsDV96674293;     mqjUswuJrfPbnxEplblCaWsDV96674293 = mqjUswuJrfPbnxEplblCaWsDV96834614;     mqjUswuJrfPbnxEplblCaWsDV96834614 = mqjUswuJrfPbnxEplblCaWsDV92909845;     mqjUswuJrfPbnxEplblCaWsDV92909845 = mqjUswuJrfPbnxEplblCaWsDV91430292;     mqjUswuJrfPbnxEplblCaWsDV91430292 = mqjUswuJrfPbnxEplblCaWsDV98798818;     mqjUswuJrfPbnxEplblCaWsDV98798818 = mqjUswuJrfPbnxEplblCaWsDV43632220;     mqjUswuJrfPbnxEplblCaWsDV43632220 = mqjUswuJrfPbnxEplblCaWsDV92581779;     mqjUswuJrfPbnxEplblCaWsDV92581779 = mqjUswuJrfPbnxEplblCaWsDV7518440;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void aJootryuODsmQpQDoqFIFNZTEDCexgJwgqSpskHYYprPfAsGWAwnsHLMj71298245() {     long VkpoUxhuvFaWaLDihkPVKoDKw13635546 = -245754568;    long VkpoUxhuvFaWaLDihkPVKoDKw95411949 = -464794535;    long VkpoUxhuvFaWaLDihkPVKoDKw62362423 = -76589690;    long VkpoUxhuvFaWaLDihkPVKoDKw47107568 = 14999601;    long VkpoUxhuvFaWaLDihkPVKoDKw84222973 = -224787575;    long VkpoUxhuvFaWaLDihkPVKoDKw50338015 = -542825623;    long VkpoUxhuvFaWaLDihkPVKoDKw80722700 = -829144210;    long VkpoUxhuvFaWaLDihkPVKoDKw2971241 = -902317916;    long VkpoUxhuvFaWaLDihkPVKoDKw20953938 = -35645789;    long VkpoUxhuvFaWaLDihkPVKoDKw43972904 = 80371150;    long VkpoUxhuvFaWaLDihkPVKoDKw91518694 = -651277205;    long VkpoUxhuvFaWaLDihkPVKoDKw34206983 = -748592129;    long VkpoUxhuvFaWaLDihkPVKoDKw28846356 = -567893711;    long VkpoUxhuvFaWaLDihkPVKoDKw88449986 = -361479399;    long VkpoUxhuvFaWaLDihkPVKoDKw58621829 = -337423278;    long VkpoUxhuvFaWaLDihkPVKoDKw10917584 = -947473501;    long VkpoUxhuvFaWaLDihkPVKoDKw72526884 = -334765299;    long VkpoUxhuvFaWaLDihkPVKoDKw56447595 = -887818317;    long VkpoUxhuvFaWaLDihkPVKoDKw22952318 = -301648625;    long VkpoUxhuvFaWaLDihkPVKoDKw96613838 = -121042127;    long VkpoUxhuvFaWaLDihkPVKoDKw3685745 = 10045520;    long VkpoUxhuvFaWaLDihkPVKoDKw6824855 = -620807551;    long VkpoUxhuvFaWaLDihkPVKoDKw7874359 = -413777950;    long VkpoUxhuvFaWaLDihkPVKoDKw32090211 = -563099108;    long VkpoUxhuvFaWaLDihkPVKoDKw92927383 = -523382534;    long VkpoUxhuvFaWaLDihkPVKoDKw39953576 = -698563601;    long VkpoUxhuvFaWaLDihkPVKoDKw95094024 = -297074174;    long VkpoUxhuvFaWaLDihkPVKoDKw59863029 = -340475962;    long VkpoUxhuvFaWaLDihkPVKoDKw8635552 = -65549201;    long VkpoUxhuvFaWaLDihkPVKoDKw70076640 = -193043178;    long VkpoUxhuvFaWaLDihkPVKoDKw82833726 = -676117902;    long VkpoUxhuvFaWaLDihkPVKoDKw92452882 = 36966488;    long VkpoUxhuvFaWaLDihkPVKoDKw5980224 = -91075726;    long VkpoUxhuvFaWaLDihkPVKoDKw21582972 = -461492293;    long VkpoUxhuvFaWaLDihkPVKoDKw27771207 = -696784005;    long VkpoUxhuvFaWaLDihkPVKoDKw51415280 = -610818823;    long VkpoUxhuvFaWaLDihkPVKoDKw56893243 = -268252920;    long VkpoUxhuvFaWaLDihkPVKoDKw31402361 = -250777926;    long VkpoUxhuvFaWaLDihkPVKoDKw70380131 = -849701527;    long VkpoUxhuvFaWaLDihkPVKoDKw46623118 = -495875476;    long VkpoUxhuvFaWaLDihkPVKoDKw72056899 = -277282707;    long VkpoUxhuvFaWaLDihkPVKoDKw34288804 = 81996332;    long VkpoUxhuvFaWaLDihkPVKoDKw31716236 = -933052303;    long VkpoUxhuvFaWaLDihkPVKoDKw43192028 = -386695971;    long VkpoUxhuvFaWaLDihkPVKoDKw41100389 = -18157119;    long VkpoUxhuvFaWaLDihkPVKoDKw96794526 = -548753293;    long VkpoUxhuvFaWaLDihkPVKoDKw55918427 = -39274948;    long VkpoUxhuvFaWaLDihkPVKoDKw44625171 = -789076666;    long VkpoUxhuvFaWaLDihkPVKoDKw99479240 = -275358650;    long VkpoUxhuvFaWaLDihkPVKoDKw24498197 = -47356098;    long VkpoUxhuvFaWaLDihkPVKoDKw82685831 = -2065191;    long VkpoUxhuvFaWaLDihkPVKoDKw1599810 = -672697428;    long VkpoUxhuvFaWaLDihkPVKoDKw85209389 = -809123057;    long VkpoUxhuvFaWaLDihkPVKoDKw12225504 = -976376520;    long VkpoUxhuvFaWaLDihkPVKoDKw67612500 = -447665182;    long VkpoUxhuvFaWaLDihkPVKoDKw6810692 = -624947018;    long VkpoUxhuvFaWaLDihkPVKoDKw87537590 = 48983415;    long VkpoUxhuvFaWaLDihkPVKoDKw30272213 = -513490583;    long VkpoUxhuvFaWaLDihkPVKoDKw54180184 = -461617866;    long VkpoUxhuvFaWaLDihkPVKoDKw44269397 = -526223975;    long VkpoUxhuvFaWaLDihkPVKoDKw55243990 = -145751449;    long VkpoUxhuvFaWaLDihkPVKoDKw20859671 = -388668248;    long VkpoUxhuvFaWaLDihkPVKoDKw94335689 = -736768715;    long VkpoUxhuvFaWaLDihkPVKoDKw50877298 = -842602611;    long VkpoUxhuvFaWaLDihkPVKoDKw61139178 = -243510948;    long VkpoUxhuvFaWaLDihkPVKoDKw99065812 = -588243694;    long VkpoUxhuvFaWaLDihkPVKoDKw28226760 = -557516403;    long VkpoUxhuvFaWaLDihkPVKoDKw7263385 = -6401419;    long VkpoUxhuvFaWaLDihkPVKoDKw60678779 = -664695394;    long VkpoUxhuvFaWaLDihkPVKoDKw7206550 = -726604456;    long VkpoUxhuvFaWaLDihkPVKoDKw54024340 = -579220581;    long VkpoUxhuvFaWaLDihkPVKoDKw41124524 = 16012627;    long VkpoUxhuvFaWaLDihkPVKoDKw86067464 = 61883209;    long VkpoUxhuvFaWaLDihkPVKoDKw76329200 = -805773150;    long VkpoUxhuvFaWaLDihkPVKoDKw24556940 = -843759421;    long VkpoUxhuvFaWaLDihkPVKoDKw69396941 = 28049187;    long VkpoUxhuvFaWaLDihkPVKoDKw75108619 = -687755249;    long VkpoUxhuvFaWaLDihkPVKoDKw64682330 = 72918021;    long VkpoUxhuvFaWaLDihkPVKoDKw90989822 = -444941989;    long VkpoUxhuvFaWaLDihkPVKoDKw96132857 = -974629241;    long VkpoUxhuvFaWaLDihkPVKoDKw84035149 = -559288653;    long VkpoUxhuvFaWaLDihkPVKoDKw50468854 = -507997509;    long VkpoUxhuvFaWaLDihkPVKoDKw60383789 = 34882687;    long VkpoUxhuvFaWaLDihkPVKoDKw84137354 = 81806896;    long VkpoUxhuvFaWaLDihkPVKoDKw87390809 = -90977987;    long VkpoUxhuvFaWaLDihkPVKoDKw81233916 = 96579526;    long VkpoUxhuvFaWaLDihkPVKoDKw7243493 = -153910456;    long VkpoUxhuvFaWaLDihkPVKoDKw93754719 = -114699207;    long VkpoUxhuvFaWaLDihkPVKoDKw53970471 = 86172889;    long VkpoUxhuvFaWaLDihkPVKoDKw20960516 = 28163012;    long VkpoUxhuvFaWaLDihkPVKoDKw63877689 = -559802239;    long VkpoUxhuvFaWaLDihkPVKoDKw26621031 = -754762338;    long VkpoUxhuvFaWaLDihkPVKoDKw77222176 = -789160061;    long VkpoUxhuvFaWaLDihkPVKoDKw26110734 = -223477552;    long VkpoUxhuvFaWaLDihkPVKoDKw91379127 = -250124027;    long VkpoUxhuvFaWaLDihkPVKoDKw51197228 = -888614460;    long VkpoUxhuvFaWaLDihkPVKoDKw39953114 = -181234953;    long VkpoUxhuvFaWaLDihkPVKoDKw80838938 = 9550308;    long VkpoUxhuvFaWaLDihkPVKoDKw82052850 = -43185024;    long VkpoUxhuvFaWaLDihkPVKoDKw42034576 = -245754568;     VkpoUxhuvFaWaLDihkPVKoDKw13635546 = VkpoUxhuvFaWaLDihkPVKoDKw95411949;     VkpoUxhuvFaWaLDihkPVKoDKw95411949 = VkpoUxhuvFaWaLDihkPVKoDKw62362423;     VkpoUxhuvFaWaLDihkPVKoDKw62362423 = VkpoUxhuvFaWaLDihkPVKoDKw47107568;     VkpoUxhuvFaWaLDihkPVKoDKw47107568 = VkpoUxhuvFaWaLDihkPVKoDKw84222973;     VkpoUxhuvFaWaLDihkPVKoDKw84222973 = VkpoUxhuvFaWaLDihkPVKoDKw50338015;     VkpoUxhuvFaWaLDihkPVKoDKw50338015 = VkpoUxhuvFaWaLDihkPVKoDKw80722700;     VkpoUxhuvFaWaLDihkPVKoDKw80722700 = VkpoUxhuvFaWaLDihkPVKoDKw2971241;     VkpoUxhuvFaWaLDihkPVKoDKw2971241 = VkpoUxhuvFaWaLDihkPVKoDKw20953938;     VkpoUxhuvFaWaLDihkPVKoDKw20953938 = VkpoUxhuvFaWaLDihkPVKoDKw43972904;     VkpoUxhuvFaWaLDihkPVKoDKw43972904 = VkpoUxhuvFaWaLDihkPVKoDKw91518694;     VkpoUxhuvFaWaLDihkPVKoDKw91518694 = VkpoUxhuvFaWaLDihkPVKoDKw34206983;     VkpoUxhuvFaWaLDihkPVKoDKw34206983 = VkpoUxhuvFaWaLDihkPVKoDKw28846356;     VkpoUxhuvFaWaLDihkPVKoDKw28846356 = VkpoUxhuvFaWaLDihkPVKoDKw88449986;     VkpoUxhuvFaWaLDihkPVKoDKw88449986 = VkpoUxhuvFaWaLDihkPVKoDKw58621829;     VkpoUxhuvFaWaLDihkPVKoDKw58621829 = VkpoUxhuvFaWaLDihkPVKoDKw10917584;     VkpoUxhuvFaWaLDihkPVKoDKw10917584 = VkpoUxhuvFaWaLDihkPVKoDKw72526884;     VkpoUxhuvFaWaLDihkPVKoDKw72526884 = VkpoUxhuvFaWaLDihkPVKoDKw56447595;     VkpoUxhuvFaWaLDihkPVKoDKw56447595 = VkpoUxhuvFaWaLDihkPVKoDKw22952318;     VkpoUxhuvFaWaLDihkPVKoDKw22952318 = VkpoUxhuvFaWaLDihkPVKoDKw96613838;     VkpoUxhuvFaWaLDihkPVKoDKw96613838 = VkpoUxhuvFaWaLDihkPVKoDKw3685745;     VkpoUxhuvFaWaLDihkPVKoDKw3685745 = VkpoUxhuvFaWaLDihkPVKoDKw6824855;     VkpoUxhuvFaWaLDihkPVKoDKw6824855 = VkpoUxhuvFaWaLDihkPVKoDKw7874359;     VkpoUxhuvFaWaLDihkPVKoDKw7874359 = VkpoUxhuvFaWaLDihkPVKoDKw32090211;     VkpoUxhuvFaWaLDihkPVKoDKw32090211 = VkpoUxhuvFaWaLDihkPVKoDKw92927383;     VkpoUxhuvFaWaLDihkPVKoDKw92927383 = VkpoUxhuvFaWaLDihkPVKoDKw39953576;     VkpoUxhuvFaWaLDihkPVKoDKw39953576 = VkpoUxhuvFaWaLDihkPVKoDKw95094024;     VkpoUxhuvFaWaLDihkPVKoDKw95094024 = VkpoUxhuvFaWaLDihkPVKoDKw59863029;     VkpoUxhuvFaWaLDihkPVKoDKw59863029 = VkpoUxhuvFaWaLDihkPVKoDKw8635552;     VkpoUxhuvFaWaLDihkPVKoDKw8635552 = VkpoUxhuvFaWaLDihkPVKoDKw70076640;     VkpoUxhuvFaWaLDihkPVKoDKw70076640 = VkpoUxhuvFaWaLDihkPVKoDKw82833726;     VkpoUxhuvFaWaLDihkPVKoDKw82833726 = VkpoUxhuvFaWaLDihkPVKoDKw92452882;     VkpoUxhuvFaWaLDihkPVKoDKw92452882 = VkpoUxhuvFaWaLDihkPVKoDKw5980224;     VkpoUxhuvFaWaLDihkPVKoDKw5980224 = VkpoUxhuvFaWaLDihkPVKoDKw21582972;     VkpoUxhuvFaWaLDihkPVKoDKw21582972 = VkpoUxhuvFaWaLDihkPVKoDKw27771207;     VkpoUxhuvFaWaLDihkPVKoDKw27771207 = VkpoUxhuvFaWaLDihkPVKoDKw51415280;     VkpoUxhuvFaWaLDihkPVKoDKw51415280 = VkpoUxhuvFaWaLDihkPVKoDKw56893243;     VkpoUxhuvFaWaLDihkPVKoDKw56893243 = VkpoUxhuvFaWaLDihkPVKoDKw31402361;     VkpoUxhuvFaWaLDihkPVKoDKw31402361 = VkpoUxhuvFaWaLDihkPVKoDKw70380131;     VkpoUxhuvFaWaLDihkPVKoDKw70380131 = VkpoUxhuvFaWaLDihkPVKoDKw46623118;     VkpoUxhuvFaWaLDihkPVKoDKw46623118 = VkpoUxhuvFaWaLDihkPVKoDKw72056899;     VkpoUxhuvFaWaLDihkPVKoDKw72056899 = VkpoUxhuvFaWaLDihkPVKoDKw34288804;     VkpoUxhuvFaWaLDihkPVKoDKw34288804 = VkpoUxhuvFaWaLDihkPVKoDKw31716236;     VkpoUxhuvFaWaLDihkPVKoDKw31716236 = VkpoUxhuvFaWaLDihkPVKoDKw43192028;     VkpoUxhuvFaWaLDihkPVKoDKw43192028 = VkpoUxhuvFaWaLDihkPVKoDKw41100389;     VkpoUxhuvFaWaLDihkPVKoDKw41100389 = VkpoUxhuvFaWaLDihkPVKoDKw96794526;     VkpoUxhuvFaWaLDihkPVKoDKw96794526 = VkpoUxhuvFaWaLDihkPVKoDKw55918427;     VkpoUxhuvFaWaLDihkPVKoDKw55918427 = VkpoUxhuvFaWaLDihkPVKoDKw44625171;     VkpoUxhuvFaWaLDihkPVKoDKw44625171 = VkpoUxhuvFaWaLDihkPVKoDKw99479240;     VkpoUxhuvFaWaLDihkPVKoDKw99479240 = VkpoUxhuvFaWaLDihkPVKoDKw24498197;     VkpoUxhuvFaWaLDihkPVKoDKw24498197 = VkpoUxhuvFaWaLDihkPVKoDKw82685831;     VkpoUxhuvFaWaLDihkPVKoDKw82685831 = VkpoUxhuvFaWaLDihkPVKoDKw1599810;     VkpoUxhuvFaWaLDihkPVKoDKw1599810 = VkpoUxhuvFaWaLDihkPVKoDKw85209389;     VkpoUxhuvFaWaLDihkPVKoDKw85209389 = VkpoUxhuvFaWaLDihkPVKoDKw12225504;     VkpoUxhuvFaWaLDihkPVKoDKw12225504 = VkpoUxhuvFaWaLDihkPVKoDKw67612500;     VkpoUxhuvFaWaLDihkPVKoDKw67612500 = VkpoUxhuvFaWaLDihkPVKoDKw6810692;     VkpoUxhuvFaWaLDihkPVKoDKw6810692 = VkpoUxhuvFaWaLDihkPVKoDKw87537590;     VkpoUxhuvFaWaLDihkPVKoDKw87537590 = VkpoUxhuvFaWaLDihkPVKoDKw30272213;     VkpoUxhuvFaWaLDihkPVKoDKw30272213 = VkpoUxhuvFaWaLDihkPVKoDKw54180184;     VkpoUxhuvFaWaLDihkPVKoDKw54180184 = VkpoUxhuvFaWaLDihkPVKoDKw44269397;     VkpoUxhuvFaWaLDihkPVKoDKw44269397 = VkpoUxhuvFaWaLDihkPVKoDKw55243990;     VkpoUxhuvFaWaLDihkPVKoDKw55243990 = VkpoUxhuvFaWaLDihkPVKoDKw20859671;     VkpoUxhuvFaWaLDihkPVKoDKw20859671 = VkpoUxhuvFaWaLDihkPVKoDKw94335689;     VkpoUxhuvFaWaLDihkPVKoDKw94335689 = VkpoUxhuvFaWaLDihkPVKoDKw50877298;     VkpoUxhuvFaWaLDihkPVKoDKw50877298 = VkpoUxhuvFaWaLDihkPVKoDKw61139178;     VkpoUxhuvFaWaLDihkPVKoDKw61139178 = VkpoUxhuvFaWaLDihkPVKoDKw99065812;     VkpoUxhuvFaWaLDihkPVKoDKw99065812 = VkpoUxhuvFaWaLDihkPVKoDKw28226760;     VkpoUxhuvFaWaLDihkPVKoDKw28226760 = VkpoUxhuvFaWaLDihkPVKoDKw7263385;     VkpoUxhuvFaWaLDihkPVKoDKw7263385 = VkpoUxhuvFaWaLDihkPVKoDKw60678779;     VkpoUxhuvFaWaLDihkPVKoDKw60678779 = VkpoUxhuvFaWaLDihkPVKoDKw7206550;     VkpoUxhuvFaWaLDihkPVKoDKw7206550 = VkpoUxhuvFaWaLDihkPVKoDKw54024340;     VkpoUxhuvFaWaLDihkPVKoDKw54024340 = VkpoUxhuvFaWaLDihkPVKoDKw41124524;     VkpoUxhuvFaWaLDihkPVKoDKw41124524 = VkpoUxhuvFaWaLDihkPVKoDKw86067464;     VkpoUxhuvFaWaLDihkPVKoDKw86067464 = VkpoUxhuvFaWaLDihkPVKoDKw76329200;     VkpoUxhuvFaWaLDihkPVKoDKw76329200 = VkpoUxhuvFaWaLDihkPVKoDKw24556940;     VkpoUxhuvFaWaLDihkPVKoDKw24556940 = VkpoUxhuvFaWaLDihkPVKoDKw69396941;     VkpoUxhuvFaWaLDihkPVKoDKw69396941 = VkpoUxhuvFaWaLDihkPVKoDKw75108619;     VkpoUxhuvFaWaLDihkPVKoDKw75108619 = VkpoUxhuvFaWaLDihkPVKoDKw64682330;     VkpoUxhuvFaWaLDihkPVKoDKw64682330 = VkpoUxhuvFaWaLDihkPVKoDKw90989822;     VkpoUxhuvFaWaLDihkPVKoDKw90989822 = VkpoUxhuvFaWaLDihkPVKoDKw96132857;     VkpoUxhuvFaWaLDihkPVKoDKw96132857 = VkpoUxhuvFaWaLDihkPVKoDKw84035149;     VkpoUxhuvFaWaLDihkPVKoDKw84035149 = VkpoUxhuvFaWaLDihkPVKoDKw50468854;     VkpoUxhuvFaWaLDihkPVKoDKw50468854 = VkpoUxhuvFaWaLDihkPVKoDKw60383789;     VkpoUxhuvFaWaLDihkPVKoDKw60383789 = VkpoUxhuvFaWaLDihkPVKoDKw84137354;     VkpoUxhuvFaWaLDihkPVKoDKw84137354 = VkpoUxhuvFaWaLDihkPVKoDKw87390809;     VkpoUxhuvFaWaLDihkPVKoDKw87390809 = VkpoUxhuvFaWaLDihkPVKoDKw81233916;     VkpoUxhuvFaWaLDihkPVKoDKw81233916 = VkpoUxhuvFaWaLDihkPVKoDKw7243493;     VkpoUxhuvFaWaLDihkPVKoDKw7243493 = VkpoUxhuvFaWaLDihkPVKoDKw93754719;     VkpoUxhuvFaWaLDihkPVKoDKw93754719 = VkpoUxhuvFaWaLDihkPVKoDKw53970471;     VkpoUxhuvFaWaLDihkPVKoDKw53970471 = VkpoUxhuvFaWaLDihkPVKoDKw20960516;     VkpoUxhuvFaWaLDihkPVKoDKw20960516 = VkpoUxhuvFaWaLDihkPVKoDKw63877689;     VkpoUxhuvFaWaLDihkPVKoDKw63877689 = VkpoUxhuvFaWaLDihkPVKoDKw26621031;     VkpoUxhuvFaWaLDihkPVKoDKw26621031 = VkpoUxhuvFaWaLDihkPVKoDKw77222176;     VkpoUxhuvFaWaLDihkPVKoDKw77222176 = VkpoUxhuvFaWaLDihkPVKoDKw26110734;     VkpoUxhuvFaWaLDihkPVKoDKw26110734 = VkpoUxhuvFaWaLDihkPVKoDKw91379127;     VkpoUxhuvFaWaLDihkPVKoDKw91379127 = VkpoUxhuvFaWaLDihkPVKoDKw51197228;     VkpoUxhuvFaWaLDihkPVKoDKw51197228 = VkpoUxhuvFaWaLDihkPVKoDKw39953114;     VkpoUxhuvFaWaLDihkPVKoDKw39953114 = VkpoUxhuvFaWaLDihkPVKoDKw80838938;     VkpoUxhuvFaWaLDihkPVKoDKw80838938 = VkpoUxhuvFaWaLDihkPVKoDKw82052850;     VkpoUxhuvFaWaLDihkPVKoDKw82052850 = VkpoUxhuvFaWaLDihkPVKoDKw42034576;     VkpoUxhuvFaWaLDihkPVKoDKw42034576 = VkpoUxhuvFaWaLDihkPVKoDKw13635546;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void MxFKYEvOzubalUrqyvnqvizeyUkMLrXpSjPFGFVgCHWZIiFiFiwgiOEex38589845() {     long bMDUjCHXlICEmksaGooLZVQPC49094514 = -712031468;    long bMDUjCHXlICEmksaGooLZVQPC8684028 = -345346141;    long bMDUjCHXlICEmksaGooLZVQPC99748900 = -842256765;    long bMDUjCHXlICEmksaGooLZVQPC19330923 = -906151471;    long bMDUjCHXlICEmksaGooLZVQPC40508242 = -330386421;    long bMDUjCHXlICEmksaGooLZVQPC86560886 = -805173518;    long bMDUjCHXlICEmksaGooLZVQPC91380106 = -673869944;    long bMDUjCHXlICEmksaGooLZVQPC65102802 = -546552056;    long bMDUjCHXlICEmksaGooLZVQPC22471544 = -523977196;    long bMDUjCHXlICEmksaGooLZVQPC58875616 = -684315848;    long bMDUjCHXlICEmksaGooLZVQPC29700430 = -453284935;    long bMDUjCHXlICEmksaGooLZVQPC34775132 = -612712901;    long bMDUjCHXlICEmksaGooLZVQPC67081001 = -19906216;    long bMDUjCHXlICEmksaGooLZVQPC41590849 = -337842808;    long bMDUjCHXlICEmksaGooLZVQPC16816346 = -840848294;    long bMDUjCHXlICEmksaGooLZVQPC94458884 = -583285108;    long bMDUjCHXlICEmksaGooLZVQPC28362820 = -861739851;    long bMDUjCHXlICEmksaGooLZVQPC56207787 = -961246385;    long bMDUjCHXlICEmksaGooLZVQPC23502648 = -618212047;    long bMDUjCHXlICEmksaGooLZVQPC90451056 = -547603193;    long bMDUjCHXlICEmksaGooLZVQPC16772608 = -747229169;    long bMDUjCHXlICEmksaGooLZVQPC10246380 = -707443845;    long bMDUjCHXlICEmksaGooLZVQPC78399738 = -51410134;    long bMDUjCHXlICEmksaGooLZVQPC25883157 = 26076288;    long bMDUjCHXlICEmksaGooLZVQPC945335 = -547367733;    long bMDUjCHXlICEmksaGooLZVQPC50651748 = -387140408;    long bMDUjCHXlICEmksaGooLZVQPC55514599 = -103358315;    long bMDUjCHXlICEmksaGooLZVQPC591455 = -510248137;    long bMDUjCHXlICEmksaGooLZVQPC55303766 = -639644003;    long bMDUjCHXlICEmksaGooLZVQPC75610051 = -227550349;    long bMDUjCHXlICEmksaGooLZVQPC1416958 = -128098389;    long bMDUjCHXlICEmksaGooLZVQPC30275901 = -836004927;    long bMDUjCHXlICEmksaGooLZVQPC18198234 = -238671704;    long bMDUjCHXlICEmksaGooLZVQPC51331398 = -526186106;    long bMDUjCHXlICEmksaGooLZVQPC93579660 = -647884256;    long bMDUjCHXlICEmksaGooLZVQPC2976124 = -825384129;    long bMDUjCHXlICEmksaGooLZVQPC6305060 = -132948960;    long bMDUjCHXlICEmksaGooLZVQPC82617764 = -233433507;    long bMDUjCHXlICEmksaGooLZVQPC770693 = -500577803;    long bMDUjCHXlICEmksaGooLZVQPC10894650 = 38861978;    long bMDUjCHXlICEmksaGooLZVQPC5508507 = -46481621;    long bMDUjCHXlICEmksaGooLZVQPC23653931 = -612548959;    long bMDUjCHXlICEmksaGooLZVQPC21099615 = -486233089;    long bMDUjCHXlICEmksaGooLZVQPC83323366 = -991028381;    long bMDUjCHXlICEmksaGooLZVQPC41116848 = -944668281;    long bMDUjCHXlICEmksaGooLZVQPC42755855 = -587676926;    long bMDUjCHXlICEmksaGooLZVQPC75263590 = -523261309;    long bMDUjCHXlICEmksaGooLZVQPC62351483 = -955603259;    long bMDUjCHXlICEmksaGooLZVQPC22371907 = 60904470;    long bMDUjCHXlICEmksaGooLZVQPC49027786 = -538382913;    long bMDUjCHXlICEmksaGooLZVQPC63456555 = -976341749;    long bMDUjCHXlICEmksaGooLZVQPC85085281 = -886349775;    long bMDUjCHXlICEmksaGooLZVQPC53830538 = -565168611;    long bMDUjCHXlICEmksaGooLZVQPC28217351 = -67885020;    long bMDUjCHXlICEmksaGooLZVQPC21817237 = -794155328;    long bMDUjCHXlICEmksaGooLZVQPC38848135 = 95412377;    long bMDUjCHXlICEmksaGooLZVQPC30284290 = -193936007;    long bMDUjCHXlICEmksaGooLZVQPC73865744 = -768333054;    long bMDUjCHXlICEmksaGooLZVQPC18385588 = -258783739;    long bMDUjCHXlICEmksaGooLZVQPC89856494 = -943246014;    long bMDUjCHXlICEmksaGooLZVQPC31046288 = -601815204;    long bMDUjCHXlICEmksaGooLZVQPC90788652 = -63621808;    long bMDUjCHXlICEmksaGooLZVQPC9799036 = -906908053;    long bMDUjCHXlICEmksaGooLZVQPC46861492 = -196426848;    long bMDUjCHXlICEmksaGooLZVQPC57458658 = -456217459;    long bMDUjCHXlICEmksaGooLZVQPC99424528 = -617280008;    long bMDUjCHXlICEmksaGooLZVQPC16576898 = -274041197;    long bMDUjCHXlICEmksaGooLZVQPC15749604 = -493720111;    long bMDUjCHXlICEmksaGooLZVQPC48011189 = -689958553;    long bMDUjCHXlICEmksaGooLZVQPC13840222 = 84535835;    long bMDUjCHXlICEmksaGooLZVQPC88153824 = -350336148;    long bMDUjCHXlICEmksaGooLZVQPC45745056 = -528306344;    long bMDUjCHXlICEmksaGooLZVQPC55437095 = -360668583;    long bMDUjCHXlICEmksaGooLZVQPC12607998 = -557074025;    long bMDUjCHXlICEmksaGooLZVQPC84942550 = -401121572;    long bMDUjCHXlICEmksaGooLZVQPC93118677 = -34680211;    long bMDUjCHXlICEmksaGooLZVQPC89146765 = -121210757;    long bMDUjCHXlICEmksaGooLZVQPC95076371 = -60381753;    long bMDUjCHXlICEmksaGooLZVQPC84766309 = -29255432;    long bMDUjCHXlICEmksaGooLZVQPC58189480 = -959690807;    long bMDUjCHXlICEmksaGooLZVQPC75388157 = -863879100;    long bMDUjCHXlICEmksaGooLZVQPC93163116 = -147755056;    long bMDUjCHXlICEmksaGooLZVQPC78219547 = -471152607;    long bMDUjCHXlICEmksaGooLZVQPC6275980 = -1261091;    long bMDUjCHXlICEmksaGooLZVQPC12153497 = -251208600;    long bMDUjCHXlICEmksaGooLZVQPC16331676 = -241748615;    long bMDUjCHXlICEmksaGooLZVQPC76445362 = -170836316;    long bMDUjCHXlICEmksaGooLZVQPC89980883 = -70786684;    long bMDUjCHXlICEmksaGooLZVQPC29514161 = -732030779;    long bMDUjCHXlICEmksaGooLZVQPC54731526 = -643296633;    long bMDUjCHXlICEmksaGooLZVQPC72691834 = -531448122;    long bMDUjCHXlICEmksaGooLZVQPC32439316 = -364615907;    long bMDUjCHXlICEmksaGooLZVQPC64232176 = -974649769;    long bMDUjCHXlICEmksaGooLZVQPC10914198 = -557331790;    long bMDUjCHXlICEmksaGooLZVQPC79848361 = -359322818;    long bMDUjCHXlICEmksaGooLZVQPC14719855 = -982859814;    long bMDUjCHXlICEmksaGooLZVQPC13854895 = -705640906;    long bMDUjCHXlICEmksaGooLZVQPC74238122 = -189806241;    long bMDUjCHXlICEmksaGooLZVQPC25864708 = -434810923;    long bMDUjCHXlICEmksaGooLZVQPC41692319 = -712031468;     bMDUjCHXlICEmksaGooLZVQPC49094514 = bMDUjCHXlICEmksaGooLZVQPC8684028;     bMDUjCHXlICEmksaGooLZVQPC8684028 = bMDUjCHXlICEmksaGooLZVQPC99748900;     bMDUjCHXlICEmksaGooLZVQPC99748900 = bMDUjCHXlICEmksaGooLZVQPC19330923;     bMDUjCHXlICEmksaGooLZVQPC19330923 = bMDUjCHXlICEmksaGooLZVQPC40508242;     bMDUjCHXlICEmksaGooLZVQPC40508242 = bMDUjCHXlICEmksaGooLZVQPC86560886;     bMDUjCHXlICEmksaGooLZVQPC86560886 = bMDUjCHXlICEmksaGooLZVQPC91380106;     bMDUjCHXlICEmksaGooLZVQPC91380106 = bMDUjCHXlICEmksaGooLZVQPC65102802;     bMDUjCHXlICEmksaGooLZVQPC65102802 = bMDUjCHXlICEmksaGooLZVQPC22471544;     bMDUjCHXlICEmksaGooLZVQPC22471544 = bMDUjCHXlICEmksaGooLZVQPC58875616;     bMDUjCHXlICEmksaGooLZVQPC58875616 = bMDUjCHXlICEmksaGooLZVQPC29700430;     bMDUjCHXlICEmksaGooLZVQPC29700430 = bMDUjCHXlICEmksaGooLZVQPC34775132;     bMDUjCHXlICEmksaGooLZVQPC34775132 = bMDUjCHXlICEmksaGooLZVQPC67081001;     bMDUjCHXlICEmksaGooLZVQPC67081001 = bMDUjCHXlICEmksaGooLZVQPC41590849;     bMDUjCHXlICEmksaGooLZVQPC41590849 = bMDUjCHXlICEmksaGooLZVQPC16816346;     bMDUjCHXlICEmksaGooLZVQPC16816346 = bMDUjCHXlICEmksaGooLZVQPC94458884;     bMDUjCHXlICEmksaGooLZVQPC94458884 = bMDUjCHXlICEmksaGooLZVQPC28362820;     bMDUjCHXlICEmksaGooLZVQPC28362820 = bMDUjCHXlICEmksaGooLZVQPC56207787;     bMDUjCHXlICEmksaGooLZVQPC56207787 = bMDUjCHXlICEmksaGooLZVQPC23502648;     bMDUjCHXlICEmksaGooLZVQPC23502648 = bMDUjCHXlICEmksaGooLZVQPC90451056;     bMDUjCHXlICEmksaGooLZVQPC90451056 = bMDUjCHXlICEmksaGooLZVQPC16772608;     bMDUjCHXlICEmksaGooLZVQPC16772608 = bMDUjCHXlICEmksaGooLZVQPC10246380;     bMDUjCHXlICEmksaGooLZVQPC10246380 = bMDUjCHXlICEmksaGooLZVQPC78399738;     bMDUjCHXlICEmksaGooLZVQPC78399738 = bMDUjCHXlICEmksaGooLZVQPC25883157;     bMDUjCHXlICEmksaGooLZVQPC25883157 = bMDUjCHXlICEmksaGooLZVQPC945335;     bMDUjCHXlICEmksaGooLZVQPC945335 = bMDUjCHXlICEmksaGooLZVQPC50651748;     bMDUjCHXlICEmksaGooLZVQPC50651748 = bMDUjCHXlICEmksaGooLZVQPC55514599;     bMDUjCHXlICEmksaGooLZVQPC55514599 = bMDUjCHXlICEmksaGooLZVQPC591455;     bMDUjCHXlICEmksaGooLZVQPC591455 = bMDUjCHXlICEmksaGooLZVQPC55303766;     bMDUjCHXlICEmksaGooLZVQPC55303766 = bMDUjCHXlICEmksaGooLZVQPC75610051;     bMDUjCHXlICEmksaGooLZVQPC75610051 = bMDUjCHXlICEmksaGooLZVQPC1416958;     bMDUjCHXlICEmksaGooLZVQPC1416958 = bMDUjCHXlICEmksaGooLZVQPC30275901;     bMDUjCHXlICEmksaGooLZVQPC30275901 = bMDUjCHXlICEmksaGooLZVQPC18198234;     bMDUjCHXlICEmksaGooLZVQPC18198234 = bMDUjCHXlICEmksaGooLZVQPC51331398;     bMDUjCHXlICEmksaGooLZVQPC51331398 = bMDUjCHXlICEmksaGooLZVQPC93579660;     bMDUjCHXlICEmksaGooLZVQPC93579660 = bMDUjCHXlICEmksaGooLZVQPC2976124;     bMDUjCHXlICEmksaGooLZVQPC2976124 = bMDUjCHXlICEmksaGooLZVQPC6305060;     bMDUjCHXlICEmksaGooLZVQPC6305060 = bMDUjCHXlICEmksaGooLZVQPC82617764;     bMDUjCHXlICEmksaGooLZVQPC82617764 = bMDUjCHXlICEmksaGooLZVQPC770693;     bMDUjCHXlICEmksaGooLZVQPC770693 = bMDUjCHXlICEmksaGooLZVQPC10894650;     bMDUjCHXlICEmksaGooLZVQPC10894650 = bMDUjCHXlICEmksaGooLZVQPC5508507;     bMDUjCHXlICEmksaGooLZVQPC5508507 = bMDUjCHXlICEmksaGooLZVQPC23653931;     bMDUjCHXlICEmksaGooLZVQPC23653931 = bMDUjCHXlICEmksaGooLZVQPC21099615;     bMDUjCHXlICEmksaGooLZVQPC21099615 = bMDUjCHXlICEmksaGooLZVQPC83323366;     bMDUjCHXlICEmksaGooLZVQPC83323366 = bMDUjCHXlICEmksaGooLZVQPC41116848;     bMDUjCHXlICEmksaGooLZVQPC41116848 = bMDUjCHXlICEmksaGooLZVQPC42755855;     bMDUjCHXlICEmksaGooLZVQPC42755855 = bMDUjCHXlICEmksaGooLZVQPC75263590;     bMDUjCHXlICEmksaGooLZVQPC75263590 = bMDUjCHXlICEmksaGooLZVQPC62351483;     bMDUjCHXlICEmksaGooLZVQPC62351483 = bMDUjCHXlICEmksaGooLZVQPC22371907;     bMDUjCHXlICEmksaGooLZVQPC22371907 = bMDUjCHXlICEmksaGooLZVQPC49027786;     bMDUjCHXlICEmksaGooLZVQPC49027786 = bMDUjCHXlICEmksaGooLZVQPC63456555;     bMDUjCHXlICEmksaGooLZVQPC63456555 = bMDUjCHXlICEmksaGooLZVQPC85085281;     bMDUjCHXlICEmksaGooLZVQPC85085281 = bMDUjCHXlICEmksaGooLZVQPC53830538;     bMDUjCHXlICEmksaGooLZVQPC53830538 = bMDUjCHXlICEmksaGooLZVQPC28217351;     bMDUjCHXlICEmksaGooLZVQPC28217351 = bMDUjCHXlICEmksaGooLZVQPC21817237;     bMDUjCHXlICEmksaGooLZVQPC21817237 = bMDUjCHXlICEmksaGooLZVQPC38848135;     bMDUjCHXlICEmksaGooLZVQPC38848135 = bMDUjCHXlICEmksaGooLZVQPC30284290;     bMDUjCHXlICEmksaGooLZVQPC30284290 = bMDUjCHXlICEmksaGooLZVQPC73865744;     bMDUjCHXlICEmksaGooLZVQPC73865744 = bMDUjCHXlICEmksaGooLZVQPC18385588;     bMDUjCHXlICEmksaGooLZVQPC18385588 = bMDUjCHXlICEmksaGooLZVQPC89856494;     bMDUjCHXlICEmksaGooLZVQPC89856494 = bMDUjCHXlICEmksaGooLZVQPC31046288;     bMDUjCHXlICEmksaGooLZVQPC31046288 = bMDUjCHXlICEmksaGooLZVQPC90788652;     bMDUjCHXlICEmksaGooLZVQPC90788652 = bMDUjCHXlICEmksaGooLZVQPC9799036;     bMDUjCHXlICEmksaGooLZVQPC9799036 = bMDUjCHXlICEmksaGooLZVQPC46861492;     bMDUjCHXlICEmksaGooLZVQPC46861492 = bMDUjCHXlICEmksaGooLZVQPC57458658;     bMDUjCHXlICEmksaGooLZVQPC57458658 = bMDUjCHXlICEmksaGooLZVQPC99424528;     bMDUjCHXlICEmksaGooLZVQPC99424528 = bMDUjCHXlICEmksaGooLZVQPC16576898;     bMDUjCHXlICEmksaGooLZVQPC16576898 = bMDUjCHXlICEmksaGooLZVQPC15749604;     bMDUjCHXlICEmksaGooLZVQPC15749604 = bMDUjCHXlICEmksaGooLZVQPC48011189;     bMDUjCHXlICEmksaGooLZVQPC48011189 = bMDUjCHXlICEmksaGooLZVQPC13840222;     bMDUjCHXlICEmksaGooLZVQPC13840222 = bMDUjCHXlICEmksaGooLZVQPC88153824;     bMDUjCHXlICEmksaGooLZVQPC88153824 = bMDUjCHXlICEmksaGooLZVQPC45745056;     bMDUjCHXlICEmksaGooLZVQPC45745056 = bMDUjCHXlICEmksaGooLZVQPC55437095;     bMDUjCHXlICEmksaGooLZVQPC55437095 = bMDUjCHXlICEmksaGooLZVQPC12607998;     bMDUjCHXlICEmksaGooLZVQPC12607998 = bMDUjCHXlICEmksaGooLZVQPC84942550;     bMDUjCHXlICEmksaGooLZVQPC84942550 = bMDUjCHXlICEmksaGooLZVQPC93118677;     bMDUjCHXlICEmksaGooLZVQPC93118677 = bMDUjCHXlICEmksaGooLZVQPC89146765;     bMDUjCHXlICEmksaGooLZVQPC89146765 = bMDUjCHXlICEmksaGooLZVQPC95076371;     bMDUjCHXlICEmksaGooLZVQPC95076371 = bMDUjCHXlICEmksaGooLZVQPC84766309;     bMDUjCHXlICEmksaGooLZVQPC84766309 = bMDUjCHXlICEmksaGooLZVQPC58189480;     bMDUjCHXlICEmksaGooLZVQPC58189480 = bMDUjCHXlICEmksaGooLZVQPC75388157;     bMDUjCHXlICEmksaGooLZVQPC75388157 = bMDUjCHXlICEmksaGooLZVQPC93163116;     bMDUjCHXlICEmksaGooLZVQPC93163116 = bMDUjCHXlICEmksaGooLZVQPC78219547;     bMDUjCHXlICEmksaGooLZVQPC78219547 = bMDUjCHXlICEmksaGooLZVQPC6275980;     bMDUjCHXlICEmksaGooLZVQPC6275980 = bMDUjCHXlICEmksaGooLZVQPC12153497;     bMDUjCHXlICEmksaGooLZVQPC12153497 = bMDUjCHXlICEmksaGooLZVQPC16331676;     bMDUjCHXlICEmksaGooLZVQPC16331676 = bMDUjCHXlICEmksaGooLZVQPC76445362;     bMDUjCHXlICEmksaGooLZVQPC76445362 = bMDUjCHXlICEmksaGooLZVQPC89980883;     bMDUjCHXlICEmksaGooLZVQPC89980883 = bMDUjCHXlICEmksaGooLZVQPC29514161;     bMDUjCHXlICEmksaGooLZVQPC29514161 = bMDUjCHXlICEmksaGooLZVQPC54731526;     bMDUjCHXlICEmksaGooLZVQPC54731526 = bMDUjCHXlICEmksaGooLZVQPC72691834;     bMDUjCHXlICEmksaGooLZVQPC72691834 = bMDUjCHXlICEmksaGooLZVQPC32439316;     bMDUjCHXlICEmksaGooLZVQPC32439316 = bMDUjCHXlICEmksaGooLZVQPC64232176;     bMDUjCHXlICEmksaGooLZVQPC64232176 = bMDUjCHXlICEmksaGooLZVQPC10914198;     bMDUjCHXlICEmksaGooLZVQPC10914198 = bMDUjCHXlICEmksaGooLZVQPC79848361;     bMDUjCHXlICEmksaGooLZVQPC79848361 = bMDUjCHXlICEmksaGooLZVQPC14719855;     bMDUjCHXlICEmksaGooLZVQPC14719855 = bMDUjCHXlICEmksaGooLZVQPC13854895;     bMDUjCHXlICEmksaGooLZVQPC13854895 = bMDUjCHXlICEmksaGooLZVQPC74238122;     bMDUjCHXlICEmksaGooLZVQPC74238122 = bMDUjCHXlICEmksaGooLZVQPC25864708;     bMDUjCHXlICEmksaGooLZVQPC25864708 = bMDUjCHXlICEmksaGooLZVQPC41692319;     bMDUjCHXlICEmksaGooLZVQPC41692319 = bMDUjCHXlICEmksaGooLZVQPC49094514;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void UzLnrUBLRIPOTsBIbnbKgvPvSWghWdQMqCGuoxdoGTCYoKqRalHBjUNZk53638913() {     long QUVnUpnrCYQmGTeKnEMsqHIfO55211621 = -823933357;    long QUVnUpnrCYQmGTeKnEMsqHIfO52057307 = -54945922;    long QUVnUpnrCYQmGTeKnEMsqHIfO15791084 = -993089686;    long QUVnUpnrCYQmGTeKnEMsqHIfO46405704 = 3099899;    long QUVnUpnrCYQmGTeKnEMsqHIfO9403731 = -851036292;    long QUVnUpnrCYQmGTeKnEMsqHIfO77978089 = 30330246;    long QUVnUpnrCYQmGTeKnEMsqHIfO51869072 = -812834921;    long QUVnUpnrCYQmGTeKnEMsqHIfO14862693 = -833425969;    long QUVnUpnrCYQmGTeKnEMsqHIfO87114038 = -292009862;    long QUVnUpnrCYQmGTeKnEMsqHIfO105276 = 86708675;    long QUVnUpnrCYQmGTeKnEMsqHIfO89810719 = -330722521;    long QUVnUpnrCYQmGTeKnEMsqHIfO66598174 = 42880897;    long QUVnUpnrCYQmGTeKnEMsqHIfO53290120 = -459797305;    long QUVnUpnrCYQmGTeKnEMsqHIfO24734526 = -870081376;    long QUVnUpnrCYQmGTeKnEMsqHIfO12558773 = -431310460;    long QUVnUpnrCYQmGTeKnEMsqHIfO35964278 = -556284651;    long QUVnUpnrCYQmGTeKnEMsqHIfO22198824 = -378284964;    long QUVnUpnrCYQmGTeKnEMsqHIfO53260940 = -626769028;    long QUVnUpnrCYQmGTeKnEMsqHIfO85332489 = 76018856;    long QUVnUpnrCYQmGTeKnEMsqHIfO71001221 = -904506112;    long QUVnUpnrCYQmGTeKnEMsqHIfO5325802 = -602716624;    long QUVnUpnrCYQmGTeKnEMsqHIfO96767403 = -615373562;    long QUVnUpnrCYQmGTeKnEMsqHIfO13990530 = -897927621;    long QUVnUpnrCYQmGTeKnEMsqHIfO9875531 = -196228700;    long QUVnUpnrCYQmGTeKnEMsqHIfO44644985 = -920563766;    long QUVnUpnrCYQmGTeKnEMsqHIfO75373423 = -265795731;    long QUVnUpnrCYQmGTeKnEMsqHIfO53974377 = -4020518;    long QUVnUpnrCYQmGTeKnEMsqHIfO13698580 = -576177090;    long QUVnUpnrCYQmGTeKnEMsqHIfO21436022 = -862026708;    long QUVnUpnrCYQmGTeKnEMsqHIfO44225688 = -45021216;    long QUVnUpnrCYQmGTeKnEMsqHIfO93659507 = -41419327;    long QUVnUpnrCYQmGTeKnEMsqHIfO27886523 = -545451742;    long QUVnUpnrCYQmGTeKnEMsqHIfO27909183 = -131285074;    long QUVnUpnrCYQmGTeKnEMsqHIfO46161962 = -277727871;    long QUVnUpnrCYQmGTeKnEMsqHIfO55054313 = -186617361;    long QUVnUpnrCYQmGTeKnEMsqHIfO71702037 = 60589764;    long QUVnUpnrCYQmGTeKnEMsqHIfO87566994 = -86584830;    long QUVnUpnrCYQmGTeKnEMsqHIfO16707977 = -4939517;    long QUVnUpnrCYQmGTeKnEMsqHIfO74380946 = -494501300;    long QUVnUpnrCYQmGTeKnEMsqHIfO98396587 = -434577245;    long QUVnUpnrCYQmGTeKnEMsqHIfO11177731 = -111755515;    long QUVnUpnrCYQmGTeKnEMsqHIfO55804387 = -882691237;    long QUVnUpnrCYQmGTeKnEMsqHIfO99166592 = -567037673;    long QUVnUpnrCYQmGTeKnEMsqHIfO70731107 = 89628681;    long QUVnUpnrCYQmGTeKnEMsqHIfO53069312 = -606566435;    long QUVnUpnrCYQmGTeKnEMsqHIfO54695050 = -572893042;    long QUVnUpnrCYQmGTeKnEMsqHIfO93042165 = -642036846;    long QUVnUpnrCYQmGTeKnEMsqHIfO70308423 = -965498792;    long QUVnUpnrCYQmGTeKnEMsqHIfO32047636 = -24832518;    long QUVnUpnrCYQmGTeKnEMsqHIfO61939439 = -625393721;    long QUVnUpnrCYQmGTeKnEMsqHIfO99157232 = -818635420;    long QUVnUpnrCYQmGTeKnEMsqHIfO95895001 = -687076095;    long QUVnUpnrCYQmGTeKnEMsqHIfO2078996 = -356958199;    long QUVnUpnrCYQmGTeKnEMsqHIfO24186231 = -388355165;    long QUVnUpnrCYQmGTeKnEMsqHIfO48313112 = -394687110;    long QUVnUpnrCYQmGTeKnEMsqHIfO58444218 = -108559796;    long QUVnUpnrCYQmGTeKnEMsqHIfO38066777 = -157018301;    long QUVnUpnrCYQmGTeKnEMsqHIfO5915554 = -696860987;    long QUVnUpnrCYQmGTeKnEMsqHIfO1760719 = -76336336;    long QUVnUpnrCYQmGTeKnEMsqHIfO34030308 = -485240562;    long QUVnUpnrCYQmGTeKnEMsqHIfO24003712 = -965649236;    long QUVnUpnrCYQmGTeKnEMsqHIfO38170493 = -136657831;    long QUVnUpnrCYQmGTeKnEMsqHIfO93426671 = -971399262;    long QUVnUpnrCYQmGTeKnEMsqHIfO42888351 = -146988646;    long QUVnUpnrCYQmGTeKnEMsqHIfO6445769 = -871871999;    long QUVnUpnrCYQmGTeKnEMsqHIfO61924197 = -785270779;    long QUVnUpnrCYQmGTeKnEMsqHIfO38688992 = -825834029;    long QUVnUpnrCYQmGTeKnEMsqHIfO7128158 = -82069434;    long QUVnUpnrCYQmGTeKnEMsqHIfO69680213 = -583464016;    long QUVnUpnrCYQmGTeKnEMsqHIfO40856736 = -391900224;    long QUVnUpnrCYQmGTeKnEMsqHIfO48397284 = -369699822;    long QUVnUpnrCYQmGTeKnEMsqHIfO5490847 = -273345448;    long QUVnUpnrCYQmGTeKnEMsqHIfO78879994 = -32267729;    long QUVnUpnrCYQmGTeKnEMsqHIfO86935902 = -489403899;    long QUVnUpnrCYQmGTeKnEMsqHIfO59823491 = -692750598;    long QUVnUpnrCYQmGTeKnEMsqHIfO49521414 = -720025388;    long QUVnUpnrCYQmGTeKnEMsqHIfO97600810 = 51664111;    long QUVnUpnrCYQmGTeKnEMsqHIfO43259423 = -887556302;    long QUVnUpnrCYQmGTeKnEMsqHIfO56806218 = -589662265;    long QUVnUpnrCYQmGTeKnEMsqHIfO89949934 = -247670724;    long QUVnUpnrCYQmGTeKnEMsqHIfO82331258 = -623758885;    long QUVnUpnrCYQmGTeKnEMsqHIfO83665953 = -38521727;    long QUVnUpnrCYQmGTeKnEMsqHIfO81650944 = -451344573;    long QUVnUpnrCYQmGTeKnEMsqHIfO59496583 = -136632987;    long QUVnUpnrCYQmGTeKnEMsqHIfO45068455 = -226385797;    long QUVnUpnrCYQmGTeKnEMsqHIfO97764505 = -354343233;    long QUVnUpnrCYQmGTeKnEMsqHIfO25807527 = -88493544;    long QUVnUpnrCYQmGTeKnEMsqHIfO3722952 = -742929909;    long QUVnUpnrCYQmGTeKnEMsqHIfO97848850 = -883040761;    long QUVnUpnrCYQmGTeKnEMsqHIfO96610095 = 21942434;    long QUVnUpnrCYQmGTeKnEMsqHIfO33635260 = -782391936;    long QUVnUpnrCYQmGTeKnEMsqHIfO81651441 = -389723843;    long QUVnUpnrCYQmGTeKnEMsqHIfO14947258 = -928603182;    long QUVnUpnrCYQmGTeKnEMsqHIfO40350639 = 90739261;    long QUVnUpnrCYQmGTeKnEMsqHIfO74392875 = -468928009;    long QUVnUpnrCYQmGTeKnEMsqHIfO73007238 = -975097685;    long QUVnUpnrCYQmGTeKnEMsqHIfO62377716 = -911291976;    long QUVnUpnrCYQmGTeKnEMsqHIfO56278242 = -320049027;    long QUVnUpnrCYQmGTeKnEMsqHIfO64285338 = -38499321;    long QUVnUpnrCYQmGTeKnEMsqHIfO91145115 = -823933357;     QUVnUpnrCYQmGTeKnEMsqHIfO55211621 = QUVnUpnrCYQmGTeKnEMsqHIfO52057307;     QUVnUpnrCYQmGTeKnEMsqHIfO52057307 = QUVnUpnrCYQmGTeKnEMsqHIfO15791084;     QUVnUpnrCYQmGTeKnEMsqHIfO15791084 = QUVnUpnrCYQmGTeKnEMsqHIfO46405704;     QUVnUpnrCYQmGTeKnEMsqHIfO46405704 = QUVnUpnrCYQmGTeKnEMsqHIfO9403731;     QUVnUpnrCYQmGTeKnEMsqHIfO9403731 = QUVnUpnrCYQmGTeKnEMsqHIfO77978089;     QUVnUpnrCYQmGTeKnEMsqHIfO77978089 = QUVnUpnrCYQmGTeKnEMsqHIfO51869072;     QUVnUpnrCYQmGTeKnEMsqHIfO51869072 = QUVnUpnrCYQmGTeKnEMsqHIfO14862693;     QUVnUpnrCYQmGTeKnEMsqHIfO14862693 = QUVnUpnrCYQmGTeKnEMsqHIfO87114038;     QUVnUpnrCYQmGTeKnEMsqHIfO87114038 = QUVnUpnrCYQmGTeKnEMsqHIfO105276;     QUVnUpnrCYQmGTeKnEMsqHIfO105276 = QUVnUpnrCYQmGTeKnEMsqHIfO89810719;     QUVnUpnrCYQmGTeKnEMsqHIfO89810719 = QUVnUpnrCYQmGTeKnEMsqHIfO66598174;     QUVnUpnrCYQmGTeKnEMsqHIfO66598174 = QUVnUpnrCYQmGTeKnEMsqHIfO53290120;     QUVnUpnrCYQmGTeKnEMsqHIfO53290120 = QUVnUpnrCYQmGTeKnEMsqHIfO24734526;     QUVnUpnrCYQmGTeKnEMsqHIfO24734526 = QUVnUpnrCYQmGTeKnEMsqHIfO12558773;     QUVnUpnrCYQmGTeKnEMsqHIfO12558773 = QUVnUpnrCYQmGTeKnEMsqHIfO35964278;     QUVnUpnrCYQmGTeKnEMsqHIfO35964278 = QUVnUpnrCYQmGTeKnEMsqHIfO22198824;     QUVnUpnrCYQmGTeKnEMsqHIfO22198824 = QUVnUpnrCYQmGTeKnEMsqHIfO53260940;     QUVnUpnrCYQmGTeKnEMsqHIfO53260940 = QUVnUpnrCYQmGTeKnEMsqHIfO85332489;     QUVnUpnrCYQmGTeKnEMsqHIfO85332489 = QUVnUpnrCYQmGTeKnEMsqHIfO71001221;     QUVnUpnrCYQmGTeKnEMsqHIfO71001221 = QUVnUpnrCYQmGTeKnEMsqHIfO5325802;     QUVnUpnrCYQmGTeKnEMsqHIfO5325802 = QUVnUpnrCYQmGTeKnEMsqHIfO96767403;     QUVnUpnrCYQmGTeKnEMsqHIfO96767403 = QUVnUpnrCYQmGTeKnEMsqHIfO13990530;     QUVnUpnrCYQmGTeKnEMsqHIfO13990530 = QUVnUpnrCYQmGTeKnEMsqHIfO9875531;     QUVnUpnrCYQmGTeKnEMsqHIfO9875531 = QUVnUpnrCYQmGTeKnEMsqHIfO44644985;     QUVnUpnrCYQmGTeKnEMsqHIfO44644985 = QUVnUpnrCYQmGTeKnEMsqHIfO75373423;     QUVnUpnrCYQmGTeKnEMsqHIfO75373423 = QUVnUpnrCYQmGTeKnEMsqHIfO53974377;     QUVnUpnrCYQmGTeKnEMsqHIfO53974377 = QUVnUpnrCYQmGTeKnEMsqHIfO13698580;     QUVnUpnrCYQmGTeKnEMsqHIfO13698580 = QUVnUpnrCYQmGTeKnEMsqHIfO21436022;     QUVnUpnrCYQmGTeKnEMsqHIfO21436022 = QUVnUpnrCYQmGTeKnEMsqHIfO44225688;     QUVnUpnrCYQmGTeKnEMsqHIfO44225688 = QUVnUpnrCYQmGTeKnEMsqHIfO93659507;     QUVnUpnrCYQmGTeKnEMsqHIfO93659507 = QUVnUpnrCYQmGTeKnEMsqHIfO27886523;     QUVnUpnrCYQmGTeKnEMsqHIfO27886523 = QUVnUpnrCYQmGTeKnEMsqHIfO27909183;     QUVnUpnrCYQmGTeKnEMsqHIfO27909183 = QUVnUpnrCYQmGTeKnEMsqHIfO46161962;     QUVnUpnrCYQmGTeKnEMsqHIfO46161962 = QUVnUpnrCYQmGTeKnEMsqHIfO55054313;     QUVnUpnrCYQmGTeKnEMsqHIfO55054313 = QUVnUpnrCYQmGTeKnEMsqHIfO71702037;     QUVnUpnrCYQmGTeKnEMsqHIfO71702037 = QUVnUpnrCYQmGTeKnEMsqHIfO87566994;     QUVnUpnrCYQmGTeKnEMsqHIfO87566994 = QUVnUpnrCYQmGTeKnEMsqHIfO16707977;     QUVnUpnrCYQmGTeKnEMsqHIfO16707977 = QUVnUpnrCYQmGTeKnEMsqHIfO74380946;     QUVnUpnrCYQmGTeKnEMsqHIfO74380946 = QUVnUpnrCYQmGTeKnEMsqHIfO98396587;     QUVnUpnrCYQmGTeKnEMsqHIfO98396587 = QUVnUpnrCYQmGTeKnEMsqHIfO11177731;     QUVnUpnrCYQmGTeKnEMsqHIfO11177731 = QUVnUpnrCYQmGTeKnEMsqHIfO55804387;     QUVnUpnrCYQmGTeKnEMsqHIfO55804387 = QUVnUpnrCYQmGTeKnEMsqHIfO99166592;     QUVnUpnrCYQmGTeKnEMsqHIfO99166592 = QUVnUpnrCYQmGTeKnEMsqHIfO70731107;     QUVnUpnrCYQmGTeKnEMsqHIfO70731107 = QUVnUpnrCYQmGTeKnEMsqHIfO53069312;     QUVnUpnrCYQmGTeKnEMsqHIfO53069312 = QUVnUpnrCYQmGTeKnEMsqHIfO54695050;     QUVnUpnrCYQmGTeKnEMsqHIfO54695050 = QUVnUpnrCYQmGTeKnEMsqHIfO93042165;     QUVnUpnrCYQmGTeKnEMsqHIfO93042165 = QUVnUpnrCYQmGTeKnEMsqHIfO70308423;     QUVnUpnrCYQmGTeKnEMsqHIfO70308423 = QUVnUpnrCYQmGTeKnEMsqHIfO32047636;     QUVnUpnrCYQmGTeKnEMsqHIfO32047636 = QUVnUpnrCYQmGTeKnEMsqHIfO61939439;     QUVnUpnrCYQmGTeKnEMsqHIfO61939439 = QUVnUpnrCYQmGTeKnEMsqHIfO99157232;     QUVnUpnrCYQmGTeKnEMsqHIfO99157232 = QUVnUpnrCYQmGTeKnEMsqHIfO95895001;     QUVnUpnrCYQmGTeKnEMsqHIfO95895001 = QUVnUpnrCYQmGTeKnEMsqHIfO2078996;     QUVnUpnrCYQmGTeKnEMsqHIfO2078996 = QUVnUpnrCYQmGTeKnEMsqHIfO24186231;     QUVnUpnrCYQmGTeKnEMsqHIfO24186231 = QUVnUpnrCYQmGTeKnEMsqHIfO48313112;     QUVnUpnrCYQmGTeKnEMsqHIfO48313112 = QUVnUpnrCYQmGTeKnEMsqHIfO58444218;     QUVnUpnrCYQmGTeKnEMsqHIfO58444218 = QUVnUpnrCYQmGTeKnEMsqHIfO38066777;     QUVnUpnrCYQmGTeKnEMsqHIfO38066777 = QUVnUpnrCYQmGTeKnEMsqHIfO5915554;     QUVnUpnrCYQmGTeKnEMsqHIfO5915554 = QUVnUpnrCYQmGTeKnEMsqHIfO1760719;     QUVnUpnrCYQmGTeKnEMsqHIfO1760719 = QUVnUpnrCYQmGTeKnEMsqHIfO34030308;     QUVnUpnrCYQmGTeKnEMsqHIfO34030308 = QUVnUpnrCYQmGTeKnEMsqHIfO24003712;     QUVnUpnrCYQmGTeKnEMsqHIfO24003712 = QUVnUpnrCYQmGTeKnEMsqHIfO38170493;     QUVnUpnrCYQmGTeKnEMsqHIfO38170493 = QUVnUpnrCYQmGTeKnEMsqHIfO93426671;     QUVnUpnrCYQmGTeKnEMsqHIfO93426671 = QUVnUpnrCYQmGTeKnEMsqHIfO42888351;     QUVnUpnrCYQmGTeKnEMsqHIfO42888351 = QUVnUpnrCYQmGTeKnEMsqHIfO6445769;     QUVnUpnrCYQmGTeKnEMsqHIfO6445769 = QUVnUpnrCYQmGTeKnEMsqHIfO61924197;     QUVnUpnrCYQmGTeKnEMsqHIfO61924197 = QUVnUpnrCYQmGTeKnEMsqHIfO38688992;     QUVnUpnrCYQmGTeKnEMsqHIfO38688992 = QUVnUpnrCYQmGTeKnEMsqHIfO7128158;     QUVnUpnrCYQmGTeKnEMsqHIfO7128158 = QUVnUpnrCYQmGTeKnEMsqHIfO69680213;     QUVnUpnrCYQmGTeKnEMsqHIfO69680213 = QUVnUpnrCYQmGTeKnEMsqHIfO40856736;     QUVnUpnrCYQmGTeKnEMsqHIfO40856736 = QUVnUpnrCYQmGTeKnEMsqHIfO48397284;     QUVnUpnrCYQmGTeKnEMsqHIfO48397284 = QUVnUpnrCYQmGTeKnEMsqHIfO5490847;     QUVnUpnrCYQmGTeKnEMsqHIfO5490847 = QUVnUpnrCYQmGTeKnEMsqHIfO78879994;     QUVnUpnrCYQmGTeKnEMsqHIfO78879994 = QUVnUpnrCYQmGTeKnEMsqHIfO86935902;     QUVnUpnrCYQmGTeKnEMsqHIfO86935902 = QUVnUpnrCYQmGTeKnEMsqHIfO59823491;     QUVnUpnrCYQmGTeKnEMsqHIfO59823491 = QUVnUpnrCYQmGTeKnEMsqHIfO49521414;     QUVnUpnrCYQmGTeKnEMsqHIfO49521414 = QUVnUpnrCYQmGTeKnEMsqHIfO97600810;     QUVnUpnrCYQmGTeKnEMsqHIfO97600810 = QUVnUpnrCYQmGTeKnEMsqHIfO43259423;     QUVnUpnrCYQmGTeKnEMsqHIfO43259423 = QUVnUpnrCYQmGTeKnEMsqHIfO56806218;     QUVnUpnrCYQmGTeKnEMsqHIfO56806218 = QUVnUpnrCYQmGTeKnEMsqHIfO89949934;     QUVnUpnrCYQmGTeKnEMsqHIfO89949934 = QUVnUpnrCYQmGTeKnEMsqHIfO82331258;     QUVnUpnrCYQmGTeKnEMsqHIfO82331258 = QUVnUpnrCYQmGTeKnEMsqHIfO83665953;     QUVnUpnrCYQmGTeKnEMsqHIfO83665953 = QUVnUpnrCYQmGTeKnEMsqHIfO81650944;     QUVnUpnrCYQmGTeKnEMsqHIfO81650944 = QUVnUpnrCYQmGTeKnEMsqHIfO59496583;     QUVnUpnrCYQmGTeKnEMsqHIfO59496583 = QUVnUpnrCYQmGTeKnEMsqHIfO45068455;     QUVnUpnrCYQmGTeKnEMsqHIfO45068455 = QUVnUpnrCYQmGTeKnEMsqHIfO97764505;     QUVnUpnrCYQmGTeKnEMsqHIfO97764505 = QUVnUpnrCYQmGTeKnEMsqHIfO25807527;     QUVnUpnrCYQmGTeKnEMsqHIfO25807527 = QUVnUpnrCYQmGTeKnEMsqHIfO3722952;     QUVnUpnrCYQmGTeKnEMsqHIfO3722952 = QUVnUpnrCYQmGTeKnEMsqHIfO97848850;     QUVnUpnrCYQmGTeKnEMsqHIfO97848850 = QUVnUpnrCYQmGTeKnEMsqHIfO96610095;     QUVnUpnrCYQmGTeKnEMsqHIfO96610095 = QUVnUpnrCYQmGTeKnEMsqHIfO33635260;     QUVnUpnrCYQmGTeKnEMsqHIfO33635260 = QUVnUpnrCYQmGTeKnEMsqHIfO81651441;     QUVnUpnrCYQmGTeKnEMsqHIfO81651441 = QUVnUpnrCYQmGTeKnEMsqHIfO14947258;     QUVnUpnrCYQmGTeKnEMsqHIfO14947258 = QUVnUpnrCYQmGTeKnEMsqHIfO40350639;     QUVnUpnrCYQmGTeKnEMsqHIfO40350639 = QUVnUpnrCYQmGTeKnEMsqHIfO74392875;     QUVnUpnrCYQmGTeKnEMsqHIfO74392875 = QUVnUpnrCYQmGTeKnEMsqHIfO73007238;     QUVnUpnrCYQmGTeKnEMsqHIfO73007238 = QUVnUpnrCYQmGTeKnEMsqHIfO62377716;     QUVnUpnrCYQmGTeKnEMsqHIfO62377716 = QUVnUpnrCYQmGTeKnEMsqHIfO56278242;     QUVnUpnrCYQmGTeKnEMsqHIfO56278242 = QUVnUpnrCYQmGTeKnEMsqHIfO64285338;     QUVnUpnrCYQmGTeKnEMsqHIfO64285338 = QUVnUpnrCYQmGTeKnEMsqHIfO91145115;     QUVnUpnrCYQmGTeKnEMsqHIfO91145115 = QUVnUpnrCYQmGTeKnEMsqHIfO55211621;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void UBtdqICEuFHSnEpXSkaTqhaVTDesHyiToQbXcVyzalUDREdDMFwqJDGna20930512() {     long YJmdKxwXodXcRvwlatFMWEPab90670589 = -190210257;    long YJmdKxwXodXcRvwlatFMWEPab65329385 = 64502472;    long YJmdKxwXodXcRvwlatFMWEPab53177561 = -658756761;    long YJmdKxwXodXcRvwlatFMWEPab18629059 = -918051172;    long YJmdKxwXodXcRvwlatFMWEPab65689000 = -956635137;    long YJmdKxwXodXcRvwlatFMWEPab14200961 = -232017649;    long YJmdKxwXodXcRvwlatFMWEPab62526478 = -657560655;    long YJmdKxwXodXcRvwlatFMWEPab76994253 = -477660110;    long YJmdKxwXodXcRvwlatFMWEPab88631643 = -780341269;    long YJmdKxwXodXcRvwlatFMWEPab15007988 = -677978323;    long YJmdKxwXodXcRvwlatFMWEPab27992455 = -132730250;    long YJmdKxwXodXcRvwlatFMWEPab67166322 = -921239874;    long YJmdKxwXodXcRvwlatFMWEPab91524765 = 88190190;    long YJmdKxwXodXcRvwlatFMWEPab77875389 = -846444785;    long YJmdKxwXodXcRvwlatFMWEPab70753288 = -934735475;    long YJmdKxwXodXcRvwlatFMWEPab19505579 = -192096258;    long YJmdKxwXodXcRvwlatFMWEPab78034759 = -905259517;    long YJmdKxwXodXcRvwlatFMWEPab53021131 = -700197097;    long YJmdKxwXodXcRvwlatFMWEPab85882819 = -240544565;    long YJmdKxwXodXcRvwlatFMWEPab64838440 = -231067178;    long YJmdKxwXodXcRvwlatFMWEPab18412664 = -259991313;    long YJmdKxwXodXcRvwlatFMWEPab188928 = -702009856;    long YJmdKxwXodXcRvwlatFMWEPab84515909 = -535559805;    long YJmdKxwXodXcRvwlatFMWEPab3668476 = -707053304;    long YJmdKxwXodXcRvwlatFMWEPab52662936 = -944548964;    long YJmdKxwXodXcRvwlatFMWEPab86071595 = 45627462;    long YJmdKxwXodXcRvwlatFMWEPab14394951 = -910304659;    long YJmdKxwXodXcRvwlatFMWEPab54427004 = -745949265;    long YJmdKxwXodXcRvwlatFMWEPab68104236 = -336121510;    long YJmdKxwXodXcRvwlatFMWEPab49759099 = -79528387;    long YJmdKxwXodXcRvwlatFMWEPab12242739 = -593399814;    long YJmdKxwXodXcRvwlatFMWEPab65709541 = -318423157;    long YJmdKxwXodXcRvwlatFMWEPab40127193 = -278881051;    long YJmdKxwXodXcRvwlatFMWEPab75910388 = -342421685;    long YJmdKxwXodXcRvwlatFMWEPab20862767 = -137717612;    long YJmdKxwXodXcRvwlatFMWEPab23262881 = -153975542;    long YJmdKxwXodXcRvwlatFMWEPab36978811 = 48719130;    long YJmdKxwXodXcRvwlatFMWEPab67923380 = 12404902;    long YJmdKxwXodXcRvwlatFMWEPab4771508 = -145377576;    long YJmdKxwXodXcRvwlatFMWEPab62668120 = -999839791;    long YJmdKxwXodXcRvwlatFMWEPab44629338 = -980954429;    long YJmdKxwXodXcRvwlatFMWEPab45169514 = -477236528;    long YJmdKxwXodXcRvwlatFMWEPab88549971 = -120218459;    long YJmdKxwXodXcRvwlatFMWEPab10862446 = -514703729;    long YJmdKxwXodXcRvwlatFMWEPab53085771 = -433077596;    long YJmdKxwXodXcRvwlatFMWEPab656379 = -611816674;    long YJmdKxwXodXcRvwlatFMWEPab12387329 = -26023207;    long YJmdKxwXodXcRvwlatFMWEPab88034735 = -32025385;    long YJmdKxwXodXcRvwlatFMWEPab54940302 = -788569398;    long YJmdKxwXodXcRvwlatFMWEPab86469028 = -16420537;    long YJmdKxwXodXcRvwlatFMWEPab79927956 = -692911977;    long YJmdKxwXodXcRvwlatFMWEPab79380473 = -900728441;    long YJmdKxwXodXcRvwlatFMWEPab70700144 = -113003753;    long YJmdKxwXodXcRvwlatFMWEPab40178078 = -579863665;    long YJmdKxwXodXcRvwlatFMWEPab2517848 = -741177256;    long YJmdKxwXodXcRvwlatFMWEPab90481661 = -488200402;    long YJmdKxwXodXcRvwlatFMWEPab80813475 = -399937724;    long YJmdKxwXodXcRvwlatFMWEPab49509085 = -951703458;    long YJmdKxwXodXcRvwlatFMWEPab65966122 = -973502209;    long YJmdKxwXodXcRvwlatFMWEPab79617405 = -902262600;    long YJmdKxwXodXcRvwlatFMWEPab99806010 = -321712991;    long YJmdKxwXodXcRvwlatFMWEPab8099474 = -911611391;    long YJmdKxwXodXcRvwlatFMWEPab8890018 = -41538600;    long YJmdKxwXodXcRvwlatFMWEPab38872545 = -600812883;    long YJmdKxwXodXcRvwlatFMWEPab2765249 = 15421491;    long YJmdKxwXodXcRvwlatFMWEPab62282914 = -814307094;    long YJmdKxwXodXcRvwlatFMWEPab27039129 = -542358823;    long YJmdKxwXodXcRvwlatFMWEPab15614377 = -569388125;    long YJmdKxwXodXcRvwlatFMWEPab57012623 = -608727174;    long YJmdKxwXodXcRvwlatFMWEPab47490408 = -680759933;    long YJmdKxwXodXcRvwlatFMWEPab82526768 = -140815388;    long YJmdKxwXodXcRvwlatFMWEPab10111380 = -817664419;    long YJmdKxwXodXcRvwlatFMWEPab48249624 = -454819521;    long YJmdKxwXodXcRvwlatFMWEPab23214700 = -240704775;    long YJmdKxwXodXcRvwlatFMWEPab20209102 = -250112749;    long YJmdKxwXodXcRvwlatFMWEPab73243150 = -782754786;    long YJmdKxwXodXcRvwlatFMWEPab11638957 = -481791397;    long YJmdKxwXodXcRvwlatFMWEPab73653464 = 79143924;    long YJmdKxwXodXcRvwlatFMWEPab50582704 = -173975708;    long YJmdKxwXodXcRvwlatFMWEPab52006557 = -232732290;    long YJmdKxwXodXcRvwlatFMWEPab73684266 = -928349331;    long YJmdKxwXodXcRvwlatFMWEPab26360216 = -778279274;    long YJmdKxwXodXcRvwlatFMWEPab99486702 = -957379867;    long YJmdKxwXodXcRvwlatFMWEPab81635208 = -219700974;    long YJmdKxwXodXcRvwlatFMWEPab69831142 = -386616410;    long YJmdKxwXodXcRvwlatFMWEPab32862265 = -692671373;    long YJmdKxwXodXcRvwlatFMWEPab95009396 = -105419404;    long YJmdKxwXodXcRvwlatFMWEPab99949115 = -699017387;    long YJmdKxwXodXcRvwlatFMWEPab73392541 = -601244429;    long YJmdKxwXodXcRvwlatFMWEPab30381105 = -649517210;    long YJmdKxwXodXcRvwlatFMWEPab42449405 = -754037819;    long YJmdKxwXodXcRvwlatFMWEPab87469725 = 422587;    long YJmdKxwXodXcRvwlatFMWEPab1957258 = -14092890;    long YJmdKxwXodXcRvwlatFMWEPab25154103 = -243114976;    long YJmdKxwXodXcRvwlatFMWEPab62862109 = -578126801;    long YJmdKxwXodXcRvwlatFMWEPab36529864 = 30656961;    long YJmdKxwXodXcRvwlatFMWEPab36279497 = -335697929;    long YJmdKxwXodXcRvwlatFMWEPab49677426 = -519405577;    long YJmdKxwXodXcRvwlatFMWEPab8097197 = -430125220;    long YJmdKxwXodXcRvwlatFMWEPab90802857 = -190210257;     YJmdKxwXodXcRvwlatFMWEPab90670589 = YJmdKxwXodXcRvwlatFMWEPab65329385;     YJmdKxwXodXcRvwlatFMWEPab65329385 = YJmdKxwXodXcRvwlatFMWEPab53177561;     YJmdKxwXodXcRvwlatFMWEPab53177561 = YJmdKxwXodXcRvwlatFMWEPab18629059;     YJmdKxwXodXcRvwlatFMWEPab18629059 = YJmdKxwXodXcRvwlatFMWEPab65689000;     YJmdKxwXodXcRvwlatFMWEPab65689000 = YJmdKxwXodXcRvwlatFMWEPab14200961;     YJmdKxwXodXcRvwlatFMWEPab14200961 = YJmdKxwXodXcRvwlatFMWEPab62526478;     YJmdKxwXodXcRvwlatFMWEPab62526478 = YJmdKxwXodXcRvwlatFMWEPab76994253;     YJmdKxwXodXcRvwlatFMWEPab76994253 = YJmdKxwXodXcRvwlatFMWEPab88631643;     YJmdKxwXodXcRvwlatFMWEPab88631643 = YJmdKxwXodXcRvwlatFMWEPab15007988;     YJmdKxwXodXcRvwlatFMWEPab15007988 = YJmdKxwXodXcRvwlatFMWEPab27992455;     YJmdKxwXodXcRvwlatFMWEPab27992455 = YJmdKxwXodXcRvwlatFMWEPab67166322;     YJmdKxwXodXcRvwlatFMWEPab67166322 = YJmdKxwXodXcRvwlatFMWEPab91524765;     YJmdKxwXodXcRvwlatFMWEPab91524765 = YJmdKxwXodXcRvwlatFMWEPab77875389;     YJmdKxwXodXcRvwlatFMWEPab77875389 = YJmdKxwXodXcRvwlatFMWEPab70753288;     YJmdKxwXodXcRvwlatFMWEPab70753288 = YJmdKxwXodXcRvwlatFMWEPab19505579;     YJmdKxwXodXcRvwlatFMWEPab19505579 = YJmdKxwXodXcRvwlatFMWEPab78034759;     YJmdKxwXodXcRvwlatFMWEPab78034759 = YJmdKxwXodXcRvwlatFMWEPab53021131;     YJmdKxwXodXcRvwlatFMWEPab53021131 = YJmdKxwXodXcRvwlatFMWEPab85882819;     YJmdKxwXodXcRvwlatFMWEPab85882819 = YJmdKxwXodXcRvwlatFMWEPab64838440;     YJmdKxwXodXcRvwlatFMWEPab64838440 = YJmdKxwXodXcRvwlatFMWEPab18412664;     YJmdKxwXodXcRvwlatFMWEPab18412664 = YJmdKxwXodXcRvwlatFMWEPab188928;     YJmdKxwXodXcRvwlatFMWEPab188928 = YJmdKxwXodXcRvwlatFMWEPab84515909;     YJmdKxwXodXcRvwlatFMWEPab84515909 = YJmdKxwXodXcRvwlatFMWEPab3668476;     YJmdKxwXodXcRvwlatFMWEPab3668476 = YJmdKxwXodXcRvwlatFMWEPab52662936;     YJmdKxwXodXcRvwlatFMWEPab52662936 = YJmdKxwXodXcRvwlatFMWEPab86071595;     YJmdKxwXodXcRvwlatFMWEPab86071595 = YJmdKxwXodXcRvwlatFMWEPab14394951;     YJmdKxwXodXcRvwlatFMWEPab14394951 = YJmdKxwXodXcRvwlatFMWEPab54427004;     YJmdKxwXodXcRvwlatFMWEPab54427004 = YJmdKxwXodXcRvwlatFMWEPab68104236;     YJmdKxwXodXcRvwlatFMWEPab68104236 = YJmdKxwXodXcRvwlatFMWEPab49759099;     YJmdKxwXodXcRvwlatFMWEPab49759099 = YJmdKxwXodXcRvwlatFMWEPab12242739;     YJmdKxwXodXcRvwlatFMWEPab12242739 = YJmdKxwXodXcRvwlatFMWEPab65709541;     YJmdKxwXodXcRvwlatFMWEPab65709541 = YJmdKxwXodXcRvwlatFMWEPab40127193;     YJmdKxwXodXcRvwlatFMWEPab40127193 = YJmdKxwXodXcRvwlatFMWEPab75910388;     YJmdKxwXodXcRvwlatFMWEPab75910388 = YJmdKxwXodXcRvwlatFMWEPab20862767;     YJmdKxwXodXcRvwlatFMWEPab20862767 = YJmdKxwXodXcRvwlatFMWEPab23262881;     YJmdKxwXodXcRvwlatFMWEPab23262881 = YJmdKxwXodXcRvwlatFMWEPab36978811;     YJmdKxwXodXcRvwlatFMWEPab36978811 = YJmdKxwXodXcRvwlatFMWEPab67923380;     YJmdKxwXodXcRvwlatFMWEPab67923380 = YJmdKxwXodXcRvwlatFMWEPab4771508;     YJmdKxwXodXcRvwlatFMWEPab4771508 = YJmdKxwXodXcRvwlatFMWEPab62668120;     YJmdKxwXodXcRvwlatFMWEPab62668120 = YJmdKxwXodXcRvwlatFMWEPab44629338;     YJmdKxwXodXcRvwlatFMWEPab44629338 = YJmdKxwXodXcRvwlatFMWEPab45169514;     YJmdKxwXodXcRvwlatFMWEPab45169514 = YJmdKxwXodXcRvwlatFMWEPab88549971;     YJmdKxwXodXcRvwlatFMWEPab88549971 = YJmdKxwXodXcRvwlatFMWEPab10862446;     YJmdKxwXodXcRvwlatFMWEPab10862446 = YJmdKxwXodXcRvwlatFMWEPab53085771;     YJmdKxwXodXcRvwlatFMWEPab53085771 = YJmdKxwXodXcRvwlatFMWEPab656379;     YJmdKxwXodXcRvwlatFMWEPab656379 = YJmdKxwXodXcRvwlatFMWEPab12387329;     YJmdKxwXodXcRvwlatFMWEPab12387329 = YJmdKxwXodXcRvwlatFMWEPab88034735;     YJmdKxwXodXcRvwlatFMWEPab88034735 = YJmdKxwXodXcRvwlatFMWEPab54940302;     YJmdKxwXodXcRvwlatFMWEPab54940302 = YJmdKxwXodXcRvwlatFMWEPab86469028;     YJmdKxwXodXcRvwlatFMWEPab86469028 = YJmdKxwXodXcRvwlatFMWEPab79927956;     YJmdKxwXodXcRvwlatFMWEPab79927956 = YJmdKxwXodXcRvwlatFMWEPab79380473;     YJmdKxwXodXcRvwlatFMWEPab79380473 = YJmdKxwXodXcRvwlatFMWEPab70700144;     YJmdKxwXodXcRvwlatFMWEPab70700144 = YJmdKxwXodXcRvwlatFMWEPab40178078;     YJmdKxwXodXcRvwlatFMWEPab40178078 = YJmdKxwXodXcRvwlatFMWEPab2517848;     YJmdKxwXodXcRvwlatFMWEPab2517848 = YJmdKxwXodXcRvwlatFMWEPab90481661;     YJmdKxwXodXcRvwlatFMWEPab90481661 = YJmdKxwXodXcRvwlatFMWEPab80813475;     YJmdKxwXodXcRvwlatFMWEPab80813475 = YJmdKxwXodXcRvwlatFMWEPab49509085;     YJmdKxwXodXcRvwlatFMWEPab49509085 = YJmdKxwXodXcRvwlatFMWEPab65966122;     YJmdKxwXodXcRvwlatFMWEPab65966122 = YJmdKxwXodXcRvwlatFMWEPab79617405;     YJmdKxwXodXcRvwlatFMWEPab79617405 = YJmdKxwXodXcRvwlatFMWEPab99806010;     YJmdKxwXodXcRvwlatFMWEPab99806010 = YJmdKxwXodXcRvwlatFMWEPab8099474;     YJmdKxwXodXcRvwlatFMWEPab8099474 = YJmdKxwXodXcRvwlatFMWEPab8890018;     YJmdKxwXodXcRvwlatFMWEPab8890018 = YJmdKxwXodXcRvwlatFMWEPab38872545;     YJmdKxwXodXcRvwlatFMWEPab38872545 = YJmdKxwXodXcRvwlatFMWEPab2765249;     YJmdKxwXodXcRvwlatFMWEPab2765249 = YJmdKxwXodXcRvwlatFMWEPab62282914;     YJmdKxwXodXcRvwlatFMWEPab62282914 = YJmdKxwXodXcRvwlatFMWEPab27039129;     YJmdKxwXodXcRvwlatFMWEPab27039129 = YJmdKxwXodXcRvwlatFMWEPab15614377;     YJmdKxwXodXcRvwlatFMWEPab15614377 = YJmdKxwXodXcRvwlatFMWEPab57012623;     YJmdKxwXodXcRvwlatFMWEPab57012623 = YJmdKxwXodXcRvwlatFMWEPab47490408;     YJmdKxwXodXcRvwlatFMWEPab47490408 = YJmdKxwXodXcRvwlatFMWEPab82526768;     YJmdKxwXodXcRvwlatFMWEPab82526768 = YJmdKxwXodXcRvwlatFMWEPab10111380;     YJmdKxwXodXcRvwlatFMWEPab10111380 = YJmdKxwXodXcRvwlatFMWEPab48249624;     YJmdKxwXodXcRvwlatFMWEPab48249624 = YJmdKxwXodXcRvwlatFMWEPab23214700;     YJmdKxwXodXcRvwlatFMWEPab23214700 = YJmdKxwXodXcRvwlatFMWEPab20209102;     YJmdKxwXodXcRvwlatFMWEPab20209102 = YJmdKxwXodXcRvwlatFMWEPab73243150;     YJmdKxwXodXcRvwlatFMWEPab73243150 = YJmdKxwXodXcRvwlatFMWEPab11638957;     YJmdKxwXodXcRvwlatFMWEPab11638957 = YJmdKxwXodXcRvwlatFMWEPab73653464;     YJmdKxwXodXcRvwlatFMWEPab73653464 = YJmdKxwXodXcRvwlatFMWEPab50582704;     YJmdKxwXodXcRvwlatFMWEPab50582704 = YJmdKxwXodXcRvwlatFMWEPab52006557;     YJmdKxwXodXcRvwlatFMWEPab52006557 = YJmdKxwXodXcRvwlatFMWEPab73684266;     YJmdKxwXodXcRvwlatFMWEPab73684266 = YJmdKxwXodXcRvwlatFMWEPab26360216;     YJmdKxwXodXcRvwlatFMWEPab26360216 = YJmdKxwXodXcRvwlatFMWEPab99486702;     YJmdKxwXodXcRvwlatFMWEPab99486702 = YJmdKxwXodXcRvwlatFMWEPab81635208;     YJmdKxwXodXcRvwlatFMWEPab81635208 = YJmdKxwXodXcRvwlatFMWEPab69831142;     YJmdKxwXodXcRvwlatFMWEPab69831142 = YJmdKxwXodXcRvwlatFMWEPab32862265;     YJmdKxwXodXcRvwlatFMWEPab32862265 = YJmdKxwXodXcRvwlatFMWEPab95009396;     YJmdKxwXodXcRvwlatFMWEPab95009396 = YJmdKxwXodXcRvwlatFMWEPab99949115;     YJmdKxwXodXcRvwlatFMWEPab99949115 = YJmdKxwXodXcRvwlatFMWEPab73392541;     YJmdKxwXodXcRvwlatFMWEPab73392541 = YJmdKxwXodXcRvwlatFMWEPab30381105;     YJmdKxwXodXcRvwlatFMWEPab30381105 = YJmdKxwXodXcRvwlatFMWEPab42449405;     YJmdKxwXodXcRvwlatFMWEPab42449405 = YJmdKxwXodXcRvwlatFMWEPab87469725;     YJmdKxwXodXcRvwlatFMWEPab87469725 = YJmdKxwXodXcRvwlatFMWEPab1957258;     YJmdKxwXodXcRvwlatFMWEPab1957258 = YJmdKxwXodXcRvwlatFMWEPab25154103;     YJmdKxwXodXcRvwlatFMWEPab25154103 = YJmdKxwXodXcRvwlatFMWEPab62862109;     YJmdKxwXodXcRvwlatFMWEPab62862109 = YJmdKxwXodXcRvwlatFMWEPab36529864;     YJmdKxwXodXcRvwlatFMWEPab36529864 = YJmdKxwXodXcRvwlatFMWEPab36279497;     YJmdKxwXodXcRvwlatFMWEPab36279497 = YJmdKxwXodXcRvwlatFMWEPab49677426;     YJmdKxwXodXcRvwlatFMWEPab49677426 = YJmdKxwXodXcRvwlatFMWEPab8097197;     YJmdKxwXodXcRvwlatFMWEPab8097197 = YJmdKxwXodXcRvwlatFMWEPab90802857;     YJmdKxwXodXcRvwlatFMWEPab90802857 = YJmdKxwXodXcRvwlatFMWEPab90670589;}
// Junk Finished
